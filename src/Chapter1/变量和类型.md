# 变量和类型

1. JavaScript 规定了几种语言类型？**[#](#1-javascript-规定了几种语言类型？)**

2. JavaScript 对象的底层数据结构是什么？**[#](#2-javascript-对象的底层数据结构是什么？)**

3. `Symbol` 类型在实际开发中的应用、可手动实现一个简单的 `Symbol`？**[#](#3-symbol-类型在实际开发中的应用？)**

4. JavaScript 中的变量在内存中的具体存储形式？**[#](#4-javascript-变量类型在内存中的具体存储形式？)**

5. 基本类型对应的内置对象，以及他们之间的装箱拆箱操作？**[#](#5-基本类型对应的内置对象，以及他们之间的装箱拆箱操作？)**

6. 理解值类型和引用类型？**[#](#6-理解值类型和引用类型？)**

7. `null` 和 `undefined` 的区别？**[#](#7-null-和-undefined-的区别？)**

8. 至少可以说出三种判断 `JavaScript` 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型？**[#](#8-至少说出三种判断-javascript-数据类型的方式，以及他们的优缺点，如何准确的判断数组类型？)**

9. 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用？**[#](#9-可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用？)**

10. 出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript 处理大数字的方法、避免精度丢失的方法？**[#](#10-出现小数精度丢失的原因，javascript-可以存储的最大数字、最大安全数字，javascript-处理大数字的方法、避免精度丢失的方法？)**

## 1. JavaScript 规定了几种语言类型？

JavaScript 规定了两种数据类型：
- **原始类型：** `string`、`number`、`boolean` 、`null`、`undefined`、`symbol`

- **引用类型：** `Object`、`Function`、`Array`


## 2. JavaScript 对象的底层数据结构是什么？

## 3. Symbol 类型在实际开发中的应用？

## 4. JavaScript 变量类型在内存中的具体存储形式？

- **基本类型：** 保存在`栈`内存中，通过按值访问，值都有固定的大小。

- **引用类型：** 保存在`堆`内存中，通过按引用访问（不允许直接访问堆内存），值大小不固定。

```js
let a: string = "123"; // 栈内存
let b: number = 123; // 栈内存
let c: null = null; // 栈内存
let d: object = { x: 10 }; // 变量d存在于栈中，{ x: 10 }作为对象存在于堆中
let e = [1, 2, 3]; // 变量e存在于栈中，[1, 2, 3]作为对象存在于堆中
```
如图所示：

![屏幕快照 2019-09-20 下午3.26.23.png](https://i.loli.net/2019/09/20/Cu3irzOYkqGFfsD.png)

拓展：

- **原始类型**的比较是值的比较，只有它们的值相等时才相等。

- **引用类型**的比较是按引用的比较，当且仅当它们引用同一个基本对象时，它们才相等。

## 5. 基本类型对应的内置对象，以及他们之间的装箱拆箱操作？

## 6. 理解值类型和引用类型？

## 7. null 和 undefined 的区别？
**null** 表示`"空对象"`，即此处应该有值：
```js 
- 在 if 语句中，会转换为 false.
- 转换为数字时，表示为 0。
- 作为函数的参数，表示该函数的参数不是对象。
- 作为对象原型链的终点 Object.getPrototypeOf(Object.prototype);
```
**undefined** 表示  `"缺少值"`，就是此处应该有一个值，但是还没有定义：
```js
- 在 if 语句中，会转换为 false.
- 转换为数字时，表示为 NaN.
- 变量被声明了，但没有被赋值，就等于 undefined.
- 调用函数时，没有提供对应的实参，该参数显示为 undefined.
- 对象没有赋值的属性，该属性的值为 undefined.
- 函数没有返回值时，默认返回 undefined.
```
拓展：
```html
typeof null 为 "object" 的解释：
不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型。
null 的二进制表示都是 0，自然前三位都是 0，所以执行 typeof null 时，会返回 ”object”。
```

## 8. 至少说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型？

### typeof
`typeof`是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。
```js
typeof '';             // string 有效
typeof 1;              // number 有效
typeof Symbol();       // symbol 有效
typeof true;           // boolean 有效
typeof undefined;      // undefined 有效
typeof null;           // object 无效
typeof [] ;            // object 无效
typeof new Function(); // function 有效
typeof new Date();     // object 无效
typeof new RegExp();   // object 无效
```
**缺点：** 
```js
typeof 对于引用类型中的数组、日期、正则等类型的处理，只返回了处于其原型链最顶端的 Object 类型；
对应 null 返回的是 "object"，而 null 有自己的数据类型 Null。
```
### instanceof
`instanceof` 是用来判断 `a` 是否为 `B` 的实例，表达式为：`a instanceof B`，如果 `a` 是 `B` 的实例，则返回 `true`，否则返回 `false`。 **在这里需要特别注意的是：`instanceof` 检测的是原型对象。**
```js
// 伪代码实现
instanceof (a,B) = {
    var L = a.__proto__;
    var R = B.prototype;
    if(L === R) {
        // A的内部属性 __proto__ 指向 B 的原型对象
        return true;
    }
    return false;
}
```
从上述过程可以看出，当 `a` 的 `__proto__` 指向 `B` 的原型对象时，就认为 `a` 就是 `B` 的实例，我们再来看几个例子：
```js
[] instanceof Array; // true
{} instanceof Object;// true
new Date() instanceof Date;// true
 
function Person(){};
new Person() instanceof Person;
 
[] instanceof Object; // true
new Date() instanceof Object;// true
new Person instanceof Object;// true
```
我们发现，虽然 `instanceof` 能够判断出 `[]` 是 `Array` 的实例，但它认为 `[]` 也是 `Object` 的实例，为什么呢？

我们来分析一下 `[]`、`Array`、`Object` 三者之间的关系：

从 `instanceof` 能够判断出 `[].__proto__`  指向 `Array.prototype`，而 `Array.prototype.__proto__` 又指向了 `Object.prototype`，最终 `Object.prototype.__proto__`指向了 `null`，标志着原型链的结束。

因此，`[]`、`Array`、`Object` 就在内部形成了一条原型链：

![849589-20160112232510850-2003340583.png](https://i.loli.net/2019/09/21/fevn2goItbBzqKc.png)

从原型链可以看出，`[]` 的 `__proto__`  直接指向 `Array.prototype`，间接指向 `Object.prototype`，所以按照 `instanceof` 的判断规则，`[]` 就是 `Object` 的实例。依次类推，类似的 `new Date()`、`new Person()` 也会形成一条对应的原型链 。

**缺点：**

```js
instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。
```

**拓展：**

`instanceof` 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

```js
var iframe = document.createElement('iframe');
document.body.appendChild(iframe);
xArray = window.frames[0].Array;
var arr = new xArray(1,2,3); // [1,2,3]
arr instanceof Array; // false
```
### Array.isArray()

针对数组的这个问题，ES5 提供了 `Array.isArray()` 方法。该方法用以确认某个对象本身是否为 `Array` 类型，而不区分该对象在哪个环境中创建。
```js
if (Array.isArray(value)){
   //对数组执行某些操作
}
```
`Array.isArray()` 本质上检测的是对象的 `[[Class]]` 值，`[[Class]]` 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 `[object Xxx]` ，`Xxx` 就是对应的具体类型。对于数组而言，`[[Class]]` 的值就是 [object Array] 。

### toStrig()

`toString()` 是 `Object` 的原型方法，调用该方法，默认返回当前对象的 `[[Class]]`。这是一个内部属性，其格式为 `[object Xxx]`，其中 `Xxx` 就是对象的类型。

对于 `Object` 对象，直接调用 `toString()` 就能返回 `[object Object]`。而对于其他对象，则需要通过 `call / apply` 来调用才能返回正确的类型信息。

```js
Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(Symbol()); //[object Symbol]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object Window] window 是全局对象 
```

### constructor

当一个函数 `F` 被定义时，JS 引擎会为 `F` 添加 `prototype` 原型对象，然后再在 `prototype`上添加一个 `constructor` 属性，并让其指向 `F` 的引用。

如下所示：

![849589-20170508125250566-1896556617.png](https://i.loli.net/2019/09/21/iFpwzxHVIlKDRJL.png)

当执行 `var f = new F()` 时，`F` 被当成了构造函数，`f` 是 `F` 的实例对象，此时 `F` 原型上的 `constructor` 传递到了 `f` 上，因此 `f.constructor == F`。

![849589-20170508125714941-1649387639.png](https://i.loli.net/2019/09/21/veHsCKjrDYIFUAW.png)

可以看出，`F` 利用原型对象上的 `constructor` 引用了自身，当 `F` 作为构造函数来创建对象时，原型上的 `constructor `就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 `F` 就是新对象的类型。**这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。**

同样，`JavaScript` 中的内置对象在内部构建时也是这样做的：

![849589-20170508131800457-2091987664.png](https://i.loli.net/2019/09/21/uHZb16KyLsComNq.png)

**细节问题：**

**`null` 和 `undefined` 是无效的对象，因此是不会有 `constructor` 存在的，这两种类型的数据需要通过其他方式来判断。**

函数的 `constructor` 是不稳定的，这个主要体现在自定义对象上，当开发者重写 `prototype` 后，原有的 `constructor` 引用会丢失，`constructor` 会默认为 `Object`。

![849589-20170508132757347-1999338357.png](https://i.loli.net/2019/09/21/9hrsbizMQag3kpI.png)


因为 `prototype` 被重新赋值的是一个 `{}`， `{}` 是 `new Object()` 的字面量，因此 `new Object()` 会将 `Object` 原型上的 `constructor` 传递给 `{}`，也就是 `Object` 本身。

因此，为了规范开发，在重写对象原型时一般都需要重新给 `constructor` 赋值，以保证对象实例的类型不被篡改。

**总结：**
- `typeof` 检测引用类型和 `null` 时，除了函数都会显示 `"object"`。
- 检测函数使用推荐使用 `typeof`。
- **instanceof：** 检测对象是否是某个构造函数的实例。
- **Array.isArray()：** 判断是否为 `Array` 数据类型时使用。
- **constructor：** 可以使用 `constructor` 属性验证实例的原始类型（与操作符 `instanceof` 非常类似）。
- **toString()：** 万能。

```js
检测对象的属性是否存在使用 in 运算符或者使用 Object.hasOwnProperty()
```

*本节参考：[一像素-判断数据类型的四种方法](https://www.cnblogs.com/onepixel/p/5126046.html)*

## 9. 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用？

### 自动转换为`boolean`类型的的情况：

|数据类型|转换之后的值|
|---|---|
|数字 0|false|
|NaN|  false
|空字符 ”|false
|null |	false
|undefined|	false
|非 0 数字|	true
|非空字符串	|true
|非 null 对象类型	|true

## 10. 出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript 处理大数字的方法、避免精度丢失的方法？
