# 执行机制

1. 为何 `try` 里面放 `return`，`finally` 还会执行，理解其内部机制。**[#](#1)**

2. JavaScript 如何实现异步编程，可以详细描述 `EventLoop` 机制。**[#](#2)**

3. 宏任务和微任务分别有哪些?**[#](#3)**

4. 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法。**[#](#4)**

5. 使用`Promise`实现串行。**[#](#5)**

6. `Node`与浏览器 `EventLoop` 的差异。**[#](#6)**

7. 如何在保证页面运行流畅的情况下处理海量数据。**[#](#7)**


<h2> 1. 为何 try 里面放 return，finally 还会执行，理解其内部机制。</h2>

如果存在 `finally` 代码块，`try` 中的 `return` 语句不会立马返回给调用者，
而是记录下返回值等待 `finally` 代码块执行完毕之后再返回。

**注意的几点：**

- 不管 `try` 里有没有返回值，`finally` 都会执行。

- 不管有没有异常，`finally` 都会被执行。

- `finally` 里边的返回值会覆盖 `try` 中返回的值。



<h2 id="2"> 2. JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制。</h2>

<h2 id="3"> 3. 宏任务和微任务分别有哪些?</h2>

**宏任务：**事件队列中每一个事件、`setImmediate（node环境）`、 `MessageChannel`、 `setTimeout`、`setInterval`。
**微任务：**`Promise.then()` 、`MutationObserver`、`process.nextTick（node环境）`。

<h2 id="4"> 4. 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法。</h2>

<h2 id="5"> 5. 使用`Promise`实现串行。 不对</h2>

**Promise 串行的实现原理：** 让每个串行中的任务都返回一个 `Promise`，最后统一由 `Promise` 进行 `then` 链式调用达到串行的目的。

```js
function task(fn) {
    return new Promise((resolve, reject) => {
        fn()
        resolve();
    })
}
function first() {
    console.log(1);
}
function second() {
    console.log(2);
}
function third() {
    console.log(3);
}

let promise = new Promise((resolve, reject) => {
    resolve("promise");
})
promise.then(task(first))
    .then(task(second))
    .then(task(third))
    .then((res) => {
        console.log(res);
    })
// 1
// 2
// 3
// promise
```




<h2 id="6"> 6. Node 与浏览器 EventLoop 的差异。</h2>

### 事件循环 

```html
事件循环是计算机系统的一种运行机制，JavaScript 采用事件循环机制来处理异步任务的执行。
```

[HTML规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop) 中指出：一个事件循环有一个或者多个**任务队列（Task Queue）**，一个任务队列有一组**任务（异步任务）**。

任务可以分成两种，一种是**同步任务**，另一种是**异步任务**。

**同步任务**是指在主线程上排队执行的任务，同步任务形成 `执行栈`。

**异步任务**不进入主线程排队，而是进入 `Task Queue` 排队的任务，只有 `Task Queue` 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

```html
执行栈中的同步任务执行完毕后，才会将 Task Queue 中的异步任务加入到主线程执行。
```

异步任务分为：**宏任务（macrotask）**和**微任务（microtask）**。

- **宏任务（macrotask）：**
    包含执行整体的 JavaScript 代码、事件回调、XHR 回调、定时器（setTimeout/setInterval/setImmediate）、IO操作以及UI渲染。

- **微任务（microtask）：**
    更新应用程序状态的任务，包括 `promise` 回调、`MutationObserver`、`process.nextTick` 以及 `Object.observe`。

<img alt="event-loop" src="https://i.loli.net/2019/09/27/wNb9KecBHvyGtWL.png" width="80%">

### Node.js 中的事件循环

当 `node.js` 运行时，会初始化一个 `EventLoop`，处理那些通过**异步api调用**、**定时器**或者调用 `process.nextTick()` 提供的 `script`或者输入到 `REPL` 中的 `script`。

下图展示了事件循环的操作顺序以及概要。

<img alt="node事件循环" src="https://i.loli.net/2019/09/27/jZNezAMIwUkbxWR.png" width="90%">

### 浏览器中的事件循环

- 执行一个**宏任务（macrotask）**。

- 执行过程中如果遇到**微任务（microtask）**，就将它添加到微任务的任务队列中。

- **宏任务（macrotask）**执行完毕后，立即执行当前**微任务（microtask）**队列中的所有微任务（先进先出）。

- 当前**宏任务（macrotask）**执行完毕，开始检查渲染，然后 `GUI` 线程接管渲染。



<img alt="浏览器事件循环" src="https://i.loli.net/2019/09/27/vskWbIJrhP5CKX9.png" width="50%">

### 差异：
**Node.js 中**，微任务 `microtask` 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 `microtask` 队列的任务。

<img alt="node事件循环" src="https://i.loli.net/2019/09/27/THPNqOjWvIAXsBG.png" width="70%">

**浏览器环境下**，微任务 `microtask` 任务队列是每个宏任务 `macrotask` 执行完之后执行。

<img alt="浏览器事件循环" src="https://i.loli.net/2019/09/27/7rbNAxsjhLf3uZM.png" width="70%">

<h2 id="7"> 7. 如何在保证页面运行流畅的情况下处理海量数据。</h2>

