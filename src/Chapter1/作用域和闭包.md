# 作用域和闭包

1. 理解词法作用域和动态作用域。**[#](#1)**

2. 理解 JavaScript 的作用域和作用域链。**[#](#2)**

3. 理解 JavaScript 的执行上下文。**[#](#3)**

4. 理解 JavaScript 执行上下文栈，可以应用堆栈信息快速定位问题。**[#](#4)**

5. `this`的原理以及几种不同使用场景的取值。**[#](#5)**

6. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用。**[#](#6)**

7. 理解堆栈溢出和内存泄漏的原理，如何防止？**[#](#7)**

8. 如何处理循环的异步操作？**[#](#8)**

9. 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理。**[#](#9)**

<h2 id="1"> 1. 理解词法作用域和动态作用域。</h2>

### 什么是词法作用域？

**词法作用域：** 是定义在词法阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和函数作用域写在哪里来决定的。

因此当词法分析器处理代码时会保持作用域不变。词法作用域即**静态作用域**。

**动态作用域：** 需要明确的是，JavaScript 并不具有动态作用域，它只有词法作用域，简单明了。

**`this` 的执行机制表现的像动态作用域，因为 `this` 的绑定是在代码执行时确定的。**

所谓 **`动态作用域`** 是指作用域在代码执行之前都不确定，也就是说拥有动态作用域的编程语言，函数的作用域是在函数调用的时候才决定的。

为什么说 JavaScript 没有动态作用域？
```js
var num = 1;
function foo() {
    console.log(num);
}
function bar() {
    var num = 2;
    foo();
}
bar();
// 输出结果是？
```

假设 JavaScript 采用动态作用域，让我们分析下执行过程：

执行 `foo()`时 ，依然是从 `foo` 函数内部查找是否有局部变量 `num`。如果没有，就会顺着调用栈在调用 `foo` 函数的位置，也就是 `bar` 函数内部查找 `num` 变量，结果会打印 `2`。

而上段代码的输出结果是 `1`，在执行 `foo()` 时，先从 `foo` 函数内部查找是否有局部变量 `num`，如果没有，就根据书写的位置，查找上一层层的代码，找到了 `var num = 1`，所以结果会打印 1。所以 JavaScript 采用的是静态作用域，作用域在书写代码时就已经决定了**与调用位置没有关系。**

总结：
``` html
JavaScript 只有词法作用域，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。
```

**思考：**
```js
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() {
        return scope;
    }
    return f();
}
checkscope();
```
```js
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() {
        return scope;
    }
    return f;
}
checkscope()();
```

<h2 id="2"> 2. 理解 JavaScript 的作用域和作用域链。</h2>


**作用域：** JavaScript 中的作用域就是词法作用域(事实上大部分语言都是基于词法作用域的)。

`词法作用域`是一套关于引擎如何寻找变量以及会在何处找到变量的规则。

`词法作用域`最重要的特征是**它的定义过程发生在代码的书写阶段**(假设你没有使用 `eval()` 或 `with`)。


**作用域链：** 当在查找变量时，首先会在当前作用域中进行查找，如果没有找到，就会向上级进行查找，直到全局作用域。这个过程形成的关系链就是作用域。

如下代码：

```js
function foo(a) {
    var b = a * 2;
    function bar(c) {
        console.log(a, b, c);
    }
    bar(b * 3);
}
foo(1);
```


在上段代码中，引擎执行 `console.log()` 声明，并查找 `a`、`b` 和 `c` 三个变量的引用。它首先从最内部的作用域，也就是 `bar()` 函数的作用域开始查找，引擎首先这里找到了`c`，而无法在这里找到 `a`，因此会去上一级到所嵌套的 `foo()` 的作用域中继续查找，在`foo()` 中查找到了`b`，而扔没有找到 `a`的引用， 因此引擎会继续去上一级（这级是全局作用域）继续查找，最后在找到了 `a`。最后经过一些列的向上查找，得到最后的输出结果 `1, 2, 6`。

**注意：**
词法作用域查找只会查找**一级标识符**，如果代码中引用了 `foo.bar.baz`，词法作用域查找只会试图查找 `foo` 标识符，找到这个变量后，对象属性访问规则会分别接管对 `bar` 和 `baz` 属性的访问。

![屏幕快照 2019-09-23 下午4.25.28.png](https://i.loli.net/2019/09/23/BTSID9FgkGLid45.png)


**思考如下代码：**
```js
var a = 10;
var foo = {
    a: 11,
    bar: {
        baz: function() {
            console.log(a);
        }
    }
}
foo.bar.baz();
```

<h2 id="3"> 3. 理解 JavaScript 的执行上下文。</h2>

#### 什么是执行上下文？
当函数执行时，会创建一个称为执行上下文的变量对象`可理解为作用域`。一个执行上下文定义了一个函数执行时的环境。

`执行上下文`也分为两种类型：

- **全局执行上下文：**代码首次执行时候的默认环境，在代码的整个执行过程中，只用一个全局执行上下文。

- **函数执行上下文：**每当执行流程进入到一个函数体内部的时候，就会创建一个函数执行上下文，`可以有任意数量的函数执行上下文`。

**执行上下文主要有两个阶段：** `创建阶段`和`执行阶段`。

**创建阶段：**
- 首先，为每个函数或变量创建与外部环境的连接，这这个连接形成`作用域链`。`作用链`告诉执行上下文它应该包含什么，以及它应该在哪里查找解析函数的引用和变量的值。

- 扫描`作用链`后，将创建一个环境存储器，其中`全局上下文`、`变量`、`函数及函数参数`的创建和引用在内存中完成。

- 最后，在第一步中创建的每个执行上下文中确定 `this` 关键字的值。


**每个执行上下文包含了三个重要属性：`变量对象（VO）`、`作用域链`、`this`。**


创建阶段伪代码：
```js
createContext = { // 创建阶段
  'outerEnvironmentConnection': { // 创建外部连接
        // 形成作用域链
   },    
   'variableObjectMapping': {
        // 变量、函数和函数参数的创建和引用在内存中完成。
   },
   'valueOfThis': {},  // 确定 this 的值
}
```

**执行阶段：**

`执行阶段`是代码在创建阶段形成的执行上下文中的运行的阶段，并且逐行分配变量值。

当执行开始时，JavaScript 引擎在其创建阶段形成的`AO对象`中查找执行函数的引用。如果在当前对象中没有找到，它将沿着作用域继续向上查找，直到它到达全局环境。

如果在全局环境中找不到函数引用，则将返回错误。

如果找到了引用并且函数正确执行，那么这个特定函数的执行上下文将从栈中弹出，接着 JavaScript 引擎将移动到下一个函数，它们的函数执行上下文将被加入到栈中并执行，以此类推。

下面结合代码来理解`两种执行上下文`的`两个阶段`：

```js
let name = "webinfoq";
var title = "execution context";
const message = "hello world";

function func1(num) {
  var author = "deepak";
  let value = 3;
  let func2 = function multiply() {
    return num * value;
  }
  const fixed = "Divine";
  function addFive() {
    return num + 5;
  }
}
func1(10);
```
因此`全局执行上下文`的`创建阶段`将如下所示：
```js
globalExecutionContext = {  // 全局执行上下文
    outerEnvironmentConnection: null,  // 全局上下文外部环境为 null
    variableObjectMapping: { 
        name: uninitialized,  // 在创建阶段，let 声明的变量是未初始化状态
        title: undefined,     // 在创建阶段，var 声明的变量表示为未定义
        date: uninitialized,  // 在创建阶段，const 声明的变量是未初始化状态
        func1: `<func1 reference>`,  // func1 地址引用
    },
    this: window // Global Object  
}
```
在`执行阶段`完成对变量的赋值等操作：

```js
globalExectutionContext = {  // 全局执行上下文
    outerEnvironmentConnection: null, // 全部上下文外部环境为 null
    variableObjectMapping: {
        name: "webinfoq",
        title: "execution context",
        message: "hello world",
        func1: pointer to function func1, // 指向 func1 的指针
    },
    this: window //Global Object
}
```

当执行到 `func1` 时，将形成新的`函数执行上下文`，`创建阶段`如下所示：
```js
func1ExecutionContext = {  // func1 函数执行上下文
    outerEnvironmentConnection: Global,  // 外部环境为全局环境
    variableObjectMapping: {
       arguments: {
            0: 10,
            length: 1
        },
        num: 10,
        author: undefined,  // var 声明的
        value: uninitialized,  // let 声明的
        func2: uninitialized,  // let 声明的
        fixed: uninitialized,  // const 声明
        addFive: `<addFive reference>`  // addFive 地址引用
    },
    this: Global Object or undefined  
}
```
`执行阶段`如下所示：
```js
func1ExecutionContext = {
    outerEnvironmentConnection: Global,  
    variableObjectMapping: {
       arguments: {  // 先处理 arguments 参数
            0: 10,
            length: 1
        },
        num: 10,
        author: "deepak",  //变量赋值
        val: 3,
        func2: pointer to function func2() 
        fixed: "Divine"
        addFive: pointer to function addFive()
    },
    this: Global Object or undefined
}
```
**最后：**

Javascript 引擎创建执行上下文，调用栈。当有函数执行时，引擎就会创建一个新的函数执行上下文。最后所用函数执行完成后，将更新全局环境，然后全局代码完成，程序结束。


<h2 id="4"> 4. 理解 JavaScript 执行上下文栈，可以应用堆栈信息快速定位问题。</h2>

通过阅读上一小节我们得知，每当有函数执行时，就会创建一个全新的`执行上下文`，那么怎么管理这些执行上下文呢？

JavaScript 引擎创建了**执行上下文栈** `Execution Context Stack` 来管理执行上下文。

可以把执行栈认为成一个储存函数调用的栈结构，遵循先进后出的原则。

下图为`执行上下文`入栈出栈示意图：

![入栈出栈示意图](https://i.loli.net/2019/09/23/twsk5g6oaOBFEVq.gif)


**JavaScript 引擎是单线程执行，所有代码都是排队执行：**

- 一开始执行的是全局代码，首先创建`全局执行上下文`，然后将该执行上下文压入执行栈中。

- 当执行一个函数，就会创建该`函数执行上下文`，然后将其压入执行栈的顶部。

- 函数执行完成后，执行上下文从底部退出，等待垃圾回收。

**调用栈的应用：**
```js
你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。
另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具， 其中包含 JavaScript 调试器。
就本例来说，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger 语句。
运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。
因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。
```

<h2 id="5"> 5. this 的原理以及几种不同使用场景的取值。</h2>

**this** 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于`函数调用时`的各种条件。

**this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**

当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。`this` 就是记录的其中一个属性，会在函数执行的过程中用到。

理解`调用栈`和`调用位置`：
```js
function baz() {
    // 当前调用栈是: baz
    console.log( "baz" );
    bar(); // <-- bar 的调用位置 
}
function bar() {
    // 当前调用栈是 baz -> bar
    console.log( "bar" );
    foo(); // <-- foo 的调用位置，当前调用位置在 baz 中
}
function foo() {
    // 当前调用栈是 baz -> bar -> foo 
    // 因此，当前调用位置在 bar 中
    console.log( "foo" );
}
baz(); // <-- baz 的调用位置，当前调用位置是全局作用域  
```
**this 绑定遵循以下四种规则：** `默认绑定`、`隐式绑定`、`显示绑定`、`new 绑定`。

#### 1. 默认绑定：独立函数调用，`this` 指向全局对象。调用时前边没有或省略 `.` 操作符号。
```js
function foo() { 
    console.log(this.a);
}
var a = 2; // window.a = 2;
foo(); // window.foo();
```
**注意：**
```js
如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined.
```
#### 2. 隐式绑定：调用位置是否有上下文对象，也就是说，函数被作为某个对象的方法被调用时，`this` 指向那个对象。

```js
function foo() { 
    console.log(this.a);
}
var obj2 = { 
    a: 42,
    foo: foo 
};
var obj1 = { 
    a: 2,
    obj2: obj2 
};
obj1.obj2.foo(); // 42
```
上段代码中，词法作用域只会查找最顶层的 `obj1`，按着对象属性访问规则，会在自身上查找属性 `obj2`，所以 `this` 指向 `obj2`，所以 `this.a` 等于 `bj2.a`。

**对象属性引用链中只有最顶层或者说最后一层会影响调用位置。** 

**注意：**
```js
会出现隐式丢失的情况：
this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，
从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。
```

#### 3. 显示绑定：使用 `call`、`apply` 或者 `bind` 绑定到指定的对象。**this指向传入的第一个参数。**

```js
function foo() { 
    console.log(this.a);
}
var obj = { 
    a:2
};
var bar = function() { 
    foo.call(obj);
};
bar(); // 2
setTimeout( bar, 100 ); // 2
// 硬绑定的 bar 不可能再修改它的 this 
bar.call( window ); // 2
```
**注意：**
```js
把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值
在调用时会被忽略，实际应用的是默认绑定规则。
```


#### 4. `new` 绑定：`this` 指向创建的空对象 `{}`。

使用 `new` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：

1. 创建(或者说构造)一个全新的对象。

2. 这个新对象会被执行`[[proto]]`连接。

3. 这个新对象会绑定到函数调用的 `this`。

4. 如果函数没有返回其他对象，那么 `new` 表达式中的函数调用会自动返回这个新对象。

##### 总结：关于 `this` 绑定的场景，遵循以下 `4` 条规则：

1. 由 `new` 调用? 绑定到新创建的对象。

2. 由`call`或者 `apply` 或者 `bind` 调用? 绑定到**指定的对象**。

3. 由上下文对象调用? 绑定到那个上下文对象。

4. 在严格模式下绑定到 `undefined`，否则绑定到**全局对象**。

##### 拓展：
```
绑定优先级：new 绑定 > 硬绑定 > 隐式绑定 > 默认绑定
```
*本节参考：你不知道的 JavaScript（上卷）*



<h2 id="6"> 6. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用。</h2>

##### 闭包的概念：闭包是可以记住并有权访问所在函数作用域的`函数`，即使这个`函数`是在当前函数作用域之外执行。

```js
function add() {
    var a = 1;
    return function closure(b) { 
        return a + b; 
    }
}
const closure = add();
console.log(closure(1)); // 2
```

这段代码中，调用 `add()` 时会生成一个函数执行上下文，并推入到`执行上下文栈中`。
`add` 函数执行完毕后，它的执行上下文会从执行栈中推出，同时局部变量 `a` 会被清理才对，但我们在执行 `console.log(closure(1));`时却输出了结果 `2`。

我们发现，调用`add()`时，会返回一个函数 `ƒ closure(b) { return a + b; }`，说明局部变量 `a` 存储于 `closure` 函数作用域中，因此我们能得到结果 `2`。

返回的这个函数 `ƒ closure(b) { return a + b; }` 就是我们将要介绍的 **`闭包`**。

### 闭包的实现原理

##### 闭包是如何实现对外部作用域的变量存储的？

**我们需要先搞清楚：**它是拷贝了变量 `a` 的值到其作用域中，还是 `a` 压根没有被销毁，而是给了闭包 `closure` 访问的权限。

```js
function add() {
    var a = 1;
    ++a;
    return function closure(b) {
        return a + b;
    }
}
const closure = add();
console.log(closure(1));
```

首先，我们在这段代码 `++a` 处打上断点，看下实际执行情况。

![屏幕快照 2019-09-24 下午2.57.06.png](https://i.loli.net/2019/09/24/Raiyz5VeuqWP6jD.png)![屏幕快照 2019-09-24 下午2.53.13.png](https://i.loli.net/2019/09/24/p4urbaPhGJA1fxi.png)

我们发现调用栈为 `add`，在执行到断点处时，作用域对象 `Scope` 中存储了当前局部变量 `a` 的值为 `2`，这是我们预期的结果。

接着我们在代码 `return a + b;` 处打上断点，实际情况如下图所示：

![屏幕快照 2019-09-24 下午3.06.28.png](https://i.loli.net/2019/09/24/itPuok97KMTNBfD.png)![屏幕快照 2019-09-24 下午2.49.18.png](https://i.loli.net/2019/09/24/SYpT7jrPiD8oBEV.png)

从 `Debug` 的结果来看，当执行到断点 `return a + b;` 处时，调用栈 `add` 被推出，当前调用栈变成了 `closure`，作用域对象 `Scope` 中局部变量 `a` 被销毁，只保存了当前调用栈 `closure` 中的变量 `b`。

而运行到此时，多出了一个 `Closure` 对象，它持有所在作用域 `add` 中的局部变量 `a` 属性，它的值为 `2`。

**这里我们应该能得知：**它是拷贝了变量 `a` 的值到其作用域中进而给了闭包 `closure` 访问的权限。


**总结：**

JavaScript 在执行时，如果遇到上述含有 `闭包` 的代码，它会在内存开辟出一块空间，这个内存空间称为 `Closure` 对象，**它用来存储所在函数作用域中的变量，因此其所在作用域的变量即使被销毁，在外部也能访问到存储下来的变量。**

***闭包查找变量是沿着作用域链向上查找的，本文并没有介绍的作用域链相关的知识，因为个人感觉闭包能缓存变量的原理并不是因为作用域链，作用域链只能说明闭包访问的范围。***

### 闭包的应用场景
- **jQuery** 源码的实现（ jQuery 就是一个大的闭包 ）。
- 函数节流。
- **Ajax** 的回调函数。
- 处理循环中的异步操作。

<h2 id="7"> 7. 理解堆栈溢出和内存泄漏的原理，如何防止？</h2>

<h2 id="8"> 8. 如何处理循环的异步操作？</h2>

在实际项目中，我们可能会遇到，在循环中发起接口调用的请求，就像这样：
```js 
const parmas = ["todos/1", "todos/2", "todos/3"];
const urls = 'https://jsonplaceholder.typicode.com';
for(var i = 0; i < parmas.length; i++) {
    fetch(urls + ${parmas[i]}).then(function(res) {
        console.log(res)
    })
}
```

#### async await
#####1. 串行执行：
```js
const urls = [
  'https://jsonplaceholder.typicode.com/todos/1',
  'https://jsonplaceholder.typicode.com/todos/2',
  'https://jsonplaceholder.typicode.com/todos/3'
];

async function getTodos() {
  for(var i = 0; i < urls.length; i++) {
      const todo = await fetch(urls[i]);
      console.log(todo);
  }
}
getTodos()

```
##### 2. 并行执行：
```js
// 第一种
async function getData() {
  const promises = urls.map(url => fetch(url))
  for (const promise of promises) {
    const data = await promise
    console.log(data);
  }
}
getData()

// 第二种
async function getData() {
    const promises = urls.map(async (url, index) => {
        const data = await fetch(url);
        console.log(data);
    })
    await Promise.all(promises);
}
getData();
```


<h2 id="9"> 9. 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理。</h2>

```js

```