# 原型和原型链

1. 理解原型设计模式以及 JavaScript 中的原型规则。**[#](#1)**

2. `instanceof`的底层实现原理，手动实现一个`instanceof`。**[#](#2)**

3. 实现继承的几种方式以及他们的优缺点。**[#](#3)**

4. 至少说出一种开源项目(如Node)中应用原型继承的案例。**[#](#4)**

5. 描述`new`一个对象的详细过程，手动实现一个`new`操作符。**[#](#5)**

6. 理解 `es6` 中 `class` 构造以及继承的底层实现原理。**[#](#6)**

<h2 id="1"> 1. 理解原型设计模式以及 JavaScript 中的原型规则。</h2>

我们创建的每个函数都有一个 `protoype` 属性，这个 `prototype` 属性是一个指针，指向**原型对象**。

**这个对象的用途**：包含由特定类型的所有实例共享的属性和方法（通俗的说就是，所有特定类型的实例都可以共享这个对象上的属性和方法）。

### 原型对象的两种赋值方法：

##### 1. 给原型对象添加属性或方法：
```js
function Person() {}
// Person 原型对象上默认只有一个 constructor 属性
// 这个 constructor 指向 Person
Person.prototype.name = "jser";
Person.prototype.age = 16;
Person.prototype.sayName = function() {
    return this.name;
}

let per1 = new Person();
let per2 = new Person();
per1.sayName === per2.sayName; // true
per1.age === per2.age;  // true
```
正如上边所说，实例 `per1` 和 `per2` 共享 `Person` 原型对象的属性和方法。

##### 2. 重写原型对象：
```js
function Person() {}
Person.prototype = {
    name: "jser",
    age: 16,
    sayName() {
        return this.name;
    }
}
let per1 = new Person();
let per2 = new Person();
per1.sayName === per2.sayName; // true
per1.age === per2.age;  // true
```
这种方式会重写原型对象，重写后的原型对象默认的 `constructor` 属性不再指向 `Person` 此时它指向 `Object`。（下文会有讲到）

我们可以手动将它指向 `Person`：
```js
Person.prototype = {
    constructor: Person,
    ...
}
```

### 原型对象内存分析：

![屏幕快照 2019-09-25 下午4.25.37.png](https://i.loli.net/2019/09/25/kC9hIFf1PJosjHX.png)

默认情况下，原型对象 `Person.prototype` 会包含一个 `constructor` 属性，这个属性上也有一个 `prototype` 属性，这个属性是一个指针，指向**原型对象**。

```js
创建的实例也有 constructor 属性，可以使用 实例.constructor.prototype 去修改或扩展原型对象。
```
```js
Person.prototype.constructor === Person // true
Person.prototype.constructor.prototype === Person.prototype // true
```

当调用构造函数创建一个新实例后，该实例内部会包含一个内部属性 `__proto__`，它指向构造函数的原型对象。

```js
person1.__proto__ === Person.prototype // true
```

这个`连接`只存在于**实例**与构造函数的**原型对象**之间，而不是存在于实例与构造函数之间，**也就是说这个内部属性和构造函数没有直接的关系。**

### 原型对象的值不能被实例重写：
```js
function Person() {}
Person.prototype = {
    constructor: Person,
    name: "jser",
    age: 16,
    sayName() {
        return this.name;
    }
}
let per1 = new Person();
let per2 = new Person();
per1.name = "zxl"; // 重写 name
console.log(per1.name);  // zxl person实例 在自身查到到了 name 
console.log(per2.name);  // jser 在原型对象上查找到的 name
```
可以看到原型对象中的 `name` 没有被改变，`person2.name` 在原型对象上查找的值仍为 `"jser"`。

**原型模式查找属性原则：**

- 在**原型模式**中，当通过实例读取属性值时，首先会在实例自身上查找，如果实例上没有，则就会去原型对象上搜索；

- 如果在**自身**上找到，就使用这个值，不会再继续去原型对象上查找。

![屏幕快照 2019-09-25 下午5.13.55.png](https://i.loli.net/2019/09/25/QdMBUg5YSR6ce3p.png)

### 原型模式的动态性：

上文说到不能通过实例对象来重写原型对象上的属性，如果想要重写原型对象上的属性，只能通过原型对象自身去修改。
```js
...
Person.prototype.age = 22;
```
**原型模型原则：由于在原型中查找值的过程是一次搜索，因此在对原型对象做的任何修改都会立即从实例上反映出来，即使是先创建实例后修改原型也如此。**
```js
// 先创建实例 后修改原型对象
let per2 = new Person();
Person.prototype.age = 22;
console.log(per2.age); // 变成改写后的 22

// 后创建实例 先修改原型对象
Person.prototype.age = 22;
let per2 = new Person();
console.log(per2.age); // 变成改写后的 22
```
**如果先创建了实例，之后用字面量赋值的方式来重写原型对象，这就会切断现有原型对象与之前存在的任何实例之间的联系。**
```js
function Person() {}
let per1 = new Person();
Person.prototype = {
    name: "jser",
    age: 16,
    sayHi() {
        console.log("Hi");
    }
}
per1.sayHi();
```
这段代码会报 `Uncaught TypeError: per1.sayHi is not a function`，说明实例 `per1` 没有搜索不到 `sayHi` 这个方法，因为在创建 `per1` 实例之前，`per1.__proto__` 指向的原型对象只有一个默认属性 `constructor`。
```js
{ constructor: ƒ }
```
重写的 `Person.prototype` 被分配在了新的内存空间中：

![屏幕快照 2019-09-25 下午5.58.18.png](https://i.loli.net/2019/09/25/3nq4eFlfZCEhuNy.png)

### 原型对象的缺点：
**原型对象**的好处是原型中的所有属性和方法可以被很多实例共享。

缺点是当原型中包含引用类型的值的属性时，一个实例对象对这个引用类型的属性做了修改，在其他实例对象中也可以体现出来。

```js
function Person() {}
Person.prototype = {
    constructor: Person,
    name: "jser",
    age: 16,
    friends: ["javaer", "phper"]
}
let per1 = new Person();
per1.friends.push("pythener");
let per2 = new Person();
console.log(per2.friends)
```
原型对象中引用类型属性 `friends` 被修改成了 ` ["javaer", "phper", "pythener"]`，因此实例对象 `per2` 搜索到的结果也被 `per1` 修改了。

### 从原型对象中体现的一些原型模式的规则可以总结如下：

- 构造函数有一个 `prototype` 指针指向原型对象，构造函数的实例共享原型对象上的属性和方法。

- 实例与原型对象之间有一个 `__proto__` 连接。

- 原型对象上有一个 `constructor` 属性默认指向构造函数，`constructor` 属性上有一个 `prototype` 指针指向原型对象。

- 原型对象上的值不能被实例重写。

- 在原型模式中，通过实例子搜索属性时，实例上的属性会屏蔽原型对象上的同名属性。

- 原型模式中查找值的过程是一次搜索，因此在对原型对象做的任何修改都会立即从实例上反映出来，即使是先创建实例后修改原型也如此。
- 如果先创建了实例，之后用字面量赋值的方式来重写原型对象，这就会切断现有原型对象与之前存在的任何实例之间的联系。

- 原型可以被继承，如通过 `Object.create(prototype, optionalDescriptorObjects)` 来实现原型继承。

<h2 id="2"> 2. instanceof 的底层实现原理，手动实现一个 instanceof。</h2>

**instanceof**是用来判断 `a` 是否为 `B` 的实例，表达式为：a `instanceof` B，如果 `a` 是 `B` 的实例，则返回 `true`，否则返回 `false`。

 **在这里需要特别注意的是：`instanceof` 检测的是原型对象。**
```js
// 底层实现原理：
instanceof (a,B) = {
    var L = a.__proto__;
    var R = B.prototype;
    if(L === R) {
        // A的内部属性 __proto__ 指向 B 的原型对象
        return true;
    }
    return false;
}
```
代码的基本实现：
```js
function _instanceof(instance, F) {
    if(!F) `Right-hand side of 'instanceof' is not an object`;
    const L = instance.__proto__;
    const R = F.prototype;
    if(!L) throw `Unexpected identifier`;
    if(instance.__proto__ === F.prototype) {
        return true;
    }
    return false;
}
```

<h2 id="3"> 3. 实现继承的几种方式以及他们的优缺点。</h2>

继承的继承方式：`原型链继承`、 `构造继承（call/apply）`、`组合继承`、`寄生组合继承` `ES6继承`。

### 原型链继承

##### 首先回顾下构造函数、原型、和实例之间的关系：
每一个构造函数都有一个原型对象 `F.prototype`，原型对象都包含一个指向构造构造的指针 `constructor`，而实例都包含一个指向原型对象的内部指针 `__proto__`。
```js
function F() {}
var f = new F()
F.prototype.constructor === F;
f.__proto__ === F.prototype; 
```
**原型链继承的思想：**将父类的实例作为子类的原型对象。
```js
function Tiger(leg) {
    this.leg = leg;
}
Tiger.prototype.getLeg = function() {
    return this.leg;
}

function Cat(eat) {
    this.eat =  eat;
}

// 将 Tiger 的实例对象 Tiger {leg: "四条腿"} 作为 Cat 的原型对象
// 这是一个重写 Cat 原型对象的过程
Cat.prototype = new Tiger("四条腿");  

Cat.prototype.getEat = function() {
    return this.eat;
}

let cat = new Cat("鱼");
console.log(cat.getLeg()); // 四条腿
console.log(cat.getEat()); // 鱼
```
**原型链继承实际上是重写子类原型对象的过程，子类原型对象的 `constructor` 属性会被默认指向父类。**
```js
Cat.prototype.constructor === Tiger; // true
```

**原型链继承的缺点：** 当父类的原型对象修改后，子类也会访问到修改后的结果，父类一变其他都跟着变了。

*遵循了原型模式的动态性（请看第 1 小节）*

### 构造继承（call/apply）

**构造继承的思想：** 利用 `call` 或 `apply` 将父类的 `this` 硬绑定到子类上。

```js
function Tiger (leg) {
    this.leg = leg;
    this.getLeg = function () {
        return this.leg;
    }
};
//对原型对象进行的扩展的方法就无法被继承了
Tiger.prototype.getEat = function () {    
    console.log("吃肉");
};

function Cat(eat) {
    // 使用 call 将 this 硬绑定到 Cat 类上
    // 创建 Cat 类实例后，实例调用方法时，this 指向 Cat
    // console.log(this); Cat 
    Tiger.call(this, '四条腿');　　
    this.eat = eat;
};

let cat = new Cat("鱼");
console.log(cat.leg);　　　　  // 四条腿 （继承自 Tiger 类）
console.log(cat.getEat());　　// 报错 调用不到 Tiger 类原型对象上面的方法　　
```

**构造继承的缺点：** 
- 只能继承父类的实例属性或方法，不能继承父类原型上的属性或方法，无法实现函数复用。

- 每个子类都有父类实例函数的副本，性能会有耗损。

### 组合继承

**组合继承的思想：**是将`原型链继承`和`构造继承`组合起来使用，是常用的一种继承方式。
```js
function Tiger(leg) {
    this.leg = leg;
}
Tiger.prototype.getLeg = function() {
    return this.leg;
}

function Cat(eat) {
    // 构造继承 使用 call 调用父类 将 this 硬绑定到子类上
    // 继承父类的实例属性或方法
    Tiger.call(this, "四条腿"); // 第二次调用父类
    this.eat =  eat;
}

// 使用原型链继承 将 Tiger 的实例对象 Tiger {leg: "四条腿"} 作为 Cat 的原型对象
// 继承父类的原型属性或原型方法
Cat.prototype = new Tiger("四条腿");   // 第一次调用父类

Cat.prototype.getEat = function() {
    return this.eat;
}

let cat = new Cat("鱼"); // 触发第二次调用
console.log(cat.leg);  // 四条腿 （继承自父的实例属性 ）
console.log(cat.getLeg()); // 四条腿 （继承自父类的原型方法）
console.log(cat.getEat()); // 鱼
```
第一次调用 `Tiger` 构造函数时，`Cat.prototype` 会得到属性 `leg`，它是父类的实例属性，只不过现在位于子类的原型对象中。
当 使用 `new` 调用 `Cat` 构造函数时，又会调用一次 `Tiger` 构造函数，这一次会在 `new` 创建的新对象上创建实例属性 `leg`， 于是这个属性就屏蔽了原型对象上的同名属性。

**组合继承的缺点：** 调用了两次父类，第二次调用父类时，会在新对象上创建实例属性，这会屏蔽存在子类原型对象上的同名属性。

### 寄生式继承

**寄生继承的思想：**创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

```js
function cloneObj(parent) {
    let clone = object(parent);
    clone.getLeg = function() {
       return this.leg;
    }
    return clone;
}

// 寄生
function object(obj) {
    function F() {};
    F.prototype = obj;
    return new F();
}

let tiger = {
    eat: "肉",
    leg: "四条"
}
let cat = cloneObj(tiger);
cat.getLeg();  // 四条
```

**寄生继承的缺点：**使用寄生式继承为对象添加方法，会由于不能做到方法的复用而降低效率，这一点和构造函数模式类似。


### 寄生组合继承
**寄生组合继承思想：**是在组合继承的基础上，使用`寄生`方式对组合继承进行的一次优化。
```js
function Tiger(name) {
    this.name = name;
}
Tiger.prototype.leg = "四条腿";

Tiger.prototype.getEat = function() {
    return this.eat;
}
function Cat(eat) {
    // 构造继承 使用 call 调用父类 将 this 硬绑定到子类上
    // 继承父类的实例属性或方法
    Tiger.call(this, "老虎"); 
    this.eat = eat;
}
// 寄生
!function() {
    let F = function() {};         // 创建一个空对象作为寄生
    F.prototype = Tiger.prototype; // 将父类的原型对象寄生到空对象的原型对象上
    new F().constructor  = Cat;    // 构造指针手动指向子类
    Cat.prototype = new F();       // 将空对象的实例作为子类的原型对象 （子类只继承了父类的原型上的方法和属性）
}();

let cat = new Cat("鱼");
console.log(cat.eat); // 鱼 // （子类实例自身的属性）
console.log(cat.leg); // 四条腿 （继承了父类原型上的属性）
console.log(cat.getEat());
```
**寄生组合继承是实现基于类型的继承的最有效的方式，但是实现起来相对复杂，代码量会很大。**

### ES6 继承（这里在本节作为了解）
ES6 中提供了 `class` 构造函数的写法，对于继承 `class` 可以使用 `extends` 关键字。
```js
class Tiger {
    constructor(leg){
        this.leg = leg;
    }
    getLeg() {
        console.log(this.leg);
    }
}
class Cat extends Tiger {  
    constructor(leg, eat) {
        super(leg);  //相当于构造继承中的 Tiger.call(this, leg);
        this.eat = eat;
    }
    //子类独有的方法
    getEat() {
        return this.eat;
    }
}

    const cat = new Cat("四条腿", "鱼");
    cat.getLeg();
    cat.getEat();
    console.log(cat instanceof Cat);    //true
    console.log(cat instanceof Tiger);  //true
```
**拓展：** 
```js
ES6 提供了 Object.create() 方法也可以实现继承。
语法：Object.create(proto[, propertiesObject])
```


<h2 id="4"> 4. 至少说出一种开源项目(如Node)中应用原型继承的案例。</h2>

<h2 id="5"> 5. 描述 new 一个对象的详细过程，手动实现一个 new 操作符。</h2>

**使用 `new`操作符来调用函数时，会自动执行下面的操作：**

1.创建一个新的空对象；

2.这个对象会被执行 `[[prototpye]]` 连接；

3.这个新对象会绑定到函数调用的 `this`；

4.如果函数没用返回其他对象，那么 `new` 调用的函数会自动返回这个新对象。

**手动实现：**
```js
// new 操作符的模拟实现
function _new() {
    let o = {}; // 创建一个空对象
    let C = arguments[0];  // 获得构造函数
    o.constructor = C;     // 将空对象的 constructor 默认指向构造函数
    o.__proto___ = C.prototype;  // 进行 [[prototype]] 连接
    let res = C.apply(o, arguments);  // 进行 this 绑定 并获得构造函数返回值
    // 返回处理
    return typeof res === "object" ? res : o;
}
// 测试
function Person() {
    this.name = "jser"
}
var p = _new(Person);
p.name; // ”jser“
p.constructor  // Person
```

<h2 id="6"> 6. 理解 es6 中 class 构造以及继承的底层实现原理。</h2>
