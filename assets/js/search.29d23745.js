(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{300:function(e,t,o){"use strict";o.r(t),t.default=[{title:"Vue",path:"/posts/Chapter6/vue.html",strippedContent:" ## 3. Vue双向绑定实现原理、Diff 算法的内部实现。  ## 4. Vue 的事件机制。  ## 5. 从 template 转换成真实DOM的实现机制。"},{title:"AST抽象语法树",path:"/posts/Chapter3/ast.html",strippedContent:' # 深入理解 JavaScript 代码编译过程   本文将从 `AST` 开始，结合 `Babel` 由浅入深的去探究编译器是如何编译 `JS` 代码的。  ## AST  在计算机科学中，抽象语法树（`abstract syntax tree` 或者缩写为 `AST`），或者语法树（`syntax tree`），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。  > 之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。   ### 使用场景  - `JS` 反编译，语法解析 - `Babel` 编译 `ES6` 语法 - 代码高亮 - 关键字匹配 - 作用域判断 - 代码压缩 - ...  ### AST 长什么样子？  看一个例子：  ```js function square(n) {   return n * n; } ```  [AST Explorer](http://astexplorer.net/) 可以让你对 `AST` 节点有一个更好的感性认识。   ![AST Explorer](https://qiniu.mdnice.com/d46e943dbd241fb8c8698b94b8e23505.png)  这段代码被解析成的 `AST` 树结构可以表示为：  ![ast](https://qiniu.mdnice.com/97e794df307af25693558eb8a80cfcf6.png)    通过解析结果，细心的你会发现，`AST` 是一个多层次嵌套的树结构，每一层都映射着源代码的相关物理信息：  - 类型 `type`，如 `type: BlockStatement`。 - 名称 `name`，如 `name: "square"`。 - 位置 `start`，如 `start: 10`、`end: 16`。 - 运算符 `operator`，如 `operator: "*"`  > 下文介绍节点类型时，会继续介绍。  我们再加一行代码，看会怎样：  ```js function square(n) {   return n * n; } (n) => n * n; ```  如下树结构：  ![AST](https://qiniu.mdnice.com/2f8ab9b8ff20271a2160dbfa8619a666.png)   JSON 格式可能会更直观些：  ```json {   "type": "Program",   "start": 0,   "end": 54,   "body": [     {       "type": "FunctionDeclaration",       "start": 1,       "end": 39,       "id": {         "type": "Identifier",         "start": 10,         "end": 16,         "name": "square"       },       "expression": false,       "generator": false,       "async": false,       "params": [         {           "type": "Identifier",           "start": 17,           "end": 18,           "name": "n"         }       ],       "body": {         "type": "BlockStatement",         "start": 20,         "end": 39,         "body": [           {             "type": "ReturnStatement",             "start": 24,             "end": 37,             "argument": {               "type": "BinaryExpression",               "start": 31,               "end": 36,               "left": {                 "type": "Identifier",                 "start": 31,                 "end": 32,                 "name": "n"               },               "operator": "*",               "right": {                 "type": "Identifier",                 "start": 35,                 "end": 36,                 "name": "n"               }             }           }         ]       }     },     {       "type": "ExpressionStatement",       "start": 41,       "end": 54,       "expression": {         "type": "ArrowFunctionExpression",         "start": 41,         "end": 53,         "id": null,         "expression": true,         "generator": false,         "async": false,         "params": [           {             "type": "Identifier",             "start": 42,             "end": 43,             "name": "n"           }         ],         "body": {           "type": "BinaryExpression",           "start": 48,           "end": 53,           "left": {             "type": "Identifier",             "start": 48,             "end": 49,             "name": "n"           },           "operator": "*",           "right": {             "type": "Identifier",             "start": 52,             "end": 53,             "name": "n"           }         }       }     }   ],   "sourceType": "module" } ```  你会发现在之前的基础上，最外层 `body` 字段中新增了一个 `expressSatement` 属性，用来描述 `(n) => n * n;` 相关语法信息等。    接着还会发现 `AST` 每一层都拥有相同的结构：  ```json {   type: "FunctionDeclaration",   id: {...},   params: [...],   body: {...} } ``` ```json {   type: "Identifier",   name: ... } ``` ```json {   type: "BinaryExpression",   operator: ...,   left: {...},   right: {...} } ```  > 注意：出于简化的目的移除了某些属性  ### 节点类型  这样的每一层结构也被叫做 **节点（Node）**。 一个 `AST` 可以由单一的节点或是成百上千个节点构成。 它们组合在一起可以描述用于静态分析的程序语法。  每一个节点都有如下所示的接口（`Interface`）：  ```js interface Node {   type: string; } ```  字符串形式的 `type` 字段表示节点的类型，如： - `FunctionDeclaration` 函数声明。 - `BlockStatement` 块语句，即用 `{}` 括号括起来的一系列语句。 - `ReturnStatement` 一个 `return` 声明。 - `Identifier"` 标识符，标识符可以是表达式或解构模式。 - `BinaryExpression` 二进制运算符表达式（二项式对象）。 - `ExpressionStatement` 表达式语句，即由单个表达式组成的语句。 - `ArrowFunctionExpression`  箭头函数表达式。 - ...  每一种类型的节点定义了一些附加属性用来进一步描述该节点类型。  详细描述请看[AST节点对象文档](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects)。  ``` (parameter) node: Identifier | SimpleLiteral | RegExpLiteral | Program | FunctionDeclaration | FunctionExpression | ArrowFunctionExpression | SwitchCase | CatchClause | VariableDeclarator | ExpressionStatement | BlockStatement | EmptyStatement | DebuggerStatement | WithStatement | ReturnStatement | LabeledStatement | BreakStatement | ContinueStatement | IfStatement | SwitchStatement | ThrowStatement | TryStatement | WhileStatement | DoWhileStatement | ForStatement | ForInStatement | ForOfStatement | VariableDeclaration | ClassDeclaration | ThisExpression | ArrayExpression | ObjectExpression | YieldExpression | UnaryExpression | UpdateExpression | BinaryExpression | AssignmentExpression | LogicalExpression | MemberExpression | ConditionalExpression | SimpleCallExpression | NewExpression | SequenceExpression | TemplateLiteral | TaggedTemplateExpression | ClassExpression | MetaProperty | AwaitExpression | Property | AssignmentProperty | Super | TemplateElement | SpreadElement | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | ClassBody | MethodDefinition | ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier ```  到这里，其实我们已经慢慢明白了：  > 抽象语法树其实就是将源码反格式化，将一类标签转化成通用标识符，从而解构出的一个类似于树形结构的语法树。  ### 深入原理  我们用代码来模拟一下 `JS` 的编译过程：（代码转换成 `AST` 并生成新代码的过程）。  ```js // 解析（JS） --\x3e 转换（AST） --\x3e 生成（JS） const esprima = require(\'esprima\'); //解析js的语法的包 const estraverse = require(\'estraverse\'); //遍历树的包 const escodegen = require(\'escodegen\'); //生成新的代码  let code = `function square() {}`; // 1. 解析 let tree = esprima.parseScript(code); console.log(tree);  // 2. 转换/遍历树（深度遍历） estraverse.traverse(tree, {   enter(node) {     console.log(\'enter: \' + node.type);     if (node.type === \'Identifier\') {         node.name = \'multiply\';       }     }   } }); // 3. 生成  let newCode = escodegen.generate(tree); console.log(newCode); ```  上段代码中，我们首先使用 [esprima](https://esprima.org/)（解析器）将源代码解析成 `AST` 抽象语法树： ```js ... let tree = esprima.parseScript(code); console.log(tree); ... ``` 打印结果如下图：  ![AST](https://qiniu.mdnice.com/811b1c5a9d7f4e692e7fba2f876f01b3.png)  正如同上文所介绍的那样：  ![ast](https://qiniu.mdnice.com/3fa959bd6214de501b522a92d239429d.png)   之后，使用 [estraverse](https://www.npmjs.com/package/estraverse) 遍历整个 `AST`，通过节点类型转换/修改（修改了源代码的函数签名）成新 `AST`。  从打印结果可知，这个遍历过程是一个深度优先遍历的过程。  ![AST](https://qiniu.mdnice.com/fb074dde04def5b3889dc9bed3827f58.png)  最后，将转换后的 `AST` 借助代码生成器 [escodegen](https://www.npmjs.com/package/escodegen)，生成新的代码：  最终结果如下： ![code](https://qiniu.mdnice.com/5ec9cdc1da2cb405eb1f812ff6f2b6e3.png)  > 新生成的代码是格式化后的代码，这里有一个线上的例子。[demo](https://estools.github.io/escodegen/demo/index.html)  深入原理之后，你可能会想到 `ES6` 到 `ES5` 的转换，可能想到了 `Babel`，想到了 `JS` 混淆，想到了更多背后的东西。  > 抽象语法树的强大之处，本质上通过编译，我们可以去改变任何输出结果。  那么，接下来，就让我们一起来认识下 `Babel` 吧。    ## Babel  ### 初识   `Babel` 是一个通用的多用途 `JavaScript` 编译器。通过 `Babel` 你可以使用（并创建）下一代的 `JavaScript`，以及下一代的 `JavaScript` 工具。   `Babel` 把用最新标准编写的 `JavaScript` 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（`transpiling` 是一个自造合成词，即转换＋编译。以下也简称为转译）。  例如，`Babel` 能够将新的 `ES2015` 箭头函数语法：  ```js const square = n => n * n; ``` 转译为： ```js const square = function square(n) {   return n * n; }; ``` >不过 Babel 的用途并不止于此，它支持语法扩展，能支持像 React 所用的 JSX 语法，同时还支持用于静态类型检查的流式语法（Flow Syntax）。  **`Babel` 的一切都是简单的插件，谁都可以创建自己的插件，利用 Babel 的全部威力去做任何事情。**  ### Babel 是如何工作的？  通过上文可知，`Babel` 是 `JavaScript` 编译器，那么它在工作时也要执行 `解析（JS） --\x3e 转换（AST） --\x3e 生成（JS）`的过程。  > 只不过是 `Babel` 将这一过程进行了封装，每一个封装都定义了一种规则。  下面让我们借助 `Babel` 插件来实现这一过程。  ```js const babel = require(\'babel-core\'); //babel 核心解析库，负责解析 const types = require(\'babel-types\'); //babel 类型转化库，负责转换  let code = `let sum = (a, b) => { return a + b }`;  // 制定规则（如何转换） let ArrowPlugins = {     //访问者模式     visitor: {     //捕获匹配的API         ArrowFunctionExpression(path) {             let { node } = path;             let body = node.body;             let params = node.params;             let r = types.functionExpression(null, params, body, false, false);             path.replaceWith(r);         }     } } // 根据规则进行转换并生成 let date = babel.transform(code, {   plugins: [     ArrowPlugins   ] }) console.log(date.code); ```  看下输出结果：  ```js let sum = function (a, b) {   return a + b; }; ```  好像这正是我们想要的。  ### 深入 Babel  当然，上文我们简单演示了 `Babel` 是如何来编译代码的，但是并非就这么简单。  > `Babel` 使用一个基于 `ESTree` 并修改过的 `AST`，它的内核说明文档可以在[这里](https://github.%20com/babel/babel/blob/master/doc/ast/spec.%20md)找到。  正如上文所说，`Babel` 编译会经过三个阶段，分别是： **解析（`parse`）**、**转换（`transform`）**、**生成（generate）**。   #### 解析  解析步骤接收代码并输出 `AST`。 这个步骤分为两个阶段：  - **词法分析（Lexical Analysis）** - **语法分析（Syntactic Analysis）**。  ##### 1. 词法解析  编译的第一个阶段，它的主要任务就是从左到右扫描字符串形式的代码，将其转换为 **令牌（tokens）** 流，用于语法分析。  可以把令牌（`tokens`）看作是一个扁平的语法片段数组： ```js n * n; ```  例如：  ```js [   { type: { ... }, value: "n", start: 0, end: 1, loc: { ... } },   { type: { ... }, value: "*", start: 2, end: 3, loc: { ... } },   { type: { ... }, value: "n", start: 4, end: 5, loc: { ... } },   ... ] ```  每一个 `type` 有一组属性来描述该令牌：  ```js {   type: {     label: \'name\',     keyword: undefined,     beforeExpr: false,     startsExpr: true,     rightAssociative: false,     isLoop: false,     isAssign: false,     prefix: false,     postfix: false,     binop: null,     updateContext: null   },   ... } ```  和 `AST` 节点一样它们也有 `start`、`end`、`loc` 属性。  ##### 2. 语法解析  语法分析阶段会把一个 **令牌流** 转换成 `AST` 的形式。   这个阶段会使用令牌中的信息把它们转换成一个 `AST` 的表述结构，这样更易于后续的操作。  ![语法分析](https://qiniu.mdnice.com/f22539bb6970b74b52718ce9d2ce0e6a.png)   #### 转换  转换步骤接收 `AST` 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。   > 这是 `Babel` 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分。  `Babel` 转换时，还为每个节点额外生成了一些属性，用于描述该节点在原始代码中的位置。  ```json {   type: ...,   start: 0,   end: 38,   loc: {     start: {       line: 1,       column: 0     },     end: {       line: 3,       column: 1     }   },   ... } ```  用伪代码可以表示为：  ```js // 规则配置 function traverser(ast, visitor) {     let methods = visitor[node.type];     if (methods && methods.enter) {       methods.enter(node, parent);     }     switch (node.type) {         case \'Program\':             // do something ...         case \'ArrowPlugins\':             // do something ...         ...     } }  function transformer(ast) {     let newAst = {         type: \'Program\',         body: [],     };     ast._context = newAst.body;     // 根据节点类型取得对应转换规则     traverser(ast, {         ArrowPlugins: {             enter(node, parent) {                 parent._context.push(...);             },         },         // 其他节点类型         ...     })     // 返回新的 AST     return newAst; } ```  #### 生成 代码生成步骤把最终（经过一系列转换之后）的 `AST` 转换成字符串形式的代码，同时还会创建源码映射（`source maps`）。  代码生成其实很简单：深度优先遍历整个`AST`，然后构建可以表示转换后代码的字符串。  用伪代码可以表示为：  ```js function codeGenerator(newAst) {     // 遍历入口点从节点类型开始     switch (newAst.type) {         case \'ExpressionStatement\':             return codeGenerator(newAst.expression)  // 一个深度遍历的过程         ...     } } ```  介绍到这里，回头再看这段代码：  ```js const babel = require(\'babel-core\'); //babel 核心解析库，负责解析 const types = require(\'babel-types\'); //babel 类型转化库，负责转换  let code = `let sum = (a, b) => { return a + b }`;  // 制定规则（如何转换） let ArrowPlugins = {     //访问者模式     visitor: {     //捕获匹配的 API         ArrowFunctionExpression(path) {             let { node } = path;             let body = node.body;             let params = node.params;             let r = types.functionExpression(null, params, body, false, false);             path.replaceWith(r);         }     } } // 根据规则进行转换并生成 let date = babel.transform(code, {   plugins: [     ArrowPlugins   ] }) console.log(date.code); ``` 是不是明白了很多。  ### 关于遍历  想要转换 `AST` 你需要进行递归的树形遍历。  比方说我们有一个 `FunctionDeclaration` 类型。它有几个属性：`id`，`params`，和 `body`，每一个都有一些内嵌节点。  ```js {   type: "FunctionDeclaration",   id: {     type: "Identifier",     name: "square"   },   params: [{     type: "Identifier",     name: "n"   }],   body: {     type: "BlockStatement",     body: [{       type: "ReturnStatement",       argument: {         type: "BinaryExpression",         operator: "*",         left: {           type: "Identifier",           name: "n"         },         right: {           type: "Identifier",           name: "n"         }       }     }]   } } ```  参照上边的结构我们说一下它遍历的过程：  1. 我们从 `FunctionDeclaration` 节点开始，依次访问每一个属性（`id`，`params`，和 `body`）及它们的子节点。  2. 接着我们来到 `id`，它是一个 `Identifier`。`Identifier` 没有任何子节点属性，所以我们继续下一个属性。  3. 之后是 `params`，由于它是一个数组节点所以我们访问其中的每一个，它们都是 `Identifier` 类型的单一节点，然后我们继续。  4. 此时我们来到了 `body`，这是一个 `BlockStatement` 并且也有一个 `body` 节点，而且也是一个数组节点，我们继续访问其中的每一个。  5. 这里唯一的一个属性是 `ReturnStatement` 节点，它有一个 `argument`，我们访问 `argument` 就找到了 `BinaryExpression`。.  6. `BinaryExpression` 有一个 `operator`，一个 `left`，和一个 `right`。 `Operator` 不是一个节点，它只是一个值因此我们不用继续向内遍历，我们只需要访问 `left` 和 `right`。  这个过程可以这么表示：  - 进入 FunctionDeclaration     - 进入 Identifier (id)         - 走到尽头     - 退出 Identifier (id)     - 进入 Identifier (params[0])         - 走到尽头     - 退出 Identifier (params[0])     - 进入 BlockStatement (body)         - 进入 ReturnStatement (body)             - 进入 BinaryExpression (argument)                 - 进入 Identifier (left)                     - 走到尽头                 - 退出 Identifier (left)                 - 进入 Identifier (right)                     - 走到尽头                 - 退出 Identifier (right)             - 退出 BinaryExpression (argument)         - 退出 ReturnStatement (body)     - 退出 BlockStatement (body) - 退出 FunctionDeclaration  > Babel 的转换步骤全都是这样的遍历过程。  关于 `Babel` 就介绍到这里。  ## 具体语法树 > 看到抽象语法树 `AST`，我们脑海中会出现这样一个疑问：有没有具体语法树呢？  和抽象语法树相对的是具体语法树（通常称作[解析树](https://en.wikipedia.org/wiki/Abstract_syntax_tree)）。  解析树通常是由解析器在源代码转换和编译过程中构建的。建成后，将通过后续处理（例如上下文分析）将其他信息添加到 `AST` 。  ## 参考  [ESTree](https://github.com/estree/estree) [Babel]((https://github.com/estree/estree)) [AST 抽象语法树](http://jartto.wang/2018/11/17/about-ast/)   未经允许，不得转载。     '},{title:"网络协议",path:"/posts/Chapter3/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html",strippedContent:' ## 1. 理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用。  ### 什么是协议？  网络协议的简称，是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：`语法`、`语义`、`时序`。  **协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。**  协议也可以这样说，就是连入网络的计算机都要遵循的一定的技术规范，关于硬件、软件和端口等的技术规范。  ### TCP/IP 协议族的构成 网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。  一个协议族，比如 `TCP/IP`，**是一组不同层次上的多个协议的组合**。   `TCP/IP` 通常被认为是一个四层协议系统：  ![TCP/IP](https://qiniu.mdnice.com/4be513497d56a071fb7af71b628d0b5a.png)   每一层负责不同的功能: 1. **链路层**          有时也称作`数据链路层`或`网络接口层`，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。      它们一起处理与电缆(或其他任何传输媒介)的物理接口细节。   2. **网络层**      有时也称作互联网层。处理分组在网络中的活动，例如分组的选路。          在 `TCP/IP` 协议族中， 网络层协议包括：     -  `IP` 协议 (网际协议)。     - `ICMP` 协议(`Internet` 互联网控制报文协议)。     - `IGMP` 协议(`Internet` 组管理协议)。  3. **运输层**      主要为两台主机上的应用程序提供**端到端**的通信。      在 `TCP/IP` 协议族中，有两个互不相同的传输协议: `TCP` (传输控制协议)和 `UDP` (用户数据报协议)。      `TCP` 为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。           `UDP` 则为应用层提供一种非常简单的服务。**它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。**任何必需的可靠性必须由应用层来提供。  4. **应用层**      负责处理特定的应用程序细节。          几乎各种不同的 `TCP/IP` 实现都会提供下面这些通用的应用程序:     - `Telnet` 远程登录。     - `FTP` 文件传输协议。     - `SMTP` 简单邮件传送协议。      -  `SNMP` 简单网络管理协议。    ## 2. 三次握手和四次挥手详细原理，为什么要使用这种机制。  建立 `TCP` 连接需要三次握手，而断开连接则需要四次握手。整个过程如下图所示：  ![TCP](https://qiniu.mdnice.com/398da98e209e8e18ae3873f8112739cc.png)   ### 建立 `TCP` 连接（三次握手） ``` SYN（Synchronize Sequence Numbers）同步序列编号。是 `TCP/IP` 建立连接时使用的握手信号。 ACK (Acknowledge character）确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。 ``` <img alt="三次挥手" width="60%" src="https://qiniu.mdnice.com/2363554b36b5c238a3ec26a37a569f63.png">   1. 第一次握手      首先 `Client` 端发送连接请求报文。      2. 第二次握手          `Server` 端接收连接后回复 `ACK` 报文，并为这次连接分配数据资源。  3. 第三次握手      `Client` 端接收到 `ACK` 报文后也向 `Server` 段发生 `ACK` 报文，并分配资源。      这样TCP连接就建立了。  ### 断开链接（四次挥手）  > 进行关闭的一方(即发送第一个 `FIN` )将执行主动关闭，而另一方(收到这个 `FIN`) 执行被动关闭。  ![四次挥手](https://qiniu.mdnice.com/accd98707dd56831971c257ea2f32bc4.png)   1. 第一次挥手      `Client` 发送一个 `FIN`，用来关闭 `Client` 到 `Server` 的数据传送，`Client` 进入 `FIN_WAIT_1` 状态。  2. 第二次挥手          `Server` 收到 `FIN` 后，发送一个 `ACK` 给 `Client` ，确认序号为收到序号 `+1` （与 `SYN` 相同，一个 `FIN` 占用一个序号）， `Server` 进入 `CLOSE_WAIT` 状态。  3. 第三次挥手          `Server` 发送一个 `FIN` ，用来关闭 `Server` 到 `Client` 的数据传送， `Server` 进入 `LAST_ACK` 状态。  4. 第四次挥手          `Client` 收到 `FIN` 后， `Client` 进入 `TIME_WAIT` 状态，接着发送一个 `ACK` 给 `Server` ，确认序号为收到序号 `+1` ， `Server` 进入 `CLOSED` 状态，完成四次挥手。   ## 3. DNS 的作用、DNS 解析的详细过程，DNS优化原理。  `DNS` 是**应用层协议**，事实上他是为其他应用层协议工作的，包括不限于 `HTTP` 和 `SMTP` 以及 `FTP`，用于将用户提供的主机名解析为 `IP` 地址。  `DNS` 的获取流程：  1. 用户主机上运行着 `DNS` 的客户端，（`PC` 机或者手机客户端运行着 `DNS` 客户端）。  2. 浏览器将接收到的 `URL` 中抽取出域名字段，就是访问的主机名，比如 `http://www.baidu.com/`，并将这个主机名传送给 `DNS` 应用的客户端。  3. `DNS` 客户机端向 `DNS` 服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式 `DNS` 集群的工作）。  4. 该 `DNS` 客户机最终会收到一份回答报文，其中包含有该主机名对应的 `IP` 地址。  5. 一旦该浏览器收到来自 `DNS` 的 `IP` 地址，就可以向该 `IP` 地址定位的 `HTTP` 服务器发起 `TCP` 连接。   **`IP` 地址的查询过程：**  1. 浏览器缓存          当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的 `IP` 地址（若曾经访问过该域名且没有清空缓存便存在）。  2. 系统缓存          当浏览器缓存中无域名对应 `IP` 则会自动检查用户计算机系统 `Hosts` 文件 `DNS` 缓存是否有该域名对应 `IP`。  3. 路由器缓存          当浏览器及系统缓存中均无域名对应 `IP` 则进入路由器缓存中检查，以上三步均为客服端的 `DNS` 缓存。  4. `ISP`（互联网服务提供商）`DNS` 缓存          当在用户客服端查找不到域名对应 `IP` 地址，则将进入 `ISP DNS` 缓存中进行查询。比如你用的是电信的网络，则会进入电信的 `DNS` 缓存服务器中进行查找。  5. 根域名服务器          当以上均未完成，则进入根服务器进行查询。全球仅有 `13` 台根域名服务器，`1` 个主根域名服务器，其余 `12` 为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器 `IP` 告诉本地 `DNS` 服务器。  6. 顶级域名服务器          顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地 `DNS` 服务器。  7. 主域名服务器          主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录。  8. 保存结果至缓存          本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 `IP` 地址与 `HTTP` 服务器建立 `TCP` 链接。   ## 4. CDN 的作用和原理。  ### 什么是 CDN ?  > 内容分发网络（`CDN`）是指一种通过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户。  **`CDN` 系统主要由 `4` 大部分组成，每部分都由集群所构成。这 `4` 部分分别是：** - `CDN` 专属 `DNS` 服务器。 - 全局负载均衡设备。 - 区域负载均衡设备。 - `CDN` 缓存服务器（边缘节点）。   除了 `CDN` 专属 `DNS` 服务器，其他 `3` 部分集群都有源服务器上对应资源的全部或部分副本。  `CDN` 系统通过各部分的负载均衡算法，最终指示客户端使用附近最优的边缘节点中的一台缓存服务器作为服务端，从而提高 `Web` 应用的性能。   ### CDN 的基本工作过程   **在传统的 `Web` 模型中，发出请求后一般要经过如下几个步骤：**  1. 用户在自己的浏览器中输入要访问的网站域名 `URL`。 2. 浏览器向本地 `DNS` 服务器请求对该域名的解析。 3. 本地 `DNS` 服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。 4. 本地 `DNS` 服务器中如果没有关于这个域名的解析结果的缓存，则以迭代方式向整个 `DNS` 系统请求解析，获得应答后将结果反馈给浏览器。 5. 浏览器得到域名解析结果，就是该域名相应的服务设备的 `IP` 地址 。 6. 浏览器获取 `IP` 地址之后，经过标准的 `TCP` 握手流程，建立 `TCP` 连接。 7. 浏览器向服务器发起 `HTTP` 请求。 8. 服务器将用户请求内容传送给浏览器。 9. 经过标准的 `TCP` 挥手流程，断开 `TCP` 连接。   **在网站和用户之间加入 `CDN` 以后，用户不会有任何与原来不同的感觉。从宏观上来看，一个典型的 `CDN` 用户访问调度流程如下：**  1. 当用户点击网站页面上的内容 `URL`，先经过本地 `DNS` 系统解析，如果本地 `DNS` 服务器没有相应域名的缓存，则本地 `DNS` 系统会将域名的解析权交给 `CNAME` 指向的 `CDN` 专用 `DNS` 服务器。  2. **`CDN` 的 `DNS` 服务器**将 `CDN` 的全局负载均衡设备 `IP` 地址返回给用户。  3. 用户向 `CDN` 的全局负载均衡设备发起 `URL` 访问请求。  4. `CDN` 全局负载均衡设备根据用户 `IP` 地址，以及用户请求的 `URL`，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。  5. 基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的 `IP` 地址，最终将得到的IP地址返回给全局负载均衡设备。      - 根据用户 `IP` 地址，判断哪一个边缘节点距用户最近。      - 根据用户所请求的 `URL` 中携带的内容名称，判断哪一个边缘节点上有用户所需内容。          - 查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。  6. 全局负载均衡设备把服务器的IP地址返回给用户。  7. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。  `CDN` 全局负载均衡设备与 `CDN` 区域负载均衡设备根据用户 `IP` 地址，将域名解析成相应节点中缓存服务器的 `IP` 地址，实现用户就近访问，从而提高服务端响应内容的速度。  理论上，最简单的 `CDN` 网络只有一个 `CDN` 专用 `DNS` 服务器，一个全局负载均衡设备，然后各节点一台缓存服务器，即可运行。   ## 5. HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么？  ## 6. HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题。  ## 7. HTTP1.1、HTTP2.0 带来的改变。  ## 8. HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求。  ## 9. 理解 WebSocket 协议的底层原理、与 HTTP 的区别。'},{title:"工具函数",path:"/posts/Chapter1/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0.html",strippedContent:" ## 深拷贝函数  ```js function find (list, f) {   return list.filter(f)[0] }  function deepCopy (obj, cache = []) {   // just return if obj is immutable value   if (obj === null || typeof obj !== 'object') {     return obj   }    // if obj is hit, it is in circular structure   const hit = find(cache, c => c.original === obj)   if (hit) {     return hit.copy   }    const copy = Array.isArray(obj) ? [] : {}   // put the copy into cache at first   // because we want to refer it in recursive deepCopy   cache.push({     original: obj,     copy   })    Object.keys(obj).forEach(key => {     copy[key] = deepCopy(obj[key], cache)   })    return copy } ```  ## 如何判断一个函数是 Promise 类型？ ```js function isPromise(val) {     return val && typeof val.then === 'function' } ```   "},{title:"Vue生命周期",path:"/posts/Chapter6/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",strippedContent:" ![image](https://qiniu.mdnice.com/d0991a846ee4772d015efb64290edb60.png)  ## 1. beforeCreate  在实例初始化之后，数据观测 (`data observer`) 和 `event/watcher` 事件配置之前被调用。  ## 2. created  在实例创建完成后被立即调用。在这一步，实例已完成以下的配置： 1. 数据观测 (`data observer`)。 2. 属性和方法的运算。 3. `watch/event` 事件回调。  然而，挂载阶段还没开始，`$el` 属性目前不可见。  ## 3. beforeMount  在挂载开始之前被调用：相关的 `render` 函数首次被调用。  ## 4、mounted  `el` 被新创建的 `vm.$el` 替换，并挂载到实例上去之后调用该钩子。如果 `root` 实例挂载了一个文档内元素，当 `mounted` 被调用时 `vm.$el` 也在文档内（ > 注意 `mounted` 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 `vm.$nextTick` 替换掉 `mounted`。  ## 5、beforeUpdate  数据更新时调用，发生在虚拟 `DOM` 打补丁之前。这里适合在更新之前访问现有的 `DOM`，比如手动移除已添加的事件监听器。  ## 6. updated  由于数据更改导致的虚拟 `DOM` 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 `DOM` 已经更新，所以你现在可以执行依赖于 `DOM` 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 `watcher` 取而代之。  ## 7. activated  `keep-alive` 组件激活时调用。 ## 8. deactivated  `keep-alive` 组件停用时调用。  ## 9. beforeDestroy  实例销毁之前调用。在这一步，实例仍然完全可用。  ## 10. destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。  ## 11、errorCaptured（2.5.0+ 新增）  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播。 "},{title:"性能优化",path:"/posts/Chapter1/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",strippedContent:" # 网站优化实践  转载自: [Jartto's blog](http://jartto.wang/2019/02/16/web-optimization/)  网站优化是前端开发的重中之重，但是优化细节却十分繁杂，没有好的思路，优化很难高效的开展。  本文将以实际网站来做参考，手把手教你如何一步步做好网站优化。  这不是一篇 **基础网站优化** 文章，继续下文前，请确定已经做了如下基本优化：  1. 图片压缩、合并 2. 代码精简、混淆 3. 减少 `iframe` 使用 4. 避免图片 `src` 为空 5. 减少 `HTTP` 请求数 6. 避免重定向 7. 样式表放页头、脚本放底部 8. …  ## 优化的意义  我们可以从两个角度来看这个问题： 1. 用户角度     网站优化能够让页面加载得更快，响应更加及时，极大提升用户体验。  2. 服务商角度     优化会减少页面资源请求数，减小请求资源所占带宽大小，从而节省可观的带宽资源。  > 网站优化的目标是：减少网站加载时间，提高响应速度。  那么网站加载速度和用户体验又有着怎样的关系呢？我们来看下面这张图：  ![性能优化](https://qiniu.mdnice.com/390751f871d33b0b206be13880926119.png)  Google 和亚马逊的研究表明，Google 页面加载的时间从 `0.4` 秒提升到 `0.9` 秒导致丢失了 `20%` 流量和广告收入，对于亚马逊，页面加载时间每增加 `100ms` 就意味着 `1%` 的销售额损失。  > 可见，页面的加载速度对于用户有着至关重要的影响。  一个好的交互效果可能是这样的：  ![性能优化](https://qiniu.mdnice.com/1a3a8cd970c4e1fa5c8e82740d12399c.png)  ## 分析网站性能瓶颈  ##### 1. 打包文件大小  ![](https://qiniu.mdnice.com/f6ca4e1ea0641ffeb15660a121aa5383.png)  ##### 2. 打包文件目录 ``` . ├── favicon.ico ├── index.html ├── manifest.json ├── static │   ├── DIN-Medium.1bbe3460.otf │   ├── DIN-Regular.799221d7.otf │   └── logo.c57d38d0.png ├── umi.css ├── umi.css.map ├── umi.js └── umi.js.map ```  > 需要注意：生产环境不要开启 SOURCEMAP  ##### 3. 静态资源加载时间  ![](https://qiniu.mdnice.com/83d7b1fd4f07630355fcf448be5c0e18.png)   ##### 4. 资源瀑布 `Waterfall`  ![waterfall](https://qiniu.mdnice.com/b789eb64bf23ae483ae1f745b0fa1cf9.png)  `TTFB` 全称 `Time To First Byte`：是指**网络请求被发起到从服务器接收到第一个字节的这段时间**，它包含了 `TCP` 连接时间、发送 `HTTP` 请求时间和获得响应消息第一个字节的时间。  > Content Download：即下载内容所需要的时间。  页面一接口情况：  ![](https://qiniu.mdnice.com/8e870ed1f77dd3379517dd374845d5a3.png)  页面二接口情况：  ![](https://qiniu.mdnice.com/b87c0ac96e784b75e524fd1e07816651.png)  用户下载内容所需要的时间，受限于服务器的资源、资源的大小以及用户的网络速度。因此，我们暂时不讨论这方面的内容。  ###### 5. 分析工具  通过 `webpack` 打包，分析一下大文件构成。  ![](https://qiniu.mdnice.com/ae512be364e295fc08b74be6dbd285da.png)  6.`YSlo`w 或者 `PageSpeed`  我们可以通过 `Google PageSpeed Insights API Extension` 来对网站整体性能 做一下评估，按照建议去做一些高效优化。  加载时间概况：  ![](https://qiniu.mdnice.com/4bbb11f789c681d925a05d35e250248c.png)  影响网站加载因素：  ![](https://qiniu.mdnice.com/d99888202d6deb3cb2e081c739c3c750.png)  缓存策略问题：  ![](https://qiniu.mdnice.com/3b5ca6726c09238eb0dbf3764b35f040.png)  DOM 节点：  ![](https://qiniu.mdnice.com/f8eb467c5249c3571f019255d404cb05.png)  关键路径：  ![](https://qiniu.mdnice.com/24fc24c0cc8b0ed9010de7a0bff22e3a.png)  主线程情况：  ![](https://qiniu.mdnice.com/f0e853684275c330497b63ffbefee85c.png)  ## 通过策略解决问题  ##### 1. favicon.ico 404 问题 ✓ ##### 2. 去除调试工具代码 `eruda`，线上环境是不需要的 ✓ ##### 3. 图片合并或者多个 `svg` ✓  建议使用 `webpack-spritesmith`，简单使用如下：  ```js plugins: [   new SpritesmithPlugin({     src: {         cwd: path.resolve(__dirname, 'src/ico'),         glob: '*.png'     },     target: {         image: path.resolve(__dirname, 'src/spritesmith-generated/jartto.png'),         css: path.resolve(__dirname, 'src/spritesmith-generated/jartto.styl')     },     apiOptions: {         cssImageRef: \"~jartto.png\"     }   }) ] ```  ##### 4. 大文件拆分 ✓  ![](https://qiniu.mdnice.com/37d42de035133a144328ea8f9b1f2c5d.png)  从上图分析得出，大文件主要包含：`dist.js`、`lottie.js`、`lodash.js`、`loading.json` 等文件。所以我们从这几个文件入手，逐个优化：  - `moment.js` - 配置 `moment` 忽略本地化，可减少 `70kb`  ```js ignoreMomentLocale: true ```  - `dist.js` - 在给单页应用做按需加载优化时，一般采用以下原则：      1. 把整个网站划分成一个个小功能，再按照每个功能的相关程度把它们分成几类。     2. 把每一类合并为一个 `Chunk`，按需加载对应的 `Chunk`。     3. 对于用户首次打开你的网站时需要看到的画面所对应的功能，不要对它们做按需加载，而是放到执行入口所在的 `Chunk` 中，以降低用户能感知的网页加载时间。     5. 对于个别依赖大量代码的功能点，例如依赖 `Chart.js` 去画图表、依赖 `flv.js` 去播放视频的功能点，可再对其进行按需加载。  - `lottie.js` - 分离减少 `60kb`      ```js     externals: {         lottie : 'react-lottie',     }     ```  - `lodash.js`      ```     externals: {     lodash : {         commonjs: 'lodash',         amd: 'lodash',         root: '_' // indicates global variable     }     }     ``` - 动态导入以及文件拆分     ```js     dynamicImport: {         webpackChunkName: true,         loadingComponent: './components/Loading/jartto.js',     }     ```  按照上面我们一步步处理后，重新打包分析一下文件构成：  ![](https://qiniu.mdnice.com/3d5ea574ce9975900633749f12c4bcd8.png)  这里为什么没有继续拆分 `dist.js`，是因为目前阶段没有好的方案，需要对代码做很多调整，所以暂且保留。相关信息可以在 `Ant-Design Issuse` [Svg icons make bunlde size too large](https://github.com/ant-design/ant-design/issues/12011) 中查看解决方案。  ##### 5. 存放 `CDN`  - `loading.json` 大小54kb ✓ - `svg` 替换 `2` 倍图 ✓ - 删除项目冗余图片 ✓  ##### 6. 优化 `TTFB`  - 减少 `DNS` 查询 - 使用 `CDN` - 提早 `Flush` - 添加周期头  ##### 7. 移除阻塞渲染的资源  - `css` 预加载 `preload`     ```html     <link rel=\"preload\">     ``` - 异步加载第三方资源     ```html     <script async src=\"https://cdn.jartto.wang/fastclick.js\"><\/script>     ```      没有 `async` 属性，`script` 将立即获取（下载）并执行，期间阻塞了浏览器的后续处理。     如果有 `async` 属性，那么 `script` 将被异步下载并执行，同时浏览器继续后续的处理。  ##### 8. 确保文本在网页字体加载期间保持可见状态  利用 `font-display` 这项 `CSS` 功能，确保文本在网页字体加载期间始终对用户可见。  ```css @font-face {     font-family: 'Arvo';     font-display: auto;     src:local('Arvo'),url(https://fonts.jartto.wang/fonts/temp.woff2)format('woff2'); } ```  ##### 9.采用高效的缓存策略提供静态资源  > 延长缓存期限可加快重访网页的速度。  `DNS TTL(Time-To-Live)` 简单的说：**它表示一条域名解析记录在 `DNS` 服务器上的缓存时间。**  - 当各地的 `DNS` 服务器接受到解析请求时，就会向域名指定的 `DNS` 服务器发出解析请求从而获得解析记录。  - 在获得这个记录之后，记录会在 `DNS` 服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，`DNS` 服务器将不再向 `DNS` 服务器发出请求，而是直接返回刚才获得的记录。  > 这个记录在 `DNS` 服务器上保留的时间，就是 `TTL` 值。  所以一般更新域名解析的步骤如下：  - 先查看域名当前的 `TTL` 值。 - 修改 `TTL` 值为可设定的最小值，建议为 `60` 秒。 - 等待一天，保证各地的 `DNS` 服务器缓存都过期并更新了记录。 - 设置修改 `DNS` 解析到新的记录，这个时候各地的 `DNS` 就能以最快的速度更新到新的记录。 - 确认各地的 `DNS` 已经更新完成后，再 `TTL` 值设置成常用的值（如: `TTL=86400`）。  如下图，`TTL` 值设置的最佳实践，可供参考：  ![](https://qiniu.mdnice.com/9e8e0df4be75d8f3c38c87272b09248d.png)  > 后文我们会详细介绍 `DNS` 相关内容，欢迎各位童鞋关注。  ##### 10. 避免 `DOM` 规模过大  - 网页包含的 `DOM` 节点最好少于 `1500` 个左右。  - 理想状况是，树深度少于 `32` 个元素，且少于 `60` 个子/父元素。  - 大型 `DOM` 可能会增加内存使用量、导致样式计算用时延长并产生高昂的布局重排费用。  ##### 11. 最大限度地缩短关键请求深度  > `关键请求链` 显示了以高优先级加载的资源。  我们可以通过：缩短链长、缩减资源的下载文件大小，或者推迟下载不必要的资源，从而提高网页加载速度。  ![](https://qiniu.mdnice.com/d3e58cb28ee2bb2b482934fd847b2628.png)  当 `HTML` 解析过程中遇到一个 `script` 标记时，它会暂停 `DOM` 构建，将控制权移交给 `JavaScript` 引擎，等 `JavaScript` 引擎运行完毕，浏览器再从中断的地方恢复 `DOM` 构建。  > 也就是说，执行内联的 JavaScript 会阻塞页面的首次渲染。  在关键渲染路径中，我们通常要关注三个点：  - 页面首次渲染需要的关键资源数量。 - 关键资源的大小。 - 关键渲染路径的往返次数（`Roundtrip`）。  > 我们的策略也非常简单，就是减少关键资源数量，降低资源大小，减少关键路径的往返次数。  优化关键渲染路径的常规步骤如下：  1. 对关键路径进行分析和特性描述：资源数、字节数、长度。 2. 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。 3. 优化关键字节数以缩短下载时间（往返次数）。 4. 优化其余关键资源的加载顺序：您需要尽早下载所有关键资源，以缩短关键路径长度。  更多详情，请参考[前端性能优化—关键渲染路径](https://segmentfault.com/a/1190000013767948)。  ##### 12. 最大限度地减少主线程工作  考虑减少为解析、编译和执行 `JS` 而花费的时间。我们可以提供较小的 `JS` 负载来实现此目标。  ##### 13. 最优配置 `nginx`  1. `gzip` 配置  ``` gzip  on; gzip_min_length  1k; gzip_buffers     4 8k; gzip_http_version 1.1; gzip_comp_level 4; gzip_types text/plain text/css application/json image/png image/x-icon application/javascript application/x-javascript text/javascript text/xml application/xml application/xml+rss text/cache-manifest application/octet-stream; gzip_vary on; ```  2. `nginx` 开启缓存  如果你对浏览器缓存还不太清楚，欢迎移步聊一聊浏览器缓存机制。 ```js location ~.*\\.(html|htm|js|css|gif|jpg|jpeg|png|bmp|swf|ico|json|otf)$ {   root /var/www/jartto_web/;   index index.html;   expires 1d; } ```  > `Nginx` 能非常有效地直接处理静态内容。在静态文件和 `Nginx` 在同一主机的情况下，这种特性尤为有用。  ## 效果如何？  > 优化前：网站评分 27 ，首次内容绘制 6.9\b 秒  网站评分：  ![网站评分](https://qiniu.mdnice.com/ecd524b4a8b5c89b8734d2cd04ddf7f3.png)  加载概况：  ![](https://qiniu.mdnice.com/738d9f51faaa8587ae119ca2bc4c7220.png)  > 优化后：网站评分 70 ，首次内容绘制 1.6 秒  网站评分：  ![](https://qiniu.mdnice.com/24aab2e3d64a26560eb6106885c1087b.png)  加载概况：  ![](https://qiniu.mdnice.com/0b0264fdadf80ea3a5735a3802d12e95.png)  > 当然，优化还可以做更多，我们尽量让网站的评分接近 100 分，譬如：  网站评分：  ![](https://qiniu.mdnice.com/432bea1804a1f3a4569fc748bb4a10e6.png)  加载概况：  ![](https://qiniu.mdnice.com/88fa9e000b6fe2ec6ccfae530058c920.png)  ## 总结  我们从头优化下来，做了不少代码改动，也达到了不错的效果。但是有几点还是需要注意：  ##### 1. 尽可能减少白屏出现时间  骨架图解决 `webview` 加载页面过长的白屏过程。  ##### 2. 关注整站性能，如 `TTFB`  服务端接口也需要同步优化，而不要仅仅依赖前端单方面优化。  ##### 3. 按照使用情况加载优先使用的资源  - `css` 预加载 - `font` 预加载 - `js` 预加载 - 图片懒加载  ##### 4. 高效利用 `DNS` 和 `CDN`  - 增加缓存时间 - `DNS` 预解析   网站优化从来不是一蹴而就，需要不断的去优化细节，不断的摸索尝试。从我的角度来看，其实优化更像是在网站性能和加载速度之间找到一个平衡点。譬如，文中我们为了优化文件打包大小，进行了大文件拆分。随之而来的问题就是拆分后的文件可能还会对某些文件有依赖，那么就影响到了关键渲染路径。  所以，优化不存在什么奇技淫巧，不断的去尝试，找到这个最佳优化点，这才是根本。                           "},{title:"闭包",path:"/posts/Chapter1/%E9%97%AD%E5%8C%85.html",strippedContent:" ## 1. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用。  ##### 闭包的概念：闭包是可以记住并有权访问所在函数作用域的`函数`，即使这个`函数`是在当前函数作用域之外执行。  ```js function add() {     var a = 1;     return function closure(b) {          return a + b;      } } const closure = add(); console.log(closure(1)); // 2 ```  这段代码中，调用 `add()` 时会生成一个函数执行上下文，并推入到`执行上下文栈中`。 `add` 函数执行完毕后，它的执行上下文会从执行栈中推出，同时局部变量 `a` 会被清理才对，但我们在执行 `console.log(closure(1));`时却输出了结果 `2`。  我们发现，调用`add()`时，会返回一个函数 `ƒ closure(b) { return a + b; }`，说明局部变量 `a` 存储于 `closure` 函数作用域中，因此我们能得到结果 `2`。  返回的这个函数 `ƒ closure(b) { return a + b; }` 就是我们将要介绍的 **`闭包`**。  ### 闭包的实现原理  ##### 闭包是如何实现对外部作用域的变量存储的？  **我们需要先搞清楚：** 它是拷贝了变量 `a` 的值到其作用域中，还是 `a` 压根没有被销毁，而是给了闭包 `closure` 访问的权限。  ```js function add() {     var a = 1;     ++a;     return function closure(b) {         return a + b;     } } const closure = add(); console.log(closure(1)); ```  首先，我们在这段代码 `++a` 处打上断点，看下实际执行情况。  ![屏幕快照 2019-09-24 下午2.57.06.png](https://i.loli.net/2019/09/24/Raiyz5VeuqWP6jD.png)![屏幕快照 2019-09-24 下午2.53.13.png](https://i.loli.net/2019/09/24/p4urbaPhGJA1fxi.png)  我们发现调用栈为 `add`，在执行到断点处时，\b作用域对象 `Scope` 中存储了当前局部变量 `a` 的值为 `2`，这是我们预期的结果。  接着我们在代码 `return a + b;` 处打上断点，实际情况如下图所示：  ![屏幕快照 2019-09-24 下午3.06.28.png](https://i.loli.net/2019/09/24/itPuok97KMTNBfD.png)![屏幕快照 2019-09-24 下午2.49.18.png](https://i.loli.net/2019/09/24/SYpT7jrPiD8oBEV.png)  从 `Debug` 的结果来看，当执行到断点 `return a + b;` 处时，调用栈 `add` 被推出，当前调用栈变成了 `closure`，作用域对象 `Scope` 中局部变量 `a` 被销毁，只保存了当前调用栈 `closure` 中的变量 `b`。  而运行到此时，多出了一个 `Closure` 对象，它持有所在作用域 `add` 中的局部变量 `a` 属性，它的值为 `2`。  **这里我们应该能得知：** 它是拷贝了变量 `a` 的值到其作用域中进而给了闭包 `closure` 访问的权限。   **总结：**  JavaScript 在执行时，如果遇到上述含有 `闭包` 的代码，它会在内存开辟出一块空间，这个内存空间称为 `Closure` 对象，**它用来存储所在函数作用域中的变量，因此其所在作用域的变量即使被销毁，在外部也能访问到存储下来的变量。**  ***闭包查找变量是沿着作用域链向上查找的，本文并没有介绍的作用域链相关的知识，因为个人感觉闭包能缓存变量的原理并不是因为作用域链，作用域链只能说明闭包访问的范围。***  ### 闭包的应用场景 - **jQuery** 源码的实现（ jQuery 就是一个大的闭包 ）。 - 函数节流。 - **Ajax** 的回调函数。 - 处理循环中的异步操作。   "},{title:"编译原理",path:"/posts/Chapter3/",strippedContent:" ## 1. 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序？ ## 2. 正则表达式的匹配原理和性能优化。 ## 3. 如何将JavaScript代码解析成抽象语法树(AST)。 [参考：](https://juejin.im/post/5d84ae08e51d4561a705bbde) ## 4. base64 的编码原理。 ## 5. 几种进制的相互转换计算方法，在JavaScript 中如何表示和转换。                    "},{title:"CSS渲染原理",path:"/posts/Chapter2/css%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.html",strippedContent:' # CSS 渲染原理以及优化策略  转载自：[CSS 渲染原理以及优化策略](http://jartto.wang/2019/10/23/css-theory-and-optimization/)  作者：[Jartto\'s blog](http://jartto.wang/)  提起 CSS 很多童鞋都很不屑，尤其是看到 RedMonk 2019 Programming Language Rankings 的时候，CSS 竟然排到了第七位。  我们先来看看这张排行榜：  ![css渲染原理](https://qiniu.mdnice.com/ced39fe8d86bbdda3ff9894efc29fe04.png)  > 既然 CSS 这么重要，那么我们花点时间来研究相关原理也就物有所值了。  本节我们就来说说 CSS 渲染以及优化相关的内容，主要围绕以下几点，由浅入深，了解来龙去脉：  1. 浏览器构成 2. 渲染引擎 3. CSS 特性 4. CSS 语法解析过程 5. CSS 选择器执行顺序 6. 高效的 ComputedStyle 7. CSS 书写顺序对性能有影响吗 8. 优化策略  ## 浏览器构成  ![浏览器构成](https://qiniu.mdnice.com/876ffd1d133df17d40489d1ffd0094e4.png)  - **User Interface：**  \t用户界面，包括浏览器中可见的地址输入框、浏览器前进返回按钮、书签，历史记录等用户可操作的功能选项。  - **Browser engine：**  \t浏览器引擎，可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据，是浏览器各个部分之间相互通信的核心。  - **Rendering engine：**  \t渲染引擎，解析 DOM 文档和 CSS 规则并将内容排版到浏览器中显示有样式的界面，也就是排版引擎，我们常说的浏览器内核主要指的就是渲染引擎。  - **Networking：**  \t网络功能模块，是浏览器开启网络线程发送请求以及下载资源的模块。  - **JavaScript Interpreter：**  \tJS 引擎，解释和执行 JS 脚本部分，例如 V8 引擎。  - **UI Backend：**  \tUI 后端则是用于绘制基本的浏览器窗口内控件，比如组合选择框、按钮、输入框等。  - **Data Persistence：**  \t数据持久化存储，涉及 Cookie、LocalStorage 等一些客户端存储技术，可以通过浏览器引擎提供的 API 进行调用。  ## 渲染引擎  渲染引擎，解析 DOM 文档和 CSS 规则并将内容排版到浏览器中显示有样式的界面，也就是排版引擎，我们常说的浏览器内核主要指的就是渲染引擎。   ![渲染引擎](https://qiniu.mdnice.com/659e34263b0550b40df0962e0eaa86bb.png)   上图中，我们需要关注两条主线：  - 其一，`HTML Parser` 生成的 `DOM` 树； - 其二，`CSS Parser` 生成的 `Style Rules（CSSOM 树）`；  在这之后，`DOM` 树与 `Style Rules` 会生成一个新的对象，也就是我们常说的 `Render Tree` 渲染树，结合 `Layout` 绘制在屏幕上，从而展现出来。  ## CSS 特性  ### 优先级  ![css优先级](https://qiniu.mdnice.com/5f23224cb0001728119489d907fd5d03.png)  !important > 行内样式（权重1000） > ID 选择器（权重 100） > 类选择器（权重 10） > 标签（权重1） > 通配符 > 继承 > 浏览器默认属性  [示例代码一：](https://jsfiddle.net/a5xtdoq7/1/)  ```html <div >   <p id="box" class="text">Jartto\'s blog</p> </div> <style>   #box{color: red;}   .text{color: yellow;} </style> ``` 猜一猜，文本会显示什么颜色？当你知道 「ID 选择器 > 类选择器 」的时候，答案不言自明。  [升级一下：](https://jsfiddle.net/a5xtdoq7/3/)  ```html <div id="box">   <p class="text">Jartto\'s blog</p> </div> <style>   #box{color: red;}   .text{color: blue;} </style> ```  这里就考查到了规则「类选择器 > 继承」，`ID` 对文本来说是继承过来的属性，所以优先级不如直接作用在元素上面的类选择器。  ### 继承性  - 继承得到的样式的优先级是最低的，在任何时候，只要元素本身有同属性的样式定义，就可以覆盖掉继承值。  - 在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级。  有哪些属性是可以继承的呢，我们简单分一下类：  1. `font-family`、`font-size`、`font-weight` 等 `f` 开头的 CSS 样式。 2. `text-align`、`text-indent` 等 `t` 开头的样式。 3. `color`。  详细的规则，请看下图：  ![css继承性](https://qiniu.mdnice.com/edf561299277f81a019f06dbcaebae84.png)  [示例代码二：](https://jsfiddle.net/a5xtdoq7/)  ```html <div>   <ol>     <li> Jartto\'s blog </li>   </ol> </div>  <style>   div { color : red!important; }   ol { color : green; } </style> ```  增加了 `!important`，猜一猜，文本显示什么颜色？  ### 层叠性  ![css层叠性](https://qiniu.mdnice.com/327973348b19a730ca31ae8fa66e2b43.png)  **层叠就是浏览器对多个样式来源进行叠加，最终确定结果的过程。**  `CSS` 之所以有「层叠」的概念，是因为有多个样式来源。  `CSS` 层叠性是指 `CSS` 样式在针对同一元素配置同一属性时，依据层叠规则（权重）来处理冲突，选择应用权重高的 `CSS` 选择器所指定的属性，一般也被描述为权重高的覆盖权重低的，因此也称作层叠。  [示例代码三：](https://jsfiddle.net/a5xtdoq7/2/)  ```html <div >   <p class="two one">Jartto\'s blog</p> </div> <style>   .one{color: red;}   .two{color: blue;} <style> ``` 如果两个类选择器同时作用呢，究竟以谁为准？这里我们要考虑样式表中两个类选择器的先后顺序，后面的会覆盖前面的，所以文本当然显示蓝色了。  [升级代码：](https://jsfiddle.net/a5xtdoq7/6/)  ```html <div>   <div>     <div>Jartto\'s blog</div>   </div> </div>  <style>   div div div { color: green; }   div div { color: red; }   div { color: yellow; } <style> ```  这个比较直接，算一下权重，谁大听谁的。  [继续升级：](https://jsfiddle.net/a5xtdoq7/7/) ```html <div id="box1" class="one">   <div id="box2" class="two">     <div id="box3" class="three"> Jartto\'s blog </div>   </div> </div> <style>   .one .two div { color : red; }   div #box3 { color : yellow; }   #box1 div { color : blue; } </style> ``` 权重： ``` 0 0 2 1 0 1 0 1 0 1 0 1 ``` [验证一下：](https://jsfiddle.net/a5xtdoq7/9/)  ```html <div id="box1" class="one">   <div id="box2" class="two">     <div id="box3" class="three"> Jartto\'s blog </div>   </div> </div> <style> .one .two div { color : red; } #box1 div { color : blue; } div .three { color : green; } </style> ``` 权重： ``` 0 0 2 1 0 1 0 1 0 0 1 1 ``` 如果你对上面这些问题都了如指掌，那么恭喜你，基础部分顺利过关，可以继续升级了！  ## CSS 语法解析过程  1.我们来把 `CSS` 拎出来看一下，`HTML Parser` 会生成 `DOM` 树，而 `CSS Parser` 会将解析结果附加到 `DOM` 树上，如下图：  ![css](https://qiniu.mdnice.com/4740d2eda89c6e7d1207ea2bdd82f5d5.png)  2.`CSS` 有自己的规则，一般如下： `WebKit` 使用 `Flex` 和 `Bison` 解析器生成器，通过 `CSS` 语法文件自动创建解析器。`Bison` 会创建自下而上的移位归约解析器。`Firefox` 使用的是人工编写的自上而下的解析器。  这两种解析器都会将 `CSS` 文件解析成 `StyleSheet` 对象，且每个对象都包含 `CSS` 规则。`CSS` 规则对象则包含选择器和声明对象，以及其他与 `CSS` 语法对应的对象。  ![css语法解析](https://qiniu.mdnice.com/7d79c0e7f29d0e2c9c1118ab7087fa98.png)  3.`CSS` 解析过程会按照 `Rule`，`Declaration` 来操作：  ![css语法解析](https://qiniu.mdnice.com/00f9ffe24b6181d761c6df624aab2862.png)  4.那么他是如何解析的呢，我们不妨打印一下 `CSS Rules`：  控制台输入： ```js document.styleSheets[0].cssRules ```  ![css语法解析](https://qiniu.mdnice.com/00f9ffe24b6181d761c6df624aab2862.png)  打印出来的结果大致分为几类：  - cssText：存储当前节点规则字符串 - parentRule：父节点的规则 - parentStyleSheet：包含 cssRules，ownerNode，rules 规则 - …  > 规则貌似有点看不懂，不用着急，我们接着往下看。  5.`CSS` 解析和 `Webkit` 有什么关系？  ![css语法解析](https://qiniu.mdnice.com/3d43e6778f42855507d3bc08d21c148a.png)  > CSS 依赖 WebCore 来解析，而 WebCore 又是 Webkit 非常重要的一个模块。  要了解 WebCore 是如何解析的，我们需要查看[相关源码](https://github.com/WebKit/webkit/tree/master/Source/WebCore/css)：  ```js CSSRule* CSSParser::createStyleRule(CSSSelector* selector)   {       CSSStyleRule* rule = 0;       if (selector) {           rule = new CSSStyleRule(styleElement);           m_parsedStyleObjects.append(rule);           rule->setSelector(sinkFloatingSelector(selector));           rule->setDeclaration(new CSSMutableStyleDeclaration(rule, parsedProperties, numParsedProperties));       }       clearProperties();       return rule;   } ```  从该函数的实现可以很清楚的看到，解析器达到某条件需要创建一个 `CSSStyleRule` 的时候将调用该函数，该函数的功能是创建一个 `CSSStyleRule`，并将其添加已解析的样式对象列表 `m_parsedStyleObjects` 中去，这里的对象就是指的 `Rule`。  > 注意：源码是为了参考理解，不需要逐行阅读！  `Webkit` 使用了自动代码生成工具生成了相应的代码，也就是说词法分析和语法分析这部分代码是自动生成的，而 `Webkit` 中实现的 `CallBack` 函数就是在 `CSSParser` 中。  这时候就不得不提到 `AST` 了，我们继续剖析。  补充阅读：[Webkit 对 CSS 支持](https://webkit.org/status/#?search=css)  6.关于 `AST`  如果对 AST 还不了解，请移步 [AST 抽象语法树](http://jartto.wang/2018/11/17/about-ast/)。这里我们不做过多解释，主要围绕如何解析这一过程展开，先来看一张 `Babel` 转换过程图：  ![ast](https://qiniu.mdnice.com/f62234d2e79c5c5fe466267e7355ce3d.png)  我们来举一个简单的例子，声明一个箭头函数，如下：  ```js let jarttoTest = () => {   // Todo } ``` 通过[在线编译](https://astexplorer.net/)，生成如下结果：  ![ast](https://qiniu.mdnice.com/90568fb1d02fa5c33fa27e980b4b2c8b.png)  从上图我们可以看出：我们的箭头函数被解析成了一段标准代码，包含了类型，起始位置，结束位置，变量声明的类型，变量名，函数名，箭头函数表达式等等。  标准的解析代码，我们可以对其进行一些加工和处理，之后通过相应 API 输出。  很多场景都会用到这个过程，如：  - JS 反编译，语法解析。 - Babel 编译 ES6 语法。 - 代码高亮。 - 关键字匹配。 - 作用域判断。 - 代码压缩。 - …  场景千千万，但是都离不开一个过程，那就是：  > AST 转换过程：解析 - 转换 - 生成  到这里，`CSS` 如何解析的来龙去脉我们已经非常清楚了，可以回到文章开头的那个流程图了，相信你一定会有另一翻感悟。  ## CSS 选择器执行顺序  渲染引擎解析 `CSS` 选择器时是从右往左解析，这是为什么呢？举个例子：  ```html <div>    <div class="jartto">       <p><span> 111 </span></p>       <p><span> 222 </span></p>       <p><span> 333 </span></p>       <p><span class=\'yellow\'> 444 </span></p>    </div> </div>  <style>   div > div.jartto p span.yellow {    color: yellow;   } </style> ```  **我们按照「从左到右」的方式进行分析：** 1. 先找到所有 `div` 节点。 2. 在 `div` 节点内找到所有的子 `div`，并且是 `class = “jartto”`。 3. 然后再依次匹配 `p span.yellow` 等情况。 4. 遇到不匹配的情况，就必须回溯到一开始搜索的 `div` 或者 `p` 节点，然后去搜索下个节点，重复这样的过程。  这样的搜索过程对于一个只是匹配很少节点的选择器来说，效率是极低的，因为我们花费了大量的时间在回溯匹配不符合规则的节点。  **我们按照「从右向左」的方式进行分析：** 1. 首先就查找到 `class=“yellow”` 的 `span` 元素。 2. 接着检测父节点是否为 `p` 元素，如果不是则进入同级其他节点的遍历，如果是则继续匹配父节点满足 `class=“jartto”` 的 `div` 容器。 3. 这样就又减少了集合的元素，只有符合当前的子规则才会匹配再上一条子规则。  综上所述，我们可以得出结论：  > 浏览器 CSS 匹配核心算法的规则是以从右向左方式匹配节点的。  这样做是为了减少无效匹配次数，从而匹配快、性能更优。  所以，我们在书写 `CSS Selector` 时，从右向左的 `Selector Term` 匹配节点越少越好。  不同 `CSS` 解析器对 `CSS Rules` 解析速度差异也很大，感兴趣的童鞋可以看看 [CSS 解析引擎](http://test.veryos.com/selector/slickspeed/index.html)，这里不再赘述。  ## 高效的 ComputedStyle  浏览器还有一个非常棒的策略，在特定情况下，浏览器会共享 `Computed Style`，网页中能共享的标签非常多，所以能极大的提升执行效率！  如果能共享，那就不需要执行匹配算法了，执行效率自然非常高。  如果两个或多个 `Element` 的 `ComputedStyle` 不通过计算可以确认他们相等，那么这些 `ComputedStyle` 相等的 `Elements` 只会计算一次样式，其余的仅仅共享该 `ComputedStyle`。  ```html <section class="one">     <p class="desc">One</p> </section>  <section class="one">     <p class="desc">two</p> </section> ```  **如何高效共享 Computed Style ？**  1. `TagName` 和 `Class` 属性必须一样。 2. 不能有 `Style` 属性。哪怕 `Style` 属性相等，他们也不共享。 3.不能使用 `Sibling selector`，譬如: `first-child`、 `:last-selector`、 `+ selector`。 4.`mappedAttribute` 必须相等。  为了更好的说明，我们再举两个例子：  不能共享，上述规则 `2`： ```html <p style="color:red">jartto\'s</p>   <p style="color:red">blog</p> ```  可以共享，上述规则 `4`： ```html <p align="middle">jartto\'s</p> <p align="middle">blog</p> ```  到这里，相信你对 `ComputedStyle` 有了更多的认识，代码也就更加精炼和高效了。  ## CSS 书写顺序对性能有影响吗？  需要注意的是：浏览器并不是一获取到 `CSS` 样式就立马开始解析，而是根据 `CSS` 样式的书写顺序将之按照 DOM 树的结构分布渲染样式，然后开始遍历每个树结点的 `CSS` 样式进行解析，此时的 `CSS` 样式的遍历顺序完全是按照之前的书写顺序。  > 在解析过程中，一旦浏览器发现某个元素的定位变化影响布局，则需要倒回去重新渲染。  我们来看看下面这个代码片段：  ``` width: 150px; height: 150px; font-size: 24px; position: absolute; ```   **当浏览器解析到 `position` 的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染。**  渲染引擎首先解除该元素在文档中所占位置，这就导致了该元素的占位情况发生了变化，其他元素可能会受到它回流的影响而重新排位。  我们对代码进行调整：  ``` position: absolute; width: 150px; height: 150px; font-size: 24px; ```  这样就能让渲染引擎更高效的工作，可是问题来了：  > 在实际开发过程中，我们如何能保证自己的书写顺序是最优呢？  这里有一个规范，建议顺序大致如下：  1. 定位属性      ```     position  display  float  left  top  right  bottom   overflow  clear   z-index     ```  2. 自身属性      ```     width  height  padding  border  margin   background     ``` 3. 文字样式      ```     font-family   font-size   font-style   font-weight   font-varient   color     ``` 4. 文本属性      ```     text-align   vertical-align   text-wrap   text-transform   text-indent    text-decoration   letter-spacing    word-spacing    white-space   text-overflow     ``` 5. CSS3 中新增属性      ```     content   box-shadow   border-radius  transform     ```  当然，我们需要知道这个规则就够了，剩下的可以交给一些插件去做，譬如 [CSSLint](https://github.com/CSSLint/csslint)（能用代码实现的，千万不要去浪费人力）。  ## 优化策略 我们从浏览器构成，聊到了渲染引擎，再到 `CSS` 的解析原理，最后到执行顺序，做了一系列的探索。期望大家能从 `CSS` 的渲染原理中了解整个过程，从而写出更高效的代码。  1.使用 `id selector` 非常的高效。在使用 `id selector` 的时候需要注意一点：因为 `id` 是唯一的，所以不需要既指定 `id` 又指定 `tagName`：  ```css /* Bad  */ p#id1 {color:red;}    /* Good  */ #id1 {color:red;} ```  2.避免深层次的 `node`，譬如： ```css /* Bad  */ div > div > div > p {color:red;}  /* Good  */ p-class{color:red;} ```  3.不要使用 `attribute selector`，如：`p[att1=”val1”]`，这样的匹配非常慢。更不要这样写：`p[id="id1"]`，这样将 `id selector` 退化成 `attribute selector`。  ```css /* Bad  */ p[id="jartto"]{color:red;}   p[class="blog"]{color:red;}   /* Good  */ #jartto{color:red;}   .blog{color:red;} ```  4.通常将浏览器前缀置于前面，将标准样式属性置于最后，类似： ```css .foo {   -moz-border-radius: 5px;   border-radius: 5px; } ``` 可以参考这个 [Css 规范](http://nec.netease.com/standard/css-sort.html)。  5.遵守 [CSSLint](https://github.com/CSSLint/csslint) 规则  ``` font-faces        　　　　  　　　不能使用超过5个web字体 import        　　　　　　　 　　  禁止使用@import regex-selectors        　　　　  禁止使用属性选择器中的正则表达式选择器 universal-selector    　　 　　  禁止使用通用选择器* unqualified-attributes    　　　禁止使用不规范的属性选择器 zero-units            　　 　　　0后面不要加单位 overqualified-elements    　　　使用相邻选择器时，不要使用不必要的选择器 shorthand        　　　　　　　　 简写样式属性 duplicate-background-images    相同的url在样式表中不超过一次 ``` 6.减少 `CSS` 文档体积  - 移除空的 `CSS` 规则（`Remove empty rules`）。 - 值为 `0` 不需要单位。 - 使用缩写。 - 属性值为浮动小数 `0.xx`，可以省略小数点之前的 `0`。 - 不给 `h1-h6` 元素定义过多的样式。  7.`CSS Will Change`  `WillChange` 属性，允许作者提前告知浏览器的默认样式，使用一个专用的属性来通知浏览器留意接下来的变化，从而优化和分配内存。  8.不要使用 `@import` 使用 `@import` 引入 `CSS` 会影响浏览器的并行下载。  使用 `@import` 引用的 `CSS` 文件只有在引用它的那个 `CSS` 文件被下载、解析之后，浏览器才会知道还有另外一个 `CSS` 需要下载，这时才去下载，然后下载后开始解析、构建 `Render Tree` 等一系列操作。  多个 `@import` 会导致下载顺序紊乱。在 IE 中，`@import` 会引发资源文件的下载顺序被打乱，即排列在 `@import` 后面的 `JS` 文件先于 `@import` 下载，并且打乱甚至破坏 `@import` 自身的并行下载。  9.避免过分回流/重排（`Reflow`）  浏览器重新计算布局位置与大小。  常见的重排元素： ``` width  height  padding  margin  display  border-width  border  top  position  font-size  float  text-align  overflow-y  font-weight  overflow  left  font-family  line-height  vertical-align  right  clear  white-space  bottom  min-height ```  10.高效利用 `computedStyle`  - 公共类。 - 慎用 `ChildSelector`。 - 尽可能共享。  > 更多请查看上文 - 高效的 ComputedStyle   11.减少昂贵属性 当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写 `CSS` 时，我们应该尽量减少使用昂贵属性，如：  - `box-shadow`。 - `border-radius`。 - `filter`。 - `:nth-child`。  12.依赖继承 如果某些属性可以继承，那么自然没有必要在写一遍。  13.遵守 `CSS` 顺序规则  上面就是对本文的一个总结，你了解 `CSS` 具体的实现原理，晓得规避错误书写方式，知道为什么这么优化，这就够了。  性能优化，进无止境。   文章首发于 [Jartto\'s blog](http://jartto.wang/2019/10/23/css-theory-and-optimization/)'},{title:"回流与重绘",path:"/posts/Chapter2/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%E5%8E%9F%E7%90%86.html",strippedContent:" ## 1. 回流与重绘的底层原理，引发原因，如何有效避免。 ![浏览器的渲染过程](https://qiniu.mdnice.com/01ad76b52063b38398ffde4cade3edb9.png)  ### 浏览器的渲染过程： 1. 解析 `HTML` 树生成 `DOM` 树，解析 `CSS` 生成 `CSSOM` 树。 2. 将 `DOM` 树和 `CSSOM` 树结合生成渲染树 `renderTree`。 3. `Layout（回流）`：根据生成的 `renderTree` 进行回流（`Layout`），得到节点的几何信息（位置、大小）。 4. `Painting（重绘）`：根据 `renderTree` 以及回流 `Layout` 得到节点的绝对像素。 5. `Display`：将像素发送给 **GPU** 线程，展示在页面上。  #### 生成渲染树 - renderTree ![image](https://qiniu.mdnice.com/879265b75b6f3681721fff44b582b4ef.png)  为了构建渲染树，浏览器主要完成了以下工作。  - 从 `DOM` 树的根节点开始遍历每个可见节点。 - 对于每个可见的节点，找到 `CSSOM` 树中对应的规则，并应用它们。 - 根据每个可见节点以及其对应的样式，组合生成渲染树。  第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：  - 一些不会渲染输出的节点，比如 `script`、`meta`、`link` 等。 - 一些通过 `css` 进行隐藏的节点。比如 `display:none`。（注意，利用 `visibility` 和 `opacity` 隐藏的节点，还是会显示在渲染树上的，只有 `display:none;` 的节点才不会显示在渲染树上。）  ####  回流 - Layout 前面我们通过构造渲染树 `renderTree`，我们将可见 `DOM` 节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(`viewport`)内的确切位置和大小，这个计算的阶段就是**回流**。  为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历,而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。  #### 重绘 - Painting 通过回流(`Layout`)阶段，我们知道了所有的可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做**重绘**。  #### 何时会发生回流重绘？ 回流 `Layout` 阶段是计算节点的几何信息和位置，那么当**页面布局**或者**几何信息**发生改变时，就会发生回流。 1. 添加或者删除可见的 `DOM` 元素。 2. 元素的尺寸或者位置发生变化时。 3. 页面开始渲染的时候。 4. 浏览器的视口尺寸大小发生改变时（因为回流是根据浏览器视口的大小来计算元素的位置和尺寸大小）。  **注意：回流一定会触发重绘，而重绘不一定会触发回流（非几何信息的样式发生改变）, `reflow` 回流的成本开销要高于 `repaint` 重绘，一个节点的回流往往回导致子节点以及同级节点的回流。**  根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。  #### 基于回流（Layout）、重绘（Painting）的优化方法  ##### 1. 避免扰乱现代浏览器的优化机制 在现代浏览器的中，由于每次回流、重绘的时候，都需要额外的计算消耗，因此会通过队列化修改，并批量执行来优化这一过程。 浏览器会将修改操作放入队列里面，直到过了一段时间或者达到一个阈值，才清空队列。   但是当你获取布局信息时，会强制刷新队列，例如：  ```js offsetTop、offsetLeft、offsetWidth、offsetHeight  scrollTop、scrollLeft、scrollWidth、scrollHeight  clientTop、clientLeft、clientWidth、clientHeight  getComputedStyle()  getBoundingClientRect() ```  上面这些方法，都需要获取最新的布局信息，所以浏览器会强制刷新队列并执行回流、重绘，来获取最新的信息。 因此我们在修改样式的时候，应该尽量避免使用上面的属性、方法，如果非要使用，可以先缓存起来然后一起获取。  ##### 2. `CSS` 的修改方式  考虑以下代码： ```js const el = document.getElementById('el') el.style.padding = 'xxx' el.style.margin = 'xxx' el.style.border = 'xxx' ```  这里元素的几何信息有三次被修改了，但是现代浏览器会将起缓存起来，但是如果这期间有通过前面列出来的属性、方法访问位置信息的话就会触发三次回流、重绘。所以还是建议通过 `cssText` 或者 `class` 的方法一次性修改。  ```js el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;'; // 或者 el.className += 'xxx'; ```  ##### 3. 批量修改 DOM 当我们需要对 `DOM` 进行一系列修改的时候，可以通过以下几种方式减少回流重绘次数：  - 隐藏元素，应用修改，重新显示：     ```js     function appendDataToElement (appendToElement, data) {          let li;         for ( let i = 0; i < data.length; i++) {         li = document.createElement('li');         li.textContent = 'text';         appendToElement.appendChild(li);             }     }      const ul = document.getElementById('list');     ul.style.display = 'none'; // 首先脱离文档流     appendDataToElement(ul, data);     ul.style.display = 'block'; // 操作完以后再可见          ```  - 使用文档片段(`document fragment`)在当前 `DOM` 之外构建一个子树，再把它拷贝回文档。     ```js     const ul = document.getElementById('list');     const fragment = document.createDocumentFragment();     appendDataToElement(fragment , data);     ul.appendChild(fragment);     ``` ##### 4. 独立图层 一个图层的回流和重绘只会在该图层当中进行，不会影响其他图层，所以有必要的时候，可以将某些元素放到单独的图层。  例如对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流， 成为一个单独的图层。否则会引起父元素以及后续元素频繁的回流。但是因该尽量少量使用图层，因为图层的合成是特别消耗性能，一个页面当中不能有过多的图层, 在使用了图层之后需要进行前后对比。   会自动建立图层的情况:  - `3d` 或者透视变换、过渡 `css` 属性。 - 使用 `<video>` 节点。 - `<canvas>`。 - `flash`。 - 多透明度做 `css` 动画。   ##### 5. 其他优化  - 用 `translate` 替代 `top` 改变：`top` 会触发回流，而前者不会。 - 用 `opacity` 替代 `visibility`： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发。 - 不要使用 `table` 布局，`table` 可能很小的一个改动会造成回流，很影响性能，应该尽量使用 `div`。 - 动画实现的速度选择。 - 对于动画新建图层。 - 启用 GPU 硬件加速: 使用 `transform:translateZ(0)`、`transform:translate3d(0,0,0)` 来开启 GPU 硬件加速。   ### CSS 和 JS 是这样阻塞 DOM 解析和渲染的  通过 `<script>` 与 `<link>` 引入外部资源，当解析到该标签的时候，会进行下载。  1. CSS 脚本的加载不会阻塞 `DOM` 解析过程，但是会阻塞渲染过程(`painting`)。 2. JS 脚本的加载与执行会阻塞 `DOM` 解析过程, 但是不会阻塞后续资源的加载。 3. JS 脚本的加载中，如果你确定没必要阻塞 `DOM` 解析的话，不妨按需要加上 `defer` 或者 `async` 属性，此时脚本下载的过程中是不会阻塞 `DOM` 解析的。 4. 浏览器遇到 `<script>` 且没有 `defer` 或 `async` 属性的标签时，为了为 `<script>` 标签内部的 js 提供最新的信息，会触发页面的回流、重绘过程。 5. 如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕之后再执行脚本。即 css 不阻塞 js 的加载，但阻塞它的执行。  所以 `<script>` 最好放底部(防止阻塞 `DOM` 解析)。 `<link>` 最好放头部(为渲染过程提供样式)。如果头部同时有 `<script>` 与 `<link>` 的情况下，最好将 `<script>` 放在 `<link>` 上面(为了防止 CSS 脚本加载时间过长，使 js 等待时间也很长)。  ### defer 和 async  绿色的代表 `html` 解析，蓝色的代表 `javascript` 脚本的下载，红色的代表 `javaScript` 脚本的执行。   ![defer&async](https://qiniu.mdnice.com/d5471718236806507193c95751fba3a9.png)   ## 9. 浏览器的垃圾回收机制，如何避免内存泄漏。  JavaScript 使用垃圾回收机制来自动管理内存。  JavaScript 的回收机制分两种：1.标记清除； 2.引用计数。（各大浏览器常用的是前）。  ### 引用计数 跟踪记录每个值被引用的次数。  - 当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是 `1`。 - 如果同一个值又被赋给另一个变量，则该值的引用次 数加 `1`。 - 相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减 `1`。 - 当这个值的引用次数变成 `0` 时，则说明没有办法访问这个值了，因此就可以将其占用的内存空间回收回来。  ```js var a = {};     对象 a 的引用计数为 1 b = a;          对象 a 的引用计数为 1 + 1  a = null;       对象 a 的引用计数为 2 - 1 不能被回收。 ``` ### 标记清除 标记清除的算法分为两个阶段： - 标记（mark）：从引用根节点开始标记所有被引用的对象。 - 清除（sweep）：遍历整个堆，把未标记的对象进行清除。  ```js markFromRoots():     worklist <- empty     for each fld in Roots         ref <- *fld         if ref != null && isNotMarked(ref)              setMarked(ref)            add(worklist,ref)            mark() mark():     while not isEmpty(worklist)           ref <- remove(worklist)             for each fld in Pointers(ref)                   child <- *fld                 if child != null && isNotMarked(child)                    setMarked(child)                    add(worklist,child)  sweep(start,end):     scan <- start    while scan < end        if isMarked(scan)           setUnMarked(scan)       else           free(scan)       scan <- nextObject(scan)  atomic collect():     markFromRoots()     sweep(HeapStart,HeapEnd) ```   ### 开发过程中遇到的内存泄露情况  #### 1. 定义和用法  内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。  *`C#` 和 `Java` 等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。*  我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有 `bug`，会产生内存泄露。     由于每次的垃圾回收开销都相对较大，并且由于机制的一些不完善的地方，可能会导致内存泄露。我们可以利用一些方法减少垃圾回收，并且**尽量避免循环引用**的问题。  - 例如，在对象结束使用后，令 `obj = null`（这样利于解除循环引用，使得无用变量及时被回收）。  - 再如，JS 中开辟空间的操作有 `new()`、`[]`、`{}`、`function (){..}`，在创建新对象的时候要尽量考虑增大对象的**复用性**。  #### 2. 内存泄漏的几种情况 虽然有垃圾回收机制，但是，我们编写代码操作不当还是会造成内存泄漏。  1. 意外的全局变量引起的内存泄漏。     ```     原因：全局变量，不会被回收。     解决：使用严格模式避免。     ```  2. 闭包引起的内存泄漏。     ```     原因：闭包可以维持函数内局部变量，使其得不到释放。     解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对 dom 的引用。     ``` 3. 没有清理的 `DOM` 元素引用。     ```     原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用。     解决：手动删除。     ```  4. 被遗忘的定时器或者回调。     ```     原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。     解决：手动删除定时器和 dom。     ```  5. 子元素存在引用引起的内存泄漏。     ```     原因：造成父元素间接引用子元素，即使子元素被清空，也还是在内存中。     解决：手动删除清空。     ```     2、内存泄露的几种情况:  虽然有垃圾回收机制，但是，我们编写代码操作不当还是会造成内存泄漏。  1.    意外的全局变量引起的内存泄漏。  原因：全局变量，不会被回收。  解决：使用严格模式避免。  2.    闭包引起的内存泄漏  原因：闭包可以维持函数内局部变量，使其得不到释放。  解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。  3.    没有清理的DOM元素引用  原因：虽然别的地方删除了，但是对象中还存在对dom的引用  解决：手动删除。  4.    被遗忘的定时器或者回调  原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。  解决：手动删除定时器和dom。  5.    子元素存在引用引起的内存泄漏  原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。  解决：手动删除清空。"},{title:"判断数据类型",path:"/posts/Chapter1/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",strippedContent:" # 至少说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型？  ## typeof `typeof`是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：`number`、`boolean`、`symbol`、`string`、`object`、`undefined`、`function` 等。  ```js typeof '';             // string 有效 typeof 1;              // number 有效 typeof Symbol();       // symbol 有效 typeof true;           // boolean 有效 typeof undefined;      // undefined 有效 typeof null;           // object 无效 typeof [] ;            // object 无效 typeof new Function(); // function 有效 typeof new Date();     // object 无效 typeof new RegExp();   // object 无效 ``` **缺点：**  ```js typeof 对于引用类型中的数组、日期、正则等类型的处理，只返回了处于其原型链最顶端的 Object 类型； 对应 null 返回的是 \"object\"，而 null 有自己的数据类型 Null。 ``` ## instanceof  `instanceof` 是用来判断 `a` 是否为 `B` 的实例，表达式为：`a instanceof B`，如果 `a` 是 `B` 的实例，则返回 `true`，否则返回 `false`。 **在这里需要特别注意的是：`instanceof` 检测的是原型对象。**  ```js // 伪代码实现 instanceof (a,B) = {     var L = a.__proto__;     var R = B.prototype;     if(L === R) {         // A的内部属性 __proto__ 指向 B 的原型对象         return true;     }     return false; } ``` 从上述过程可以看出，当 `a` 的 `__proto__` 指向 `B` 的原型对象时，就认为 `a` 就是 `B` 的实例，我们再来看几个例子：  ```js [] instanceof Array; // true {} instanceof Object;// true new Date() instanceof Date;// true   function Person(){}; new Person() instanceof Person;   [] instanceof Object; // true new Date() instanceof Object;// true new Person instanceof Object;// true ``` 我们发现，虽然 `instanceof` 能够判断出 `[]` 是 `Array` 的实例，但它认为 `[]` 也是 `Object` 的实例，为什么呢？  我们来分析一下 `[]`、`Array`、`Object` 三者之间的关系：  从 `instanceof` 能够判断出 `[].__proto__`  指向 `Array.prototype`，而 `Array.prototype.__proto__` 又指向了 `Object.prototype`，最终 `Object.prototype.__proto__`指向了 `null`，标志着原型链的结束。  因此，`[]`、`Array`、`Object` 就在内部形成了一条原型链：  ![849589-20160112232510850-2003340583.png](https://i.loli.net/2019/09/21/fevn2goItbBzqKc.png)  从原型链可以看出，`[]` 的 `__proto__`  直接指向 `Array.prototype`，间接指向 `Object.prototype`，所以按照 `instanceof` 的判断规则，`[]` 就是 `Object` 的实例。依次类推，类似的 `new Date()`、`new Person()` 也会形成一条对应的原型链 。  ### 缺点  ```js instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 ```  ### 拓展  `instanceof` 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。  ```js var iframe = document.createElement('iframe'); document.body.appendChild(iframe); xArray = window.frames[0].Array; var arr = new xArray(1,2,3); // [1,2,3] arr instanceof Array; // false ``` ## Array.isArray()  针对数组的这个问题，ES5 提供了 `Array.isArray()` 方法。该方法用以确认某个对象本身是否为 `Array` 类型，而不区分该对象在哪个环境中创建。 ```js if (Array.isArray(value)){    //对数组执行某些操作 } ``` `Array.isArray()` 本质上检测的是对象的 `[[Class]]` 值，`[[Class]]` 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 `[object Xxx]` ，`Xxx` 就是对应的具体类型。对于数组而言，`[[Class]]` 的值就是 [object Array] 。  ## toStrig()  `toString()` 是 `Object` 的原型方法，调用该方法，默认返回当前对象的 `[[Class]]`。这是一个内部属性，其格式为 `[object Xxx]`，其中 `Xxx` 就是对象的类型。  对于 `Object` 对象，直接调用 `toString()` 就能返回 `[object Object]`。而对于其他对象，则需要通过 `call / apply` 来调用才能返回正确的类型信息。  ```js Object.prototype.toString.call('') ;   // [object String] Object.prototype.toString.call(1) ;    // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object Window] window 是全局对象  ```  ## constructor  当一个函数 `F` 被定义时，JS 引擎会为 `F` 添加 `prototype` 原型对象，然后再在 `prototype`上添加一个 `constructor` 属性，并让其指向 `F` 的引用。  如下所示：  ![849589-20170508125250566-1896556617.png](https://i.loli.net/2019/09/21/iFpwzxHVIlKDRJL.png)  当执行 `var f = new F()` 时，`F` 被当成了构造函数，`f` 是 `F` 的实例对象，此时 `F` 原型上的 `constructor` 传递到了 `f` 上，因此 `f.constructor == F`。  ![849589-20170508125714941-1649387639.png](https://i.loli.net/2019/09/21/veHsCKjrDYIFUAW.png)  可以看出，`F` 利用原型对象上的 `constructor` 引用了自身，当 `F` 作为构造函数来创建对象时，原型上的 `constructor `就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 `F` 就是新对象的类型。**这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。**  同样，`JavaScript` 中的内置对象在内部构建时也是这样做的：  ![849589-20170508131800457-2091987664.png](https://i.loli.net/2019/09/21/uHZb16KyLsComNq.png)  ### 细节问题  **`null` 和 `undefined` 是无效的对象，因此是不会有 `constructor` 存在的，这两种类型的数据需要通过其他方式来判断。**  函数的 `constructor` 是不稳定的，这个主要体现在自定义对象上，当开发者重写 `prototype` 后，原有的 `constructor` 引用会丢失，`constructor` 会默认为 `Object`。  ![849589-20170508132757347-1999338357.png](https://i.loli.net/2019/09/21/9hrsbizMQag3kpI.png)   因为 `prototype` 被重新赋值的是一个 `{}`， `{}` 是 `new Object()` 的字面量，因此 `new Object()` 会将 `Object` 原型上的 `constructor` 传递给 `{}`，也就是 `Object` 本身。  因此，为了规范开发，在重写对象原型时一般都需要重新给 `constructor` 赋值，以保证对象实例的类型不被篡改。  ## 总结 - `typeof` 检测引用类型和 `null` 时，除了函数都会显示 `\"object\"`。 - 检测函数使用推荐使用 `typeof`。 - **instanceof：** 检测对象是否是某个构造函数的实例。 - **Array.isArray()：** 判断是否为 `Array` 数据类型时使用。 - **constructor：** 可以使用 `constructor` 属性验证实例的原始类型（与操作符 `instanceof` 非常类似）。 - **toString()：** 万能。  ```js 检测对象的属性是否存在使用 in 运算符或者使用 Object.hasOwnProperty() ```  *本节参考：[一像素-判断数据类型的四种方法](https://www.cnblogs.com/onepixel/p/5126046.html)*"},{title:"this",path:"/posts/Chapter1/this.html",strippedContent:' ## 1. this 的原理以及几种不同使用场景的取值。  **this** 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于`函数调用时`的各种条件。  **this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**  当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。`this` 就是记录的其中一个属性，会在函数执行的过程中用到。  理解`调用栈`和`调用位置`： ```js function baz() {     // 当前调用栈是: baz     console.log( "baz" );     bar(); // <-- bar 的调用位置  } function bar() {     // 当前调用栈是 baz -> bar     console.log( "bar" );     foo(); // <-- foo 的调用位置，当前调用位置在 baz 中 } function foo() {     // 当前调用栈是 baz -> bar -> foo      // 因此，当前调用位置在 bar 中     console.log( "foo" ); } baz(); // <-- baz 的调用位置，当前调用位置是全局作用域   ``` **this 绑定遵循以下四种规则：** `默认绑定`、`隐式绑定`、`显示绑定`、`new 绑定`。  #### 1. 默认绑定：独立函数调用，`this` 指向全局对象。调用时前边没有或省略 `.` 操作符号。 ```js function foo() {      console.log(this.a); } var a = 2; // window.a = 2; foo(); // window.foo(); ``` **注意：** ```js 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined. ``` #### 2. 隐式绑定：调用位置是否有上下文对象，也就是说，函数被作为某个对象的方法被调用时，`this` 指向那个对象。  ```js function foo() {      console.log(this.a); } var obj2 = {      a: 42,     foo: foo  }; var obj1 = {      a: 2,     obj2: obj2  }; obj1.obj2.foo(); // 42 ``` 上段代码中，词法作用域只会查找最顶层的 `obj1`，按着对象属性访问规则，会在自身上查找属性 `obj2`，所以 `this` 指向 `obj2`，\b所以 `this.a` 等于 `bj2.a`。  **对象属性引用链中只有最顶层或者说最后一层会影响调用位置。**   **注意：** ```js 会出现隐式丢失的情况： this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定， 从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。 ```  #### 3. 显示绑定：使用 `call`、`apply` 或者 `bind` 绑定到指定的对象。**this指向传入的第一个参数。**  ```js function foo() {      console.log(this.a); } var obj = {      a:2 }; var bar = function() {      foo.call(obj); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的 bar 不可能再修改它的 this  bar.call( window ); // 2 ``` **注意：** ```js 把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则。 ```   #### 4. `new` 绑定：`this` 指向创建的空对象 `{}`。  使用 `new` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：  1. 创建(或者说构造)一个全新的对象。  2. 这个新对象会被执行`[[proto]]`连接。  3. 这个新对象会绑定到函数调用的 `this`。  4. 如果函数没有返回其他对象，那么 `new` 表达式中的函数调用会自动返回这个新对象。  ##### 总结：关于 `this` 绑定的场景，遵循以下 `4` 条规则：  1. 由 `new` 调用? 绑定到新创建的对象。  2. 由`call`或者 `apply` 或者 `bind` 调用? 绑定到**指定的对象**。  3. 由上下文对象调用? 绑定到那个上下文对象。  4. 在严格模式下绑定到 `undefined`，否则绑定到**全局对象**。  ##### 拓展： ``` 绑定优先级：new 绑定 > 硬绑定 > 隐式绑定 > 默认绑定 ``` *本节参考：你不知道的 JavaScript（上卷）*   '},{title:"执行上下文",path:"/posts/Chapter1/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html",strippedContent:' ## 1. 理解 JavaScript 的执行上下文。  #### 什么是执行上下文？ 当函数执行时，会创建一个称为执行上下文的变量对象`可理解为作用域`。一个执行上下文定义了一个函数执行时的环境。  `执行上下文`也分为两种类型：  - **全局执行上下文：** 代码首次执行时候的默认环境，在代码的整个执行过程中，只用一个全局执行上下文。  - **函数执行上下文：** 每当执行流程进入到一个函数体内部的时候，就会创建一个函数执行上下文，`可以有任意数量的函数执行上下文`。  **执行上下文主要有两个阶段：** `创建阶段`和`执行阶段`。  **创建阶段：** - 首先，为每个函数或变量创建与外部环境的连接，这这个连接形成`作用域链`。`作用链`告诉执行上下文它应该包含什么，以及它应该在哪里查找解析函数的引用和变量的值。  - 扫描`作用链`后，将创建一个环境存储器，其中`全局上下文`、`变量`、`函数及函数参数`的创建和引用在内存中完成。  - 最后，在第一步中创建的每个执行上下文中确定 `this` 关键字的值。   **每个执行上下文包含了三个重要属性：`变量对象（VO）`、`作用域链`、`this`。**   创建阶段伪代码： ```js createContext = { // 创建阶段   \'outerEnvironmentConnection\': { // 创建外部连接         // 形成作用域链    },        \'variableObjectMapping\': {         // 变量、函数和函数参数的创建和引用在内存中完成。    },    \'valueOfThis\': {},  // 确定 this 的值 } ```  **执行阶段：**  `执行阶段`是代码在创建阶段形成的执行上下文中的运行的阶段，并且逐行分配变量值。  当执行开始时，JavaScript 引擎在其创建阶段形成的`AO对象`中查找执行函数的引用。如果在当前对象中没有找到，它将沿着作用域继续向上查找，直到它到达全局环境。  如果在全局环境中找不到函数引用，则将返回错误。  如果找到了引用并且函数正确执行，那么这个特定函数的执行上下文将从栈中弹出，接着 JavaScript 引擎将移动到下一个函数，它们的函数执行上下文将被加入到栈中并执行，以此类推。  下面结合代码来理解`两种执行上下文`的`两个阶段`：  ```js let name = "webinfoq"; var title = "execution context"; const message = "hello world";  function func1(num) {   var author = "deepak";   let value = 3;   let func2 = function multiply() {     return num * value;   }   const fixed = "Divine";   function addFive() {     return num + 5;   } } func1(10); ``` 因此`全局执行上下文`的`创建阶段`将如下所示： ```js globalExecutionContext = {  // 全局执行上下文     outerEnvironmentConnection: null,  // 全局上下文外部环境为 null     variableObjectMapping: {          name: uninitialized,  // 在创建阶段，let 声明的变量是未初始化状态         title: undefined,     // 在创建阶段，var 声明的变量表示为未定义         date: uninitialized,  // 在创建阶段，const 声明的变量是未初始化状态         func1: `<func1 reference>`,  // func1 地址引用     },     this: window // Global Object   } ``` 在`执行阶段`完成对变量的赋值等操作：  ```js globalExectutionContext = {  // 全局执行上下文     outerEnvironmentConnection: null, // 全部上下文外部环境为 null     variableObjectMapping: {         name: "webinfoq",         title: "execution context",         message: "hello world",         func1: pointer to function func1, // 指向 func1 的指针     },     this: window //Global Object } ```  当执行到 `func1` 时，将形成新的`函数执行上下文`，`创建阶段`如下所示： ```js func1ExecutionContext = {  // func1 函数执行上下文     outerEnvironmentConnection: Global,  // 外部环境为全局环境     variableObjectMapping: {        arguments: {             0: 10,             length: 1         },         num: 10,         author: undefined,  // var 声明的         value: uninitialized,  // let 声明的         func2: uninitialized,  // let 声明的         fixed: uninitialized,  // const 声明         addFive: `<addFive reference>`  // addFive 地址引用     },     this: Global Object or undefined   } ``` `执行阶段`如下所示： ```js func1ExecutionContext = {     outerEnvironmentConnection: Global,       variableObjectMapping: {        arguments: {  // 先处理 arguments 参数             0: 10,             length: 1         },         num: 10,         author: "deepak",  //变量赋值         val: 3,         func2: pointer to function func2()          fixed: "Divine"         addFive: pointer to function addFive()     },     this: Global Object or undefined } ``` **最后：**  Javascript 引擎创建执行上下文，调用栈。当有函数执行时，引擎就会创建一个新的函数执行上下文。最后所用函数执行完成后，将更新全局环境，然后全局代码完成，程序结束。   ## 2. 理解 JavaScript 执行上下文栈，可以应用堆栈信息快速定位问题。  通过阅读上一小节我们得知，每当有函数执行时，就会创建一个全新的`执行上下文`，那么怎么管理这些执行上下文呢？  JavaScript 引擎创建了**执行上下文栈** `Execution Context Stack` 来管理执行上下文。  可以把执行栈认为成一个储存函数调用的栈结构，遵循先进后出的原则。  下图为`执行上下文`入栈出栈示意图：  ![入栈出栈示意图](https://i.loli.net/2019/09/23/twsk5g6oaOBFEVq.gif)   **JavaScript 引擎是单线程执行，所有代码都是排队执行：**  - 一开始执行的是全局代码，首先创建`全局执行上下文`，然后将该执行上下文压入执行栈中。  - 当执行一个函数，就会创建该`函数执行上下文`，然后将其压入执行栈的顶部。  - 函数执行完成后，执行上下文从底部退出，等待垃圾回收。  **调用栈的应用：** ```js 你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。 另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具， 其中包含 JavaScript 调试器。 就本例来说，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger 语句。 运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。 因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 ```'},{title:"高阶函数",path:"/posts/Chapter1/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0.html",strippedContent:' ## 1. 熟练应用 `map`、`reduce`、`filter` 等高阶函数解决问题。  列举一些 `map`、`reduce`、`filter` 高频使用场景。  ### [map 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map) `map()` 方法返回一个新数组，其结果是该数组每个成员调用提供的函数后返回的新数组。 ```js var arr = [1, 2, 3, 4]; var newArr = arr.map(x => x * 2); console.log(newArr); // [2, 4, 6, 8] ```  ### map 方法使用场景：  ##### 1. 将字符串成员转换为数组项  ```js var str = "yuanyuan"; var arr = Array.prototype.call(str, x => x + ""); console.log(arr); //["y", "u", "a", "n", "y", "u", "a", "n"] ``` ##### 2. 在 React 中用来渲染列表数据 ```js const names = ["jser", "phper", "javaer", "pythener"]; const NamesList = () => (<ul>{names.map(name => <li key={name}> {name} </li>)}</ul>); const rootElement = document.getElementById("root"); ReactDOM.render(<NamesList />, rootElement); ```  ##### 3. 格式化数组对象 ```js const myUsers = [     { name: \'jser\', age: 18 },     { name: \'phper\', age: 19 },     { name: \'javaer\', age: 20 } ] const mapFormat = myUsers.map((item) => {     const result = [];     result[item.name] = item.age;     result.sex = "男";     return result; }) console.log(mapFormat); // [{ jser: 18, sex: "男" },{ phper: 19, sex: "男" },{ javaer: 20, sex: "男" }] ``` ### [reduce 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)  `reduce()` 方法对数组每个元素执行一个 `reduce` 函数，将其结果汇总为单个返回值。  ```js const array = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) => accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array.reduce(reducer));  // 10 ```  ### reduce 方法使用场景：  ##### 1. 对数组进行求和 ```js 参见上段代码 ``` ##### 2. 将二维数组转换为一维数组 ```js let array = [[1, 2], [3, 4], [5, 6]]; const reducer = (acc, cur) => acc.concat(cur); let result = array.reduce(reducer, [])   // 将 [] 作为回到函数第一个参数 console.log(result); //[1, 2, 3, 4, 5, 6] ```  ##### 3. 计算数组每个元素出现的次数 ```js let names = [\'jser\', \'jser\', \'javaer\', \'javaer\', \'phper\', \'pythener\'] let obj = {}; names.reduce((acc, cur) => {     acc[cur]? acc[cur]++ : acc[cur] = 1;     return acc; }, obj)   // 将 obj 作为回到函数第一个参数 obj  //解析： //第一次遍历：acc = {} cur = "jser" //第二次遍历：acc = {jser: 1} cur = "jser" //第三次遍历：acc = {jser: 2} cur = "javaer" //第四次遍历：acc = {jser: 2, javaer: 1} cur = "javaer" //第五次遍历：acc = {jser: 2, javaer: 2} cur = "phper" //第六次遍历：acc = {jser: 2, javaer: 2, phper: 1} cur = "pythener" //第七次退出：acc = {jser: 2, javaer: 2, phper: 1, pythen: 1}   console.log(obj) // {jser: 2, javaer: 2, phper: 1, pythen: 1}   ```  ### [filter 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)  `filter()` 方法创建一个新数组，其成员是通过提供函数测试的所有元素。 ```js const words = [\'spray\', \'limit\', \'elite\', \'exuberant\', \'destruction\', \'present\']; const result = words.filter(word => word.length > 6);  // 元素的长度大于6的通过测试 console.log(result); ["exuberant", "destruction", "present"] ``` ### filter 方法使用场景  ##### 1. 数组去重 ```js function unique(arr) {   return arr.filter((item, index, arr) => arr.indexOf(item) === index); } let arr = [1, 1, false, false, undefined, undefined, null, null]; unique(arr); // [1, false, undefined, null] ```   ## 5. `setInterval`需要注意的点，使用 `setTimeout` 实现 `setInterval`。  **setInterval 需要注意的点：**  - `setInterval` 第一个参数可以是一个函数签名也可以是一个被引号包裹的函数调用。     ```js     setInterval(engine, 1000);      //or     setInterval("engine()", 1000);     ```  - 第一个参数不能传递带参数的函数。     ```js      setInterval(function(args), 300)  // 报错     ```      - `setInterval` 如果不使用 `clearInterval` 停止，将会一直运行，即使第二次使用传入了不同的函数处理程序。  - `setInterval` 只能在方法外使用。   **使用 setTimerout 实现 setInterval：**  ```js // 递归调用 _setInterval(); function _setInterval() {     console.log(1);     let timer = setTimeout(() => {         _setInterval();         clearInterval(timer);     }, 1000) } ``` '},{title:"浏览器缓存",path:"/posts/Chapter5/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html",strippedContent:" # 彻底理解浏览器缓存机制  ## 概述  浏览器的缓存机制也就是我们说的 `HTTP` 缓存机制，其机制是根据 `HTTP` 报文的缓存标示进行的。  所以在分析浏览器缓存之前，我们先使用图文简单介绍一下 `HTTP` 报文，`HTTP` 报文分为两种：  - `HTTP` 请求（`Request`）报文。报文格式为：     1. **请求行**。     2. **`HTTP` 头**（通用信息头，请求头，实体头）。     3. **请求报文主体**（只有 `POST` 才有报文主体)。  ![请求报文](https://qiniu.mdnice.com/531b3efa6ddd37c8318f5f7cfed34931.png) ![请求报文主体](https://qiniu.mdnice.com/fa85fd3a79ee9989dae5f580ec39a941.png)  - `HTTP` 响应（`Response`）报文，报文格式为：     1. **状态行**。     2. `HTTP` 头（通用信息头，响应头，实体头）。     3. **响应报文主体**。  ![响应报文](https://qiniu.mdnice.com/0b5203c39d169ae326c715bd090674bd.png) ![响应报文主体](https://qiniu.mdnice.com/53513029f2fb2e561ad02e2d64a0c497.png)  ```js 注： 通用信息头指的是请求和响应报文都支持的头域，分别为：Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。 实体头则是实体信息的实体头域，分别为：Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。 这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。 ``` 以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。  ## 缓存过程分析 浏览器与服务器通信的方式为应答模式，即，浏览器发起 `HTTP` 请求 –> 服务器响应该请求。  那么浏览器第一次向服务器发起该请求后拿到请求结果，**会根据响应报文中 `HTTP` 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中**，简单的过程如下图：  ![第一次发起HTTP请求](https://qiniu.mdnice.com/e111df7e85e6afc415fc3c4494a6b0cd.png)  由上图我们可以知道：  - 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。 - 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。  以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。  为了方便大家理解，这里我们根据是否需要向服务器重新发起 `HTTP` 请求将缓存过程分为两个部分，分别是**强制缓存**和**协商缓存**。  ### 强制缓存 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种：  - 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：  ![强制缓存](https://qiniu.mdnice.com/21e4e59d92db2f9b2a23ed87d9de0a17.png)  - 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图：  ![强制缓存](https://qiniu.mdnice.com/f3177fb2e9ac086cbc65ebd351ba685d.png)  - 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图：  ![强制缓存](https://qiniu.mdnice.com/985df827046187a5d32d7dda76b5db48.png)  > 那么强制缓存的缓存规则是什么？  当浏览器向服务器发起请求时，服务器会将缓存规则放入 `HTTP` 响应报文的 `HTTP` 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中 `Cache-Control` 优先级比` Expires` 高。  #### Expires `Expires` 是 `HTTP/1.0` 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于`Expires` 的值时，直接使用缓存结果。  > `Expires` 是 `HTTP/1.0` 的字段，但是现在浏览器默认使用的是 `HTTP/1.1`，那么在 `HTTP/1.1` 中网页缓存还是否由 `Expires` 控制？  到了 `HTTP/1.1`，`Expire` 已经被 `Cache-Control` 替代，原因在于 `Expires` 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么 `Cache-Control` 又是如何控制的呢？  #### Cache-Control  在 `HTTP/1.1` 中，`Cache-Control` 是最重要的规则，主要用于控制网页缓存，主要取值为：  - `public`：所有内容都将被缓存（客户端和代理服务器都可缓存）。  - `private`：所有内容只有客户端可以缓存，`Cache-Control` 的默认取值。  - `no-cache`：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定。  - `no-store`：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。  - `max-age=xxx (xxx is numeric)`：缓存内容将在 `xxx` 秒后失效。  接下来，我们直接看一个例子，如下：  ![强制缓存](https://qiniu.mdnice.com/aed2f635e77f7b6c215655e214b9ae7f.png)  由上面的例子我们可以知道：  `HTTP` 响应报文中 `expires` 的时间值，是一个绝对值。  `HTTP` 响应报文中 `Cache-Control` 为 `max-age=600`，是相对值。  由于 `Cache-Control` 的优先级比 `expires`，那么直接根据 `Cache-Control` 的值进行缓存，意思就是说在 `600` 秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。  注：在无法确定客户端的时间是否与服务端的时间同步的情况下，`Cache-Control` 相比于 `expires` 是更好的选择，所以同时存在时，只有`Cache-Control` 生效。  了解强制缓存的过程后，我们拓展性的思考一下：  >浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？  ![强制缓存](https://qiniu.mdnice.com/9ef4986f8ec16aebebd6f1caefd55d5d.png)  这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的 `Size` 值则代表该缓存存放的位置，分别为 `from memory cache` 和 `from disk cache`。  那么 `from memory cache` 和 `from disk cache` 又分别代表的是什么呢？什么时候会使用 `from disk cache`，什么时候会使用`from memory cache` 呢？  `from memory cache` 代表使用内存中的缓存，`from disk cache` 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 `memory –> disk`。  虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析： 1. 访问 `https://heyingye.github.io/` –> `200` 2. 关闭博客的标签页 –> 重新打开 `https://heyingye.github.io/` –> `200 (from disk cache)` 3. 刷新 –> `200(from memory cache)`  > 看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着 from disk cache 和 from memory cache 吗？  对于这个问题，我们需要了解内存缓存（`from memory cache`）和硬盘缓存（`from disk cache`），如下:  - 内存缓存(`from memory cache`)：内存缓存具有两个特点，分别是**快速读取**和**时效性**：      - **快速读取**：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。      - **时效性**：一旦该进程关闭，则该进程的内存则会清空。  - 硬盘缓存（`from disk cache`）：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 `I/O` 操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。  在浏览器中，浏览器会在 `js` 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取；而 `css` 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存。   ### 协商缓存  **协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程**。  主要有以下两种情况：  - 协商缓存生效，返回 `304`，如下：      ![协商缓存](https://qiniu.mdnice.com/50e14b0a28494997d560d5395f3d6dae.png)  - 协商缓存失效，返回 `200` 和请求结果结果，如下：      ![协商缓存](https://qiniu.mdnice.com/49c53e602efbf8040a27b846bd923aea.png)  同样，协商缓存的标识也是在响应报文的 `HTTP` 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有： - `Last-Modified / If-Modified-Since`. - `Etag / If-None-Match`.  其中 `Etag / If-None-Match` 的优先级比 `Last-Modified / If-Modified-Since` 高。  #### Last-Modified / If-Modified-Since  - `Last-Modified` 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下：      ![协商缓存](https://qiniu.mdnice.com/b883a3df793d3d330644b7351243a5e6.png)  - `If-Modified-Since` 则是客户端再次发起该请求时，携带上次请求返回的 `Last-Modified` 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 `If-Modified-Since` 字段，则会根据 `If-Modified-Since` 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 `If-Modified-Since` 的字段值，则重新返回资源，状态码为 `200`；否则则返回 `304`，代表资源无更新，可继续使用缓存文件，如下：      ![协商缓存](https://qiniu.mdnice.com/af737ad0211018faf7bb0dfbd47ff2d2.png)  #### Etag / If-None-Match  - `Etag` 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下：      ![协商缓存](https://qiniu.mdnice.com/a2a5ca7092f9d9ceb435317126fe112f.png)  - `If-None-Match` 是客户端再次发起该请求时，携带上次请求返回的唯一标识 `Etag` 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 `If-None-Match`，则会根据 `If-None-Match` 的字段值与该资源在服务器的 `Etag`值做对比，一致则返回 `304`，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 `200`，如下：      ![协商缓存](https://qiniu.mdnice.com/03ccaf19197565f16c59c81910d2f0ca.png)  注：`Etag / If-None-Match` 优先级高于 `Last-Modified / If-Modified-Since`，同时存在则只有 `Etag / If-None-Match` 生效。  ### 总结  强制缓存优先于协商缓存进行，若强制缓存 `Expires` 和 `Cache-Control` 生效则直接使用缓存，若不生效则进行协商缓存（`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`）。  协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回    `304`，继续使用缓存，主要过程如下：   ![HTTP 缓存](https://qiniu.mdnice.com/3e3cc0154d1a038b7caec00c50def728.png)  以上便是浏览器缓存的过程，若有错误之处，敬请指正。  "},{title:"HTML汇总",path:"/posts/Chapter2/html.html",strippedContent:' ## 1. 从规范的角度理解 HTML，从分类和语义的角度使用标签。  ## 2. 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式。  ## 3. 元信息类标签（head、title、meta）的使用目的和配置方法。  ## 4. HTML5 离线缓存原理。  使用 `HTML5` 通过创建 `cache manifest` 文件，可以轻松地创建 web 应用的离线版本。  ### 什么是应用程序缓存（Application Cache）？  `HTML5` 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。  **应用程序缓存为应用带来三个优势：**  - 离线浏览 - 用户可在应用离线时使用它们。 - 速度 - 已缓存资源加载得更快。 - 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。    ### Cache Manifest 基础  如需启用应用程序缓存，请在文档的 `<html>` 标签中包含 `manifest` 属性：  ```html <!DOCTYPE HTML> <html manifest="demo.appcache"> ... </html> ``` 每个指定了 `manifest` 的页面在用户对其访问时都会被缓存。如果未指定 `manifest` 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。  **manifest 文件的建议的文件扩展名是：`.appcache`。**  ***请注意，`manifest` 文件需要配置正确的 `MIME-type`，即 `"text/cache-manifest"`。必须在 web 服务器上进行配置。***   ### Manifest 文件  `manifest` 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）它分为三个部分：  - **CACHE MANIFEST** - 在此标题下列出的文件将在首次下载后进行缓存。  - **NETWORK** - 在此标题下列出的文件需要与服务器的连接，且不会被缓存。  - **FALLBACK** - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）。  #### CACHE MANIFEST 第一行 `CACHE MANIFEST`，是必需的。  ``` CACHE MANIFEST /theme.css /logo.gif /main.js ``` 无论用户何时与因特网断开连接，`CACHE MANIFEST` 下列出的资源依然是可用的。  #### NETWORK 下面的 `NETWORK` 字段规定文件 `login.php` 永远不会被缓存，且离线时是不可用的。  ``` NETWORK: login.php ``` 可以使用星号来指示所有其他资源/文件都需要因特网连接。 ``` NETWORK: * ``` #### FALLBACK  下面的 `FALLBACK` 字段规定如果无法建立因特网连接，则用 `offline.html` 替代 `/html5/` 目录中的所有文件。  ``` FALLBACK: /html/ /offline.html ``` ***注意: 第一个 URI 是资源，第二个是替补。***  #### 完整的 Manifest 文件 ```appcache CACHE MANIFEST # 2012-02-21 v1.0.0  /theme.css /logo.gif /main.js  NETWORK: login.php  FALLBACK: /html/ /offline.html ```  ***注意：浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。***  参考：[https://www.runoob.com/html/html5-app-cache.html](https://www.runoob.com/html/html5-app-cache.html)  ## 5. 可以使用 Canvas API、SVG 等绘制高性能的动画。 '},{title:"BFC 实现原理",path:"/posts/Chapter2/bfc.html",strippedContent:' ## BFC 实现原理，可以解决的问题，如何创建 BFC。  **BFC** 即 `Block Formatting Contexts`（块级格式上下文），它的布局模式为`流动模型`，是一个独立的渲染区域。 `BFC` 决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。  **具有 `BFC` 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。**  ### BFC 的生成  - `body` 根元素。 - `float` 的值不为 `none`。 - `overflow` 的值不为 `visible`。 - `display`的值为`inline-block`、`table-cell`、`table-caption`。 - `position` 的值为 `absolute`、`fiexd`。  ### BFC 解决的问题  #### 1. 阻止 margin 重叠（margin 塌陷问题）  在标准文档流中，块级元素之间竖直方向的 `margin` 会以大的为准，这就会导致 `margin` 重叠（塌陷）问题。  ```html <body>     <p></p>     <p></p> </body> <style>     p {         width: 100px;         height: 100px;         background: rgb(19, 149, 192);         margin: 50px;     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/2e633e8c5ac02c1678493bb5a2bec7bb.png">  **解决 margin 塌陷问题：将其放在不同的 `BFC` 容器中来解决，设置 `overflow: hidden;`。**  ```html <body>     <div>         <p></p>     </div>     <p></p> </body> <style>     div {         overflow: hidden;     }     p {         width: 100px;         height: 100px;         background: rgb(19, 149, 192);         margin: 50px;     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/5096d81caa2cc88fc31c09a13ce8e1c7.png">   #### 2. 高度塌陷问题  在通常情况下，父元素的高度会被子元素撑开，而将其子元素设置为浮动元素时，子元素就会脱离文档流，父元素就会发生高度塌陷问题，上下边界重回。  ```html <div style="border: 1px solid #333;">     <div class="child"></div> </div> <style>       div.child {         float: left;         width: 100px;         height: 100px;         background: rgb(19, 149, 192);     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/17fa72870ee407c086d9e2e6c35e31e9.png">  **解决高度塌陷问题：设置 `overflow: hidden;` 将父元素变成 BFC 容器。**  ```js BFC约束准则：计算 BFC 容器的高度时，浮动元素也参与计算。 ``` ```html <div style="border: 1px solid #333; overflow: hidden;">     <div class="child"></div> </div> <style>       div.child {         float: left;         width: 100px;         height: 100px;         background: rgb(19, 149, 192);     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/dd9bdf163c040175aa5beb718ae9466b.png">  #### 3. 阻止元素被浮动元素覆盖  由于左侧块级元素发生了浮动脱离了文档流，和右侧未发生浮动的块级元素不在同一层内，所以会发生 `div` 遮挡问题。  ```html <div class="contanier">     <div>左浮动的元素</div>     <div>没有触发 BFC 的元素</div> </div> <style>     .contanier div:nth-child(1) {         float: left;         height: 100px;         width: 100px;         background: rgb(27, 178, 228);     }     .contanier div:nth-child(2) {         width: 200px;          height: 200px;         background: rgb(248, 234, 172);     } </style> ```  <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/f12e54cdeafe5eeedfe1fa3d67683109.png">  **解决元素被这遮挡问题：给右侧元素设置 `overflow: hidden;` 触发 `BFC` 来解决。**  ```js BFC 约束准则：BFC 的区域不会与浮动的元素区域重叠。 ``` ```html <div class="contanier">     <div>左浮动的元素</div>     <div>触发 BFC 的元素</div> </div> <style>     .contanier div:nth-child(1) {         float: left;         height: 100px;         width: 100px;         background: rgb(27, 178, 228);     }     .contanier div:nth-child(2) {         width: 200px;          height: 200px;         overflow: hidden;         background: rgb(248, 234, 172);     } </style> ``` <img alt="bfc" width="60%" src="http://qiniu.mdnice.com/47d7e0fb31a734bb5bee749cc75ad50c.png">  ### 总结  ```js 1. 内部的块元素会在垂直方向上一个接一个的放置。 2. 属于同一个 BFC 的两个相邻块元素的 margin 会发生重叠（重叠）。 3. 计算BFC的高度时，浮动子元素也参与计算。（解决高度塌陷问题）。 4. BFC 容器不会与 float 的元素区域重叠。（解决浮动元素遮挡问题）。 5. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。 ``` '},{title:"Vue组件通信",path:"/posts/Chapter6/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",strippedContent:' ## Vue 组件间通信方法汇总  ### 父组件向子组件传值   #### 1. 通过属性传值 props   `props` 可以是数组或对象，用于接收来自父组件的数据。  ```js // 父组件 List.vue <template>   <div>     <List-item :str="str" :obj="obj" :arr="arr"></List-item>   </div> </template> <script> import ListItem from "./ListItem"; export default {   data() {     return {       str: "给子组件传值",       obj: {msg: "给子组件传值"},       arr: [1, 2, 3]     }   },   components: {     ListItem   } } <\/script>  // 子组件 ListItem.vue <template>   <div>     <div>{{msg}}</div>     <div>{{obj}}</div>     <div>{{arr}}</div>   </div> </template> <script> export default {   props: {     msg: String, // props是字符串     obj: Object, // props是对象     arr: Array   // props是数组   } } <\/script> ``` **子组件渲染结果：**  ![父子组件通信](http://qiniu.mdnice.com/7ad4bf7bc983458d7a903befd7a33fe6.png)   #### 2. 使用修饰符 `.sync`  修饰符 [.sync](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6) 是 `2.3.0+` 新增，它对 `props` 起到了一种修饰的作用，使用 `.sync` 进行修饰的 `props` 意味子组件有修改它的意图，这种情况下它只起到一个标注性作用，有它没它都不会影响逻辑（后文会介绍使用 .sync 的其他作用）。  使用 `.sync` 修改上边的代码：  ```js // 父组件 List.vue <template>   \x3c!-- 这里不写 .sync 也不会影响结果 --\x3e   <List-item :title.sync="title" @update:title="updataTitle"></List-item> </template> <script> import ListItem from "./ListItem"; export default {   data() {     return {       title: "我是title",     }   },   components: {     ListItem   },   methods: {    updataTitle(res) {     this.title = res;    }   } } <\/script>  // 子组件 ListItem.vue <template>   <div>     <button @click="handleClick">Click me</button>     <div>{{title}}</div>   </div> </template> <script> export default {   props: {     title: String,    },   methods: {    handleClick() {     // 子组件向父组件传值     this.$emit(\'update:title\', \'我要父组件更新 title\');    }   } } <\/script> ```  <img width="30%" src="https://i.loli.net/2019/10/24/wi87HNTJLsDdOIf.png" alt="props"> <img width="50%" src="http://qiniu.mdnice.com/78ce8a9205e20962af4300138ce62b24.png" alt="props">   **使用`.sync` 向子组件传递 多个props：**  当我们用一个对象同时设置多个 `prop` 的时候，也可以将这个 `.sync` 修饰符和 `v-bind` 配合使用： ```js <text-document v-bind.sync="doc"></text-document> ```  这样会把 `doc` 对象中的每一个属性 (如 title) 都作为一个独立的 `prop` 传进去，然后各自添加用于更新的 `v-on 监听器。  更多介绍，[.sync](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6) 。  #### 3. 通过 $parent 获取父组件实例的方法或者属性  这种方式，从严格意思上讲不是值的传递，而是一种"取"（不推荐直接通过实例进行值的获取）。  可以通过 Vue 的[实例属性](https://cn.vuejs.org/v2/api/#vm-parent) `$parent` 获得父组件的实例，借助实例可以调用父实例中的方法，或者获取父实例上的属性，从而达到取值的目的。   <img width="80%" src="http://qiniu.mdnice.com/103331d17ba700350a5e60a48773b837.jpeg" alt="$parent">  ```js // 父组件 List.vue ... <script> export default {   data() {     return {       message: "hello children",       msg: "hello"     }   },   methods: {     sendMessage() {       return this.message;     }   } } <\/script>  // 子组件 ListItem.vue <template>   <div>     <div>{{data}}</div>     <div>{{msg}}</div>   </div> </template> <script> export default {   data() {     return {       data: "",       msg: ""     }   },   mounted() {     this.data = this.$parent.sendMessage(); // 调用父实例中的方法     this.msg = this.$parent.msg; // 获取父实例中的属性   } } <\/script> ``` **拓展**  子组件调用父组件中的方法：  - 通过 `$parent` 获取父实例 `this.$parent.event`。  - 通过 通过 `props` 传递方法。  - 通过 `$emit` 监听父组件中的方法 `this.$emit("envnt")`。   ### 子组件向父组件传值   #### 1. 通过事件传值 $emit  - 子组件使用 `$emit` 发送一个自定义事件，事件名称是一个字符串。 - 父组件使用指令 `v-on` 绑定子组件发送的自定义事件。  ```js // 父组件 List.vue <template>   <div>     \x3c!-- 监听自定义事件 --\x3e     <List-item v-on:welcome="getWelcome"></List-item>   </div> </template> <script> import ListItem from "./List-item"; export default {   components: {     ListItem   },   methods: {     getWelcome(data) {       alert(data)     }   } } <\/script>  // 子组件 ListItem.vue <template>   <button @click="handleClick">Click me</button> </template> <script> export default {   methods: {     handleClick() {    // 使用 $emit 发送自定义事件 welcome       this.$emit(\'welcome\', \'hello\');     }   } } <\/script> ```  ![image](http://qiniu.mdnice.com/66401cecb6a809c6c5527c855c4f45f9.png)  #### 2. 通过 $children 获取子组件实例  此方式同 `$parent`，这里就不进行介绍了。  #### 3. 通过 ref 注册子组件引用  尽管存在 `prop` 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，可以通过 `ref` 特性为这个子组件赋予一个 ID 引用。  ```js <template>   <div>     <List-item ref="item" :title="title"></List-item>     <div>{{data}}</div>   </div> </template> <script> import ListItem from "./List-item"; export default {   data() {     return {       title: "我是title",       data: ""     }   },   components: {     ListItem   },   mounted() {     this.data = this.$refs.item.message;   } } <\/script> ``` [更多 ref 用法](https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0)。  ### 兄弟组件传值  #### 1. Bus 中央事件总线  非父子组件传值，可以使用一个空的 Vue 实例作为中央事件总线，结合[实例方法](https://cn.vuejs.org/v2/api/?#vm-on) `$on` 和 `$emit` 完成传值操作。  **Bus 的定义方式有以下三种：**  1. 将 `Bus` 抽离出来，组件有需要时进行引入。     ```js     // Bus.js     import Vue from \'vue\'     const Bus = new Vue()     export default Bus     ``` 2. 将 `Bus` 挂载到 Vue 根实例的原型上。     ```js     import Vue from \'vue\'     Vue.prototype.$bus = new Vue();     ``` 3. 将 `Bus` 注入到 Vue 根对象上。     ```js     import Vue from \'vue\'     const Bus = new Vue()     new Vue({       el:\'#app\',       data: {         Bus       }　　     })     ```  **下面案例中的 `Bus` 挂载在 Vue 原型上：**  ```js // 组件1 使用 $emit 向外部发布自定义事件 <template>   <button @click="handleClick"> Send Message</button> </template> <script> export default {   data() {     return {       message: "给兄弟组件传值",     }   },   methods: {     handleClick() {       this.$Bus.$emit("sendMessage", this.message)     }   } } <\/script>  // 组件2 使用 $on 订阅外部发布的事件 <template>   <div>     {{data}}   </div> </template> <script> export default {   data() {     return {       data: "",     }   },   mounted() {     this.$Bus.$on("sendMessage", data => {       this.data = data;     })   } } <\/script> ``` **注意：注册的 `Bus` 要在组件销毁时卸载，否则会多次挂载，造成触发一次但多个响应的情况。** ```js beforeDestroy () {   this.$Bus.$off(\'sendMessage\', this.message); } ``` #### 2. Vuex 状态管理器  Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。  <img src="https://vuex.vuejs.org/vuex.png" alt="vuex"/>  Vuex 的[具体使用](https://vuex.vuejs.org/zh/)。   #### 3. 通过父组件进行过渡  *不是方法的方法：*  1. 子组件 `A` 通过事件 `$emit` 传值传给父组件。  2. 父组件通过属性 `props` 传值给子组件 `B`。  ### 深层次嵌套组件传值  #### 1. 依赖注入 provide/inject  `provide` 选项允许我们指定我们想要提供给后代组件的数据/方法。  ```js provide: function () {   return {     getMap: this.getMap   } } ```  然后在任何后代组件里，我们都可以使用 `inject` 选项来接收指定的我们想要添加在这个实例上的属性：  ```js inject: [\'getMap\'] ```  ***`provide` 和 `inject` 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。***  ```js // 父级组件提供 \'foo\' var Provider = {   provide: {     foo: \'bar\'   },   // ... }  // 子组件注入 \'foo\' var Child = {   inject: [\'foo\'],   created () {     console.log(this.foo) // => "bar"   }   // ... } ```  >然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root 做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。  ---  #### 2. $attrs/inheritAttrs  这个两个属性是 `2.4` 新增的特性。  **$attrs：**   **官网介绍的很累赘，可以理解为非 `props` 属性集合。**[更多介绍](https://cn.vuejs.org/v2/api/?#inheritAttrs)。  当一个组件中没有声明任何 prop 时，`this.$attrs` 可以获取到所有父作用域的属性绑定 (class 和 style 除外)，并且可以通过 `v-bind="$attrs"` 传给其内部组件 —— 在创建高级别的组件时非常有用。  **inheritAttrs：**   控制元素属性是否显示在 dom 上，默认值为 `true`。  >默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。   **祖先组件：** ```html <template>   <div>     <List-item :title="title" :message="message"></List-item>   </div> </template> <script> import ListItem from "./List-item"; export default {   data() {     return {       title: "我是title",       message: "传给后代"     }   },   components: {     ListItem   } } <\/script> ```  **父组件：** ```html <template>   <div>     <h1>{{title}}</h1>     <h2>{{$attrs.message}}</h2>     \x3c!-- 通过 v-bind="$attrs" 传入后代组件--\x3e     <ListItem2 v-bind=\'$attrs\'></ListItem2>   </div> </template> <script> import ListItem2 from \'./List-item2\' export default {   props: {     title: String   },   components: {     ListItem2   },   // 默认为 true，如果传入的属性子组件没有 prop 接受，就会以字符串的形式作为标签的属性存在 <div message="传给后代"></div>   // 设为 false，在 dom 中就看不到这些属性 <div>...</div>   inheritAttrs: false } <\/script> ```  **后代组件：** ```html <template>   <div>     {{$attrs.message}}   </div> </template> <script> export default {   mounted() {     console.log(this.$attrs)\t// {message: "传给后代"}   } } <\/script> ``` **渲染出来的结果为：**  <img width="50%" src="http://qiniu.mdnice.com/c78bfa9a349c4b3f46096b878e0fb129.png" alt="$attrs/inheritAttrs">  ### 插槽 slot 与子组件传值  在实际项目中确实有遇到插槽 *`后备内容`* 动态显示的情况，所以这里要补充一下插槽 *`后备内容`* 是如何与子组件进行通信的。  **插槽后备内容是指：写在父组件中，包含在子组件标签里的，与子组件中的 `slot` 对应。**  ```html <template>   <child-component>     我是插槽的后备内容   </child-component> </template> ```  比如这里有一个含有 `slot` 的 `current-user` 组件，它的模版结构是这样的： ```html \x3c!-- 子组件 current-user.vue --\x3e <template>   <div>     <div>current-user组件</div>     <slot>插槽里默认显示：{{user.firstName}}</slot>   </div> </template>  <script> export default {   data() {     return {       user: {         firstName: "zhao",         lastName: "xinglei"       }     }   } } <\/script> ``` 它的父组件是这样的：  ```html \x3c!-- 父组件 Users.vue --\x3e <template>   <div>     <div>我是Users组件</div>     <current-user>       我是插槽里的后备内容： {{user.lastName}}（我想显示为子组件中 user.lastName ）     </current-user>   </div> </template>  <script> import CurrentUser from \'./Current-User.vue\' export default {   components: {     CurrentUser   } } <\/script> ```  我们看到，在父组件 `Users` 中，为子组件 `current-user` 提供的后备内容中，想要显示子组件定义的 `user.firstName` 是不能做到的。  官网中提供一个指令 [v-slot](https://cn.vuejs.org/v2/guide/components-slots.html)，它与 `props` 结合使用从而达到插槽后备内容与子组件通信的目的。  我们首先需要在子组件的 `slot` 中传递一个 `props`（这个`props` 叫做插槽props），这里我们起名叫 `user`：  ```html \x3c!-- 子组件 current-user.vue --\x3e <template>   <div>     <div>current-user组件</div>     <slot :user="user">       插槽里默认显示：{{user.firstName}}     </slot>   </div> </template> ```  在父组件中，包含插槽后备内容的子组件标签上我们绑定一个 `v-slot` 指令，像这样： ```html <template>   <div>     <div>我是Users组件</div>     \x3c!-- slotProps里的内容就是子组件传递过来的 props --\x3e     \x3c!-- "user": { "firstName": "zhao", "lastName": "xinglei" } --\x3e     <current-user v-slot="slotProps">       {{slotProps}}     </current-user>   </div> </template> ```  最后渲染出来的结果为：  ![作用域插槽](https://qiniu.mdnice.com/19b47dbffd18c928ec122eef6f46f099.png)  官网给这种插槽起名叫做`作用域插槽`，[更多了解](https://cn.vuejs.org/v2/guide/components-slots.html)。     ### 总结  ```js 1. 组件之间传值无非就是通过属性、事件和操作 Vue 实例进行的。 2. 操作实例进行组件件通信，实例属性 $root、$parent、$children 分别对应了根实例、父实例、子实例。 3  ref 子组件引用，在操作表单元素时会应用的到。 4. Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，简单的应用不要使用 Vuex。 5. Vue.observable() 让一个对象可响应，可以作为最小化的跨组件状态存储器（本文未提到）。 ```  '},{title:"CSS盒模型",path:"/posts/Chapter2/css%E7%9B%92%E6%A8%A1%E5%9E%8B.html",strippedContent:" ## CSS 盒模型，在不同浏览器下的差异。  ### 标准盒模型和怪异盒模型  - **标准盒模型**：宽度只是内容（content）的宽度。      ![1265396-20171119143703656-1332857321.png](https://i.loli.net/2019/09/30/D7Wl59TfMQcdmwG.png)  - **怪异（IE）盒模型**：宽度是内容（content）+ 填充（padding）+ 边框（border）的总宽度。      ![1265396-20171119144229156-49945808.png](https://i.loli.net/2019/09/30/imUEr4skWPlI2dF.png)  ### 设置盒模型 使用 CSS3 新增的属性 `box-sizing` 可以模拟标准盒模型和怪异盒模型。  - **content-box**：默认值，标准盒模型。      ```css     /* 标准模型 */     box-sizing: content-box;     ``` - **border-box**：IE 盒子模型。      ```css     /* IE 盒模型 */     box-sizing: border-box;     ``` - **padding-box**：`padding` 计算入 `width` 内。  ### 注意 ```js ie8+ chrome 浏览器支持 content-box 和 border-box 属性。 Firfox （2-49）支持 padding-box 属性。 IE 浏览器在 getComputedStyle 得到的 width/height 是按照标准模式计算的，而不论 box-sizing 的取值。 ``` "},{title:"CSS伪类和伪元素",path:"/posts/Chapter2/css%E4%BC%AA%E7%B1%BB.html",strippedContent:' ## CSS 伪类和伪元素有哪些，它们的区别和实际应用。  ### CSS 伪类  CSS 伪元素是用来对一些选择器添加特殊效果。  - **:link**：     用于设置未被访问的链接的样式。  - **:visited**：  用于设置已经被访问的链接的样式。  - **:hover**：    用于设置将鼠标悬浮在链接上的样式。  - **:active**：   用于设置鼠标点击链接时到鼠标松开时的样式。  - **:focus**：    用于设置用键盘将焦点放在链接上时的样式（如用tab键或者上下键来移动页面焦点时）。   - **:first-child**：选中列表中的第一个元素。  - **:last-child**：选中列表中的最后一个元素。  - **:nth-child()**：括号里面的取值可以为三类。 \t```js     1. 数字： :nth-child(3) 表示选中父元素的第三个子元素。 \t2. 自变量为 n 的表达式： :nth-child(3n) 代表选中父元素的第3 6 9 .. 3n 的子元素。 \t3. even 或者 odd： 分别代表选中父元素的奇数或者偶数个子元素。     ``` - **:nth-last-child()**：与 `:nth-child()` 的不同点在于，这个是从最后一个元素开始计算，取值都是一样的。   - **:not(name)**：除了 `name` 以外的元素。  ####CSS 伪元素  CSS 伪元素是用来对一些选择器添加特殊效果。  *CSS 伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称为伪元素。*  <img width="60%" alt="css伪元素" src="http://qiniu.mdnice.com/50ff5d10c5a8a83731a2fb8638171a09.png">  1. **::first-letter**：用于向文本的首字母设置特殊样式。  2. **::first-line**：用于向文本的首行设置特殊样式。  3. **::before**：可以向元素内容的前面插入新内容。  4. **::after**：可以向元素内容的后面插入新内容。  5. **::selection**  6. **::placeholder**  7. **::backdrop**   ### 伪类和伪元素的区别  1. 为了避免混淆，`css3` 中的标准规定伪类使用单冒号 `:` ，伪元素使用双冒号 `::`，为了保证兼容伪元素两种使用方法都是可以的。  2. 伪类可以叠加使用，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。     ```css     .content:first-child:hover { color: #fff;}   //使用伪类     .content:first-letter { color: #fff;}   //使用伪元素     .conrent:first-letter:hover { color: #fff;}   //错误写法      ```  3. 伪类和类的优先级相同，伪元素和元素的优先级相同。   '},{title:"CSS汇总",path:"/posts/Chapter2/",strippedContent:' ## 1. HTML 文档流的排版规则，CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理。  ### 文档流的排版规则  元素默认从左向右、从上到下进行排列。  标准文章流分为：**块级元素**和**行内元素**。  **块级元素：**独占一行，水平方向不能与其他元素并排显示，可设置宽、高，宽度默认为父级的100%。 **行内元素：**    ## 2. 可使用 CSS 函数复用代码，实现特殊效果。  #### CSS 中的函数： | 函数  | 描述 | CSS 版本 | |----- |-----|-----| |attr()|  返回选择元素的属性值 |  2  |calc()|  允许计算 CSS 的属性值（比如动态计算长度值）| 3 |linear-gradient()| 创建一个线性渐变的图像|  3 |radial-gradient()| 用径向渐变创建图像|  3 |repeating-linear-gradient()  |用重复的线性渐变创建图像|  3 |repeating-radial-gradient()  |类似 radial-gradient()，用重复的径向渐变创建图像| 3   ## 3. PostCSS、Sass、Less 的异同，以及使用配置，至少掌握一种。  https://blog.csdn.net/JoeBlackzqq/article/details/98885880  ## 4. CSS 模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染。  ### 如何防止 CSS 阻塞渲染  通过**媒体类型**和**媒体查询**，设置 `link` 标签的 `media` 属性值，根据特定场景（设备类型、显示、打印、屏幕方向变化、屏幕分辨率等）按需渲染 CSS 资源。  ```html \x3c!-- 屏幕分辨率为 800px 时，渲染 style.css --\x3e <link href="style.css" rel="stylesheet" media="(min-width: 800px)">  \x3c!-- 打印网页或者在打印预览模式下打开时，渲染 print.css  --\x3e <link rel="stylesheet" type="text/css" href="print.css" media="print"/>  \x3c!-- 手持设备（小屏幕、有限带宽）设备时，渲染 handheld.css  --\x3e <link rel="stylesheet" type="text/css" href="handheld.css" media="handheld"/> ``` **注意：**无论哪一种情况，浏览器仍会下载全部 CSS 资源，只不过将不阻塞渲染资源的优先级降低罢了。    ## 5. 熟练使用 CSS 实现常见动画，如渐变、移动、旋转、缩放等等。   ## 6. CSS 浏览器兼容性写法，了解不同 API 在不同浏览器下的兼容性情况。   ## 7. 掌握一套完整的响应式布局方案。   '},{title:"水平垂直居中方案",path:"/posts/Chapter2/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html",strippedContent:' ## 元素水平垂直居中的方案、可以实现 6 种以上并对比它们的优缺点。  <img alt="元素居中" width="30%" src="http://qiniu.mdnice.com/164c36b8b16a017a344a634667b05eb8.png">  ### 1. 绝对定位 transform 变形 （不定宽高）  *IE8 不支持*  采用 `transform: translate(-50%, -50%)` ，父元素设置相对定位 `position: relative`。  ```css body {     position: relative; } div {     position: absolute;     left: 50%;     top: 50%;     transform: translate(-50%, -50%);     background: red; } ```   ### 2. 弹性盒模型 （不定宽高）  *兼容性不好，主要应用与移动端*  当前 `div` 父级设置 `display: flex; align-items: center; justify-content: center;` 。  ```css body {     display: flex;     align-items: center;     justify-content: center; } div {     background: red; } ```  ### 3. table-cell 单元格布局（不定宽高）  *不常用*  此方法是`内联块状元素`水平垂直剧中的解决方案。  将父元素设置 `dispaly: table-cell;` 转换成表格单元格。  ```css  body {     display: table-cell;     vertical-align: middle;     text-align: center;     width: 400px;     height: 400px;     border:1px solid #666; } div {     dispaly: inline-block;     background: red; } ```  ### 4. 绝对定位 margin 负间距（定宽高）  *比较流行的解决方案*  将 `margin-left` 和 `margin-top` 的值为当前 `div` 宽度的一半的负值。  ```css div {     width: 100px;     height: 100px;     position: absolute;     left: 50%;     top: 50%;     margin-left: -50px;     margin-top: -50px;     background: red; } ``` ### 5. 绝对定位 margin：auto（定宽高）  *不确定宽高时，会充满整个屏幕。*  设置绝对定位属性 `position: absolute`， `left`、`top`、`right`、`bottom` 值均为 `0`， `margin` 值为 `auto`。  ```css div {     width: 100px;     height: 100px;     position: absolute;     left: 0;     top: 0;     right: 0;     bottom: 0;     margin: auto;     background: red; } ```  ### 6. 绝对定位 和 salc() （定宽高）  *IE 8 不支持*  `calc()` 函数动态计算实现水平垂直剧中。  ```css body {     position: relative;     width: 100%;     height: 100%; } div {     position: absolute;     width: 200px;     height: 50px;     left: calc((100% - 200px)/2);     top: calc((100% - 50px)/2);     background: red; }　　 ```  ### 总结 ```js 不宽高： 1. absolute + transform 变形 2. flex 布局  3. table-cell 布局 （不常用）  定宽高： 1. absolute + margin 负间距离 （常用） 2. absolute + margin auto 3. absolute + calc() 函数 ``` '},{title:"CSS选择器",path:"/posts/Chapter2/css%E9%80%89%E6%8B%A9%E5%99%A8.html",strippedContent:' ## CSS 所有选择器及其优先级、使用场景，哪些可以继承，如何运用 @ 规则。  ### CSS 选择器优先级及使用场景  1. 在属性后面使用 `!important`， 权重最高。  2. 内联样式，如 `style=""`，权重 `1000`。  3. `id` 选择器，如 `#header`，权重 `100`。  4. 类、伪类、属性选择器，如 `.header div:last-child input[type="text"]`，权重 `10`。(伪类使用 `:`)  5. 元素、伪元素选择器，如 `div p ::before`，权重 `1`。(伪元素使用`::`)     6. 通配符、子选择器、相邻选择器，如 `*、>、+`，权重 `0`。     7. 继承的样式、浏览器默认的属性，没有权重。   |选择器\t|权重 |----|---- |!important|\t1/0(无穷大) |内联样式|\t1000 |ID|\t100 |类/伪类/属性\t|10 |元素/伪元素|\t1 |通配符/子选择器/相邻选择器|\t0   ```js !important > 内联样式 > ID 选择器 > 类选择器 > 元素选择器 > 通配符（*）选择器 > 浏览器默认属性 ``` ### 继承性  1. 以 `color`、`font-`、`text-`、`line` 开头属性可继承。  2. 只要是后代就可继承。  3. `<a>` 标签文字颜色和下划线无法继承。  4. `<h>` 标签的文字大小无法继承。  ### at 规则介绍  `at`规则由一个 `@` 关键字和后续的一个区块组成，如果没有区块，则以分号结束。  #### @charset  用于提示 `css` 文件使用的字符串编码方式，它如果被使用，必须出现在最前面。  这个规则只是在给出语法解析阶段前使用，并不影响页面上展示效果。  ```css @charset "utf-8" ``` #### @import  用于引入一个 `css` 文件，除 `@charset` 规则不会被引入外，可以引入一个文件的全部内容。  ```css @import "style.css"; @import url("style.css"); ``` #### @ media  对设备类型进行判断，用于媒体查询。  ```css @media screen and (max-width: 600px) {     body {         background: blue;     } } ``` #### @keyframes  `@keyframes` 规则用于定义动画关键帧。创建动画的原理是：将一套 `CSS` 样式逐渐变化为另一套样式。  ```css @keyframes .move {     from: { top: 0px; }     to: { top: 20px; } } ```  #### @fontace `@fontace` 用于定义字体，`iconfont` 技术就是利用这个特性来实现。 ```css @font-face{ \tfont-family: myFirstFont;     src: url(\'Sansation_Light.ttf\')          ,url(\'Sansation_Light.eot\'); /* IE9 */ } div { \tfont-family: myFirstFont; } ```  ####  其他 - **@page**：用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。  - **@counter-style**： 产生一种数据，用于定义列表项的表现。  - **@support**：support 检查环境的特性，它与 `media` 比较类似。  - **@namespace**：用于跟 `xml` 命名空间配合的一个规则，表示内部的 `css` 选择器全都带上特定命名空间。  - **@viewport**：用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 `html`的 `meta` 代替。  - **@color-profile**  - **@document**  - **@font-feature-values** '},{title:"三栏布局",path:"/posts/Chapter2/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80.html",strippedContent:' ##  三栏布局有几种实现方式，并说出它们的优缺点。  *三栏布局是指左栏和右栏固定宽度，中间的宽度自适应。三栏布局也被称为圣杯布局或者双飞翼布局。*  ### 1. 浮动布局   ```html <style type="text/css">     .left, .center, .right {         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         float: left;         background: red;     }     .right {         float: right;         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="right"></div>     <div class="center"></div> </body> ```  ### 2. 绝对定位布局   ```html <style type="text/css">     .left, .center, .right {         position: absolute;         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         left: 0;         background: red;     }     .right {         right: 0;         background: blue;     }     .center {         left: 300px;         right: 300px;         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```  ### 3. flex 布局   ```html <style type="text/css">     body {         display: flex;     }     .left, .center, .right {         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         flex: 1;         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```   ### 4. bable-cell 表格布局   ```html <style type="text/css">     body {         display: table;         width: 100%;         height: 200px;     }     .left, .center, .right {         display: table-cell;     }     .left, .right {         width: 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```   ### 5. grid 网格布局   ```html <style type="text/css">     body {         display: grid;         width: 100%;         grid-template-rows: 200px;         grid-template-columns: 300px auto 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```  ### 总结  ```html 1. 浮动布局：兼容性比较好，但是浮动元素脱离了文档流，会造成父容器高度塌陷，需要清除浮动。 2. 绝对定位布局：绝对定位布局快捷，但是有效性比较差，元素脱离了文档流，高度未知的时候会有问题。 3. flex 布局：移动端常用的布局方案，解决了上述两种布局的不足。 4. table-cell 表格布局：兼容性好，但是有时候单元格高度超出的时候，其他单元格的高度也会被撑高；无法设置边距；对SEO不好。 5. grid 网格布局：比较新的二维布局方式，兼容性没那么好。 ``` '},{title:"实现轮子",path:"/posts/Chapter4/",strippedContent:' ## 1. 手动实现 call、apply、bind。  ### 手动实现 call() 方法  **实现思路：调用 `call` 方法时，`this` 指向传入的第一个参数，参数不固定。**   ```js Function.prototype._call = function() {     let thisArg = arguments[0];     if(thisArg === null || thisArg === undefined)  thisArg = window;     let args = Array.prototype.slice.call(arguments, 1, arguments.length);     thisArg._prov_ = this; // 将 this 存储到到临时属性中，为了之后的删除操作     thisArg._prov_(...args); // 这一步相当于直接调用 this this(...args)     delete thisArg._prov_; // 删除临时属性 防止副作用 }  // 测试 let thisArg = {     name: "thisArg" } let thisArg1 = {     name: "thisArg1",     fun: function(age) {        console.log(this.name, age)      } }  thisArg1.fun.call(thisArg); // "thisArg" undefined thisArg1.fun.call(thisArg, 23); // "thisArg" 23 thisArg1.fun._call(thisArg);  // "thisArg" undefined thisArg1.fun._call(thisArg, 23) // "thisArg" 23 ```  ### 手动实现 apply() 方法  **实现思路：`apply()` 与 `call()` 的区别是第二个参数是一个数组。**  ```js Function.prototype._call = function() {     let thisArg = arguments[0];     if(thisArg === null || thisArg === undefined) thisArg = window;     let args = Array.prototype.slice.call(arguments, 1, arguments.length);     thisArg._prov_ = this;     thisArg._prov_(args);     delete thisArg._prov_; } ```  ### 手动实现 bind() 方法  **实现思路：** 1. 调用 `bind()` 方法时，返回一个新函数，普通调用时，新函数的 `this` 指向传入的参数。 2. 如果使用 `new` 调用 `bind` 返回的新函数时，`this` 指向这个新函数。[new 操作符](http://localhost:8080/posts/Chapter1/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html#_4-new-%E7%BB%91%E5%AE%9A%EF%BC%9Athis-%E6%8C%87%E5%90%91%E5%88%9B%E5%BB%BA%E7%9A%84%E7%A9%BA%E5%AF%B9%E8%B1%A1-%E3%80%82)  ```js Function.prototype._bind = function() {     let thisArg = arguments[0];  // 获取 this     let args = Array.prototype.slice.call(arguments, 1); // 获取调用 bind 时传入的参数     let that = this;     let newF = function() {         //调用 bind 返回的新函数时，         //如果通过 new 调用 this 指向返回的新函数         //普通调用时 this 指向传入的第一个参数         let ctx = this instanceof newF ? this : thisArg;            let newArgs = arguments;         let initArgs = args.concat(Array.from(newArgs));  // 合并调用 bind 时传入的参数和调用返回的新函数传入的参数         return that.apply(ctx, initArgs);   // 调用程序     }     return newF;  // 返回新函数 }  let obj1 = {     name: "obj1" } let obj = {     name: "obj",     fun: function(age) {         console.log(this)         console.log(this.name, age);     } }  var f = obj.fun._bind(obj1, 1);  f();  // 输出结果为 obj1 1  this 指向 obj1   new f(); // 输出结果为 undefined 1  this 指向返回的新对象  ```  ## 2. 手动实现符合 Promise/A+ 规范的Promise、手动实现 async await。  ### 手动实现 Promise   ## 3. 手写一个 EventEmitter 实现事件发布、订阅。   ## 4. 可以说出两种实现双向绑定的方案、可以手动实现。   ## 5. 手写 JSON.stringify、JSON.parse。   ## 6. 手写一个模版引擎，并能解释其中原理。   ## 7. 手写懒加载、下拉刷新、上拉加载、预加载等效果。 '},{title:"数据结构",path:"/posts/Chapter4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",strippedContent:" ## 1. 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点。  ## 2. 理解数组、字符串的存储原理，并熟练应用他们解决问题。  ## 3. 理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题。  ## 4. 了解图、堆的基本结构和使用场景。"},{title:"算法",path:"/posts/Chapter4/%E7%AE%97%E6%B3%95.html",strippedContent:" ## 1. 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗。  ## 2. 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度。  ## 3. 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用。  ## 4. 可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题。  ## 5. 前端处理海量数据的算法方案。 "},{title:"TypeScript",path:"/posts/Chapter6/TypeScript.html",strippedContent:" ## 1. 理解泛型、接口等面向对象的相关概念，TypeScript 对面向对象理念的实现。  ## 2. 理解使用 TypeScript 的好处，掌握 TypeScript 基础语法。  ## 3. TypeScript 的规则检测原理。  ## 4. 可以在 React、Vue 等框架中使用 TypeScript 进行开发。"},{title:"项目构建",path:"/posts/Chapter7/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA.html",strippedContent:" 1. 理解 npm、yarn 依赖包管理的原理，两者的区别。  2. 可以使用 npm 运行自定义脚本。  3. 理解 Babel、ESLint、webpack 等工具在项目中承担的作用。  4. ESLint 规则检测原理，常用的 ESLint 配置。  5. Babel 的核心原理，可以自己编写一个 Babel 插件。  6. 可以配置一种前端代码兼容方案，如 Polyfill。  7. Webpack 的编译原理、构建流程、热更新原理，chunk、bundle 和 module 的区别和应用。  8. 可熟练配置已有的 loaders 和 plugins 解决问题，可以自己编写 loaders 和 plugins。  "},{title:"版本控制",path:"/posts/Chapter7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.html",strippedContent:" 1. 理解Git的核心原理、工作流程、和 SVN 的区别。  2. 熟练使用常规的 Git 命令、git rebase、git stash 等进阶命令。  3. 可以快速解决线上分支回滚、线上分支错误合并等复杂问题。"},{title:"持续集成",path:"/posts/Chapter7/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90.html",strippedContent:" 1. 理解 CI/CD 技术的意义，至少熟练掌握一种 CI/CD 工具的使用，如 Jenkins。  2. 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）。 "},{title:"开发提速",path:"/posts/Chapter7/%E5%BC%80%E5%8F%91%E6%8F%90%E9%80%9F.html",strippedContent:" 1. 熟练掌握一种接口管理、接口 mock 工具的使用，如 yapi。  2. 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题。  3. 理解 TDD 与 BDD 模式，至少会使用一种前端单元测试框架。"},{title:"数据流管理",path:"/posts/Chapter6/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86.html",strippedContent:" 1. 掌握 React 和 Vue 传统的跨组件通信方案，对比采用数据流管理框架的异同。  2. 熟练使用 Redux 管理数据流，并理解其实现原理，中间件实现原理。  3. 熟练使用 Mobx 管理数据流，并理解其实现原理，相比 Redux 有什么优势。   4. 熟练使用 Vuex 管理数据流，并理解其实现原理。  5. 以上数据流方案的异同和优缺点，不情况下的技术选型。 "},{title:"Nginx",path:"/posts/Chapter7/nginx.html",strippedContent:" ## 1. 正向代理与反向代理的特点和实例。  ## 2. 可手动搭建一个简单的 nginx 服务器。  ## 3. 熟练应用常用的 nginx 内置变量，掌握常用的匹配规则写法。  ## 4. 可以用 nginx 实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理。"},{title:"编码能力",path:"/posts/Chapter4/%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B.html",strippedContent:" ## 1. 多种方式实现数组去重、扁平化、对比优缺点。  ## 2. 多种方式实现深拷贝、对比优缺点。  ## 3. 手写函数柯里化工具函数、并理解其应用场景和优势。  ## 4. 手写防抖和节流工具函数、并理解其内部原理和应用场景。  ## 5. 实现一个 sleep 函数。  "},{title:"React",path:"/posts/Chapter6/react.html",strippedContent:" ## 1. React 和 Vue 选型以及两者优缺点、核心架构的区别。  ## 2. React中 setState 的执行机制，如何有效的管理状态。  ## 3. React 的事件底层实现机制。  ## 4. React 的虚拟 DOM 和 Diff 算法的内部实现。  ## 5. React的 Fiber 工作原理，解决了什么问题。  ## 6. React Router 和 Vue Router 的底层实现原理、动态加载实现原理。  ## 7. 可熟练应用 React API、生命周期等，可应用 HOC、render props、Hooks 等高阶用法解决问题。  ## 8. 基于 React 的特性和原理，可以手动实现一个简单的 React。"},{title:"异常处理",path:"/posts/Chapter1/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8.html",strippedContent:" # 如何优雅的处理前端异常？  转自：[如何优雅处理前端异常？](http://jartto.wang/2018/11/20/js-exception-handling/index.html)  作者：[Jartto](http://jartto.wang/)  ## 为什么要处理异常？ > 异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。  1. 增强用户体验。 2. 远程定位问题。 3. 未雨绸缪，及早发现问题。 4. 无法复现问题，尤其是移动端，机型，系统都是问题。 5. 完善的前端方案，前端监控系统。  对于 `JS` 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 `JS` 引擎崩溃，最多只会使当前执行的任务终止。  ## 需要处理哪些异常？ 对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：  - `JS` 语法错误、代码异常。 - `AJAX` 请求异常。 - 静态资源加载异常。 - `Promise` 异常。 - `Iframe` 异常。 - 跨域 `Script error`。 - 崩溃和卡顿。  下面我会针对每种具体情况来说明如何处理这些异常。  ## Try-Catch 的误区  `try-catch` 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。   1.只能捕获同步运行时错误 ```js try {     let name = 'jartto';     console.log(nam); } catch(e) {     console.log('捕获到异常：',e); } ``` 输出： ```js     捕获到异常： ReferenceError: nam is not defined         at <anonymous>:3:15 ``` 2.不能捕获到语法错误，我们修改一下代码，删掉一个单引号： ```js try {     let name = 'jartto;     console.log(nam); } catch(e) {     console.log('捕获到异常：',e); } ``` 输出： ```js Uncaught SyntaxError: Invalid or unexpected token ``` *不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。*  3.异步错误 ```js try {     setTimeout(() => {         undefined.map(v => v);     }, 1000) } catch(e) {     console.log('捕获到异常：',e); } ``` 我们看看日志： ```js Uncaught TypeError: Cannot read property 'map' of undefined     at setTimeout (<anonymous>:3:11) ``` 并没有捕获到异常，这是需要我们特别注意的地方。  ## window.onerror 不是万能的  当 `JS` 发生运行时错误时，`window` 会触发 `ErrorEvent` 接口的 `error` 事件，并执行 `window.onerror()`。 ```js /** * @param {String}  message    错误信息 * @param {String}  source    出错文件 * @param {Number}  lineno    行号 * @param {Number}  colno    列号 * @param {Object}  error  Error对象（对象） */ window.onerror = function(message, source, lineno, colno, error) {    console.log('捕获到异常：',{ message, source, lineno, colno, error }); } ``` 1.首先试试同步运行时错误 ```js window.onerror = function(message, source, lineno, colno, error) {     // message：错误信息（字符串）。     // source：发生错误的脚本URL（字符串）     // lineno：发生错误的行号（数字）     // colno：发生错误的列号（数字）     // error：Error对象（对象）     console.log('捕获到异常：', { message, source, lineno, colno, error }); } Jartto; ``` 可以看到，我们捕获到了异常：  ![onerror](https://qiniu.mdnice.com/9df3c9c44449c798ba4966d4c1accbd5.png)  2.再试试语法错误呢？ ```js window.onerror = function(message, source, lineno, colno, error) {     console.log('捕获到异常：',{message, source, lineno, colno, error}); } let name = 'Jartto ``` 控制台打印出了这样的异常：  ```js Uncaught SyntaxError: Invalid or unexpected token ```  >什么，竟然没有捕获到语法错误？  3.怀着忐忑的心，我们最后来试试异步运行时错误：  ```js window.onerror = function(message, source, lineno, colno, error) {     console.log('捕获到异常：',{message, source, lineno, colno, error}); } setTimeout(() => {     Jartto; }); ``` 控制台输出了：  ```js 捕获到异常： {message: \"Uncaught ReferenceError: Jartto is not defined\", source: \"http://127.0.0.1:8001/\", lineno: 36, colno: 5, error: ReferenceError: Jartto is not defined     at setTimeout (http://127.0.0.1:8001/:36:5)} ```  4.接着，我们试试网络请求异常的情况：  ```js <script> window.onerror = function(message, source, lineno, colno, error) {     console.log('捕获到异常：',{message, source, lineno, colno, error});     return true; } <\/script> <img src=\"./jartto.png\"> ```  > 我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。  补充一点：`window.onerror` 函数只有在返回 `true` 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 `Uncaught Error: xxxxx`。  ```js window.onerror = function(message, source, lineno, colno, error) {     console.log('捕获到异常：',{message, source, lineno, colno, error});     return true; } setTimeout(() => {     Jartto; }); ``` 控制台就不会再有这样的错误了：  ```js Uncaught ReferenceError: Jartto is not defined     at setTimeout ((index):36) ```  需要注意： - `onerror` 最好写在所有 `JS` 脚本的前面，否则有可能捕获不到错误。 - `onerror` 无法捕获语法错误。  到这里基本就清晰了：在实际的使用过程中，`onerror` 主要是来捕获预料之外的错误，而 `try-catch` 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。  > 问题又来了，捕获不到静态资源加载异常怎么办？ 当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 `Event` 接口的 `error` 事件，并执行该元素上的 `onerror()` 处理函数。这些 `error` 事件不会向上冒泡到 `window`，不过（至少在 `Firefox` 中）能被单一的 `window.addEventListener` 捕获。  ```js <scritp> window.addEventListener('error', (error) => {     console.log('捕获到异常：', error); }, true) <\/script> <img src=\"./jartto.png\"> ```  控制台输出：  ![捕获异常](https://qiniu.mdnice.com/8b687377fe3fa092a745a3ca13091dfa.png)  由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 `HTTP` 的状态是 `404` 还是其他比如 `500` 等等，所以还需要配合服务端日志才进行排查分析才可以。  需要注意：  - 不同浏览器下返回的 `error` 对象可能不同，需要注意兼容处理。 - 需要注意避免 `addEventListener` 重复监听。  ## Promise Catch  > 在 promise 中使用 catch 可以非常方便的捕获到异步 error，这个很简单。  没有写 `catch` 的 `Promise` 中抛出的错误无法被 `onerror` 或 `try-catch` 捕获到，所以我们务必要在 `Promise` 中不要忘记写 `catch` 处理抛出的异常。  解决方案： 为了防止有漏掉的 `Promise` 异常，建议在全局增加一个对 `unhandledrejection` 的监听，用来全局监听 `Uncaught Promise Error`。  使用方式：  ```js window.addEventListener(\"unhandledrejection\", function(e) {   console.log(e); }); ```  我们继续来尝试一下： ```js window.addEventListener(\"unhandledrejection\", function(e) {   e.preventDefault()   console.log('捕获到异常：', e);   return true; }); Promise.reject('promise error'); ```  可以看到如下输出：  ![异常捕获](https://qiniu.mdnice.com/28f4eea6f9e6f66b091cc037a99229fc.png)  那如果对 `Promise` 不进行 `catch` 呢？  ```js window.addEventListener(\"unhandledrejection\", function(e) {   e.preventDefault()   console.log('捕获到异常：', e);   return true; }); new Promise((resolve, reject) => {   reject('jartto: promise error'); }); ```  > 嗯，事实证明，也是会被正常捕获到的。  所以，正如我们上面所说，为了防止有漏掉的 `Promise` 异常，建议在全局增加一个对 `unhandledrejection` 的监听，用来全局监听 `Uncaught Promise Error`。  补充一点：如果去掉控制台的异常显示，需要加上：  ```js event.preventDefault(); ```  ## VUE errorHandler  ```js Vue.config.errorHandler = (err, vm, info) => {   console.error('通过vue errorHandler捕获的错误');   console.error(err);   console.error(vm);   console.error(info); } ```  ## React 异常捕获  `React 16` 提供了一个内置函数 `componentDidCatch`，使用它可以非常简单的获取到 `react` 下的错误信息： ```js componentDidCatch(error, info) {     console.log(error, info); } ```  除此之外，我们可以了解一下：`error boundary`。 `UI` 的某部分引起的 `JS` 错误不应该破坏整个程序，为了帮 `React` 的使用者解决这个问题，`React 16` 介绍了一种关于错误边界（`error boundary`）的新观念。  需要注意的是： error boundaries 并不会捕捉下面这些错误：  1. 事件处理器。 2. 异步代码。 3. 服务端的渲染代码。 4. 在 `error boundaries` 区域内的错误。  我们来举一个小例子，在下面这个 `componentDIdCatch(error,info)` 里的类会变成一个 `error boundary`：  ```js class ErrorBoundary extends React.Component {   constructor(props) {     super(props);     this.state = { hasError: false };   }     componentDidCatch(error, info) {     // Display fallback UI     this.setState({ hasError: true });     // You can also log the error to an error reporting service     logErrorToMyService(error, info);   }     render() {     if (this.state.hasError) {       // You can render any custom fallback UI       return <h1>Something went wrong.</h1>;     }     return this.props.children;   } } ```  然后我们像使用普通组件那样使用它： ```js <ErrorBoundary>   <MyWidget /> </ErrorBoundary> ```  `componentDidCatch()` 方法像 `JS` 的 `catch{}` 模块一样工作，但是对于组件，只有 `class` 类型的组件可以成为一个 `error boundaries`。  实际上，大多数情况下我们可以在整个程序中定义一个 `error boundary` 组件，之后就可以一直使用它了！  ## iframe 异常  对于 `iframe` 的异常捕获，我们还得借力 `window.onerror`：  ```js window.onerror = function(message, source, lineno, colno, error) {   console.log('捕获到异常：',{message, source, lineno, colno, error}); } ```  一个简单的例子可能如下： ```js <iframe src=\"./iframe.html\" frameborder=\"0\"></iframe> <script>   window.frames[0].onerror = function (message, source, lineno, colno, error) {     console.log('捕获到 iframe 异常：',{message, source, lineno, colno, error});     return true;   }; <\/script> ```  ## Script error  一般情况，如果出现 `Script error` 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：  > 跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。  ```js <script src=\"http://jartto.wang/main.js\" crossorigin><\/script> ```  或者动态去添加 `js` 脚本：  ```js const script = document.createElement('script'); script.crossOrigin = 'anonymous'; script.src = url; document.body.appendChild(script); ```  > 特别注意，服务器端需要设置：Access-Control-Allow-Origin。  此外，我们也可以试试这个[解决 Script Error 的另类思路](https://juejin.im/post/5c00a405f265da610e7fd024)：  ```js const originAddEventListener = EventTarget.prototype.addEventListener; EventTarget.prototype.addEventListener = function (type, listener, options) {   const wrappedListener = function (...args) {     try {       return listener.apply(this, args);     }     catch (err) {       throw err;     }   }   return originAddEventListener.call(this, type, wrappedListener, options); } ```  简单解释一下：  - 改写了 `EventTarget` 的 `addEventListener` 方法。 - 对传入的 `listener` 进行包装，返回包装过的 `listener`，对其执行进行 `try-catch`。 - 浏览器不会对 `try-catch` 起来的异常进行跨域拦截，所以 `catch` 到的时候，是有堆栈信息的。 - 重新 `throw` 出来异常的时候，执行的是同域代码，所以 `window.onerror` 捕获的时候不会丢失堆栈信息。  利用包装 `addEventListener`，我们还可以达到「扩展堆栈」的效果：  ```js (() => {    const originAddEventListener = EventTarget.prototype.addEventListener;    EventTarget.prototype.addEventListener = function (type, listener, options) { +    // 捕获添加事件时的堆栈 +    const addStack = new Error(`Event (${type})`).stack;      const wrappedListener = function (...args) {        try {          return listener.apply(this, args);        }        catch (err) { +        // 异常发生时，扩展堆栈 +        err.stack += '\\n' + addStack;          throw err;        }      }      return originAddEventListener.call(this, type, wrappedListener, options);    } })(); ```  ## 崩溃和卡顿  卡顿也就是网页暂时响应比较慢，`JS` 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，`JS` 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？  > 崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。  1.利用 `window` 对象的 `load` 和 `beforeunload` 事件实现了网页崩溃的监控。 不错的文章，推荐阅读：[Logging Information on Browser Crashes](http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/)。  ```js window.addEventListener('load', function () {     sessionStorage.setItem('good_exit', 'pending');     setInterval(function () {         sessionStorage.setItem('time_before_crash', new Date().toString());     }, 1000); });  window.addEventListener('beforeunload', function () {     sessionStorage.setItem('good_exit', 'true'); });  if(sessionStorage.getItem('good_exit') &&     sessionStorage.getItem('good_exit') !== 'true') {     /*         insert crash logging code here     */     alert('Hey, welcome back from your crash, looks like you crashed on: ' + sessionStorage.getItem('time_before_crash')); } ```  2.基于以下原因，我们可以使用 `Service Worker` 来实现[网页崩溃的监控](https://juejin.im/entry/5be158116fb9a049c6434f4a?utm_source=gold_browser_extension)：  - `Service Worker` 有自己独立的工作线程，与网页区分开，网页崩溃了，`Service Worker` 一般情况下不会崩溃。 - `Service Worker` 生命周期一般要比网页还要长，可以用来监控网页的状态。 网页可以通过 `navigator.serviceWorker.controller.postMessage API` 向掌管自己的 `SW` 发送消息。  ## 错误上报  1.通过 `Ajax` 发送数据  因为 `Ajax` 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 `img` 标签的形式进行上报。  2.动态创建 `img` 标签的形式 ```js function report(error) {   let reportUrl = 'http://jartto.wang/report';   new Image().src = `${reportUrl}?logs=${error}`; } ```  收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而[减缓服务器的压力](https://github.com/happylindz/blog/issues/5)：  ```js Reporter.send = function(data) {   // 只采集 30%   if(Math.random() < 0.3) {     send(data)      // 上报错误信息   } } ```  > 采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。  ## 总结  回到我们开头提出的那个问题，如何优雅的处理异常呢？  1. 可疑区域增加 `Try-Catch`。 2. 全局监控 `JS` 异常 `window.onerror`。 3. 全局监控静态资源异常 `window.addEventListener`。 4. 捕获没有 `Catch` 的 `Promise` 异常：`unhandledrejection`。 5. `VUE errorHandler` 和 `React componentDidCatch`。 6. 监控网页崩溃：`window` 对象的 `load` 和 `beforeunload`。 7. 跨域 `crossOrigin` 解决。  其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。"},{title:"基础问题",path:"/posts/Chapter1/",strippedContent:' ## 1. JavaScript 规定了几种语言类型？  JavaScript 规定了两种数据类型： - **原始类型：** `string`、`number`、`boolean` 、`null`、`undefined`、`symbol`  - **引用类型：** `Object`、`Function`、`Array`  ## 2. JavaScript 对象的底层数据结构是什么？   ## 3. 理解 `ECMAScript` 和 `JavaScript` 的关系。  ECMAScript 和 JavaScript 的关系是：前者是后者的规格，后者是前者的一种实现，在日常场合，这两个词是可以互换的。  ```js ECMAScript 是国际标准化组织 ECMA 为 JavaScript 制定的一种标准，之所以不叫 JavaScript： 一是因为商标问题，JavaScript 本身也已经被 Netscape 公司注册为商标，只有 Netscape 公司可以合法地使用 JavaScript 这个名字。 二是想体现这门语言的制定者是 ECMA，这样有利于保证这门语言的开放性和中立性。 ```   ## 4. JavaScript 变量类型在内存中的具体存储形式？  - **基本类型：** 保存在`栈`内存中，通过按值访问，值都有固定的大小。  - **引用类型：** 保存在`堆`内存中，通过按引用访问（不允许直接访问堆内存），值大小不固定。  ```js let a: string = "123"; // 栈内存 let b: number = 123; // 栈内存 let c: null = null; // 栈内存 let d: object = { x: 10 }; // 变量d存在于栈中，{ x: 10 }作为对象存在于堆中 let e = [1, 2, 3]; // 变量e存在于栈中，[1, 2, 3]作为对象存在于堆中 ``` 如图所示：  ![屏幕快照 2019-09-20 下午3.26.23.png](https://i.loli.net/2019/09/20/Cu3irzOYkqGFfsD.png)  拓展：  - **原始类型**的比较是值的比较，只有它们的值相等时才相等。  - **引用类型**的比较是按引用的比较，当且仅当它们引用同一个基本对象时，它们才相等。   ## 5. null 和 undefined 的区别？ **null** 表示`"空对象"`，即此处应该有值： ```js  - 在 if 语句中，会转换为 false. - 转换为数字时，表示为 0。 - 作为函数的参数，表示该函数的参数不是对象。 - 作为对象原型链的终点 Object.getPrototypeOf(Object.prototype); ``` **undefined** 表示  `"缺少值"`，就是此处应该有一个值，但是还没有定义： ```js - 在 if 语句中，会转换为 false. - 转换为数字时，表示为 NaN. - 变量被声明了，但没有被赋值，就等于 undefined. - 调用函数时，没有提供对应的实参，该参数显示为 undefined. - 对象没有赋值的属性，该属性的值为 undefined. - 函数没有返回值时，默认返回 undefined. ``` 拓展： ```html typeof null 为 "object" 的解释： 不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型。 null 的二进制表示都是 0，自然前三位都是 0，所以执行 typeof null 时，会返回 ”object”。 ```   ## 6. 出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript 处理大数字的方法、避免精度丢失的方法？  参考： 1. [JavaScript数字精度丢失问题总结](https://www.cnblogs.com/thinkingthigh/p/8073526.html) 2. [最大安全整数](https://segmentfault.com/a/1190000002608050) 3. [超出JavaScript安全整数限制的数字计算-BigInt](https://www.cnblogs.com/wangmeijian/p/9217352.html)   JavaScript 处理大数字避免精度丢失，可以在存储时使用字符串进行存储。  '},{title:"作用域",path:"/posts/Chapter1/%E4%BD%9C%E7%94%A8%E5%9F%9F.html",strippedContent:' ## 1. 理解词法作用域和动态作用域。  ### 什么是词法作用域？  **词法作用域：** 是定义在词法阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和函数作用域写在哪里来决定的。  因此当词法分析器处理代码时会保持作用域不变。词法作用域即**静态作用域**。  **动态作用域：** 需要明确的是，JavaScript 并不具有动态作用域，它只有词法作用域，简单明了。  **`this` 的执行机制表现的像动态作用域，因为 `this` 的绑定是在代码执行时确定的。**  所谓 **`动态作用域`** 是指作用域在代码执行之前都不确定，也就是说拥有动态作用域的编程语言，函数的作用域是在函数调用的时候才决定的。  为什么说 JavaScript 没有动态作用域？ ```js var num = 1; function foo() {     console.log(num); } function bar() {     var num = 2;     foo(); } bar(); // 输出结果是？ ```  假设 JavaScript 采用动态作用域，让我们分析下执行过程：  执行 `foo()`时 ，依然是从 `foo` 函数内部查找是否有局部变量 `num`。如果没有，就会顺着调用栈在调用 `foo` 函数的位置，也就是 `bar` 函数内部查找 `num` 变量，结果会打印 `2`。  而上段代码的输出结果是 `1`，在执行 `foo()` 时，先从 `foo` 函数内部查找是否有局部变量 `num`，如果没有，就根据书写的位置，查找上一层层的代码，找到了 `var num = 1`，所以结果会打印 1。所以 JavaScript 采用的是静态作用域，作用域在书写代码时就已经决定了**与调用位置没有关系。**  总结： ``` html JavaScript 只有词法作用域，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 ```  **思考：** ```js var scope = "global scope"; function checkscope() {     var scope = "local scope";     function f() {         return scope;     }     return f(); } checkscope(); ``` ```js var scope = "global scope"; function checkscope() {     var scope = "local scope";     function f() {         return scope;     }     return f; } checkscope()(); ```  ## 2. 理解 JavaScript 的作用域和作用域链。   **作用域：** JavaScript 中的作用域就是词法作用域(事实上大部分语言都是基于词法作用域的)。  `词法作用域`是一套关于引擎如何寻找变量以及会在何处找到变量的规则。  `词法作用域`最重要的特征是**它的定义过程发生在代码的书写阶段**(假设你没有使用 `eval()` 或 `with`)。   **作用域链：** 当在查找变量时，首先会在当前作用域中进行查找，如果没有找到，就会向上级进行查找，直到全局作用域。这个过程形成的关系链就是作用域。  如下代码：  ```js function foo(a) {     var b = a * 2;     function bar(c) {         console.log(a, b, c);     }     bar(b * 3); } foo(1); ```   在上段代码中，引擎执行 `console.log()` 声明，并查找 `a`、`b` 和 `c` 三个变量的引用。它首先从最内部的作用域，也就是 `bar()` 函数的作用域开始查找，引擎首先这里找到了`c`，而无法在这里找到 `a`，因此会去上一级到所嵌套的 `foo()` 的作用域中继续查找，在`foo()` 中查找到了`b`，而扔没有找到 `a`的引用， 因此引擎会继续去上一级（这级是全局作用域）继续查找，最后在找到了 `a`。最后经过一些列的向上查找，得到最后的输出结果 `1, 2, 6`。  **注意：** 词法作用域查找只会查找**一级标识符**，如果代码中引用了 `foo.bar.baz`，词法作用域查找只会试图查找 `foo` 标识符，找到这个变量后，对象属性访问规则会分别接管对 `bar` 和 `baz` 属性的访问。  ![屏幕快照 2019-09-23 下午4.25.28.png](https://i.loli.net/2019/09/23/BTSID9FgkGLid45.png)   **思考如下代码：** ```js var a = 10; var foo = {     a: 11,     bar: {         baz: function() {             console.log(a);         }     } } foo.bar.baz(); ```'},{title:"执行机制",path:"/posts/Chapter1/%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html",strippedContent:' ## 1. 为何 try 里面放 return，finally 还会执行，理解其内部机制。  如果存在 `finally` 代码块，`try` 中的 `return` 语句不会立马返回给调用者， 而是记录下返回值等待 `finally` 代码块执行完毕之后再返回。  **注意的几点：**  - 不管 `try` 里有没有返回值，`finally` 都会执行。  - 不管有没有异常，`finally` 都会被执行。  - `finally` 里边的返回值会覆盖 `try` 中返回的值。    ## 2. JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制。  ## 3. 宏任务和微任务分别有哪些?  **宏任务：** 事件队列中每一个事件、`setImmediate（node环境）`、 `MessageChannel`、 `setTimeout`、`setInterval`。  **微任务：** `Promise.then()` 、`MutationObserver`、`process.nextTick（node环境）`。  ## 4. 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法。  ## 5. 使用`Promise`实现串行。 不对  **Promise 串行的实现原理：** 让每个串行中的任务都返回一个 `Promise`，最后统一由 `Promise` 进行 `then` 链式调用达到串行的目的。  ```js function task(fn) {     return new Promise((resolve, reject) => {         fn()         resolve();     }) } function first() {     console.log(1); } function second() {     console.log(2); } function third() {     console.log(3); }  let promise = new Promise((resolve, reject) => {     resolve("promise"); }) promise.then(task(first))     .then(task(second))     .then(task(third))     .then((res) => {         console.log(res);     }) // 1 // 2 // 3 // promise ```     ## 6. Node 与浏览器 EventLoop 的差异。  ### 事件循环   ```html 事件循环是计算机系统的一种运行机制，JavaScript 采用事件循环机制来处理异步任务的执行。 ```  [HTML规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop) 中指出：一个事件循环有一个或者多个**任务队列（Task Queue）**，一个任务队列有一组**任务（异步任务）**。  任务可以分成两种，一种是**同步任务**，另一种是**异步任务**。  **同步任务**是指在主线程上排队执行的任务，同步任务形成 `执行栈`。  **异步任务**不进入主线程排队，而是进入 `Task Queue` 排队的任务，只有 `Task Queue` 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。  ```html 执行栈中的同步任务执行完毕后，才会将 Task Queue 中的异步任务加入到主线程执行。 ```  异步任务分为：**宏任务（macrotask）**和**微任务（microtask）**。  - **宏任务（macrotask）：**     包含执行整体的 JavaScript 代码、事件回调、XHR 回调、定时器（setTimeout/setInterval/setImmediate）、IO操作以及UI渲染。  - **微任务（microtask）：**     更新应用程序状态的任务，包括 `promise` 回调、`MutationObserver`、`process.nextTick` 以及 `Object.observe`。  <img alt="event-loop" src="https://i.loli.net/2019/09/27/wNb9KecBHvyGtWL.png" width="80%">  ### Node.js 中的事件循环  当 `node.js` 运行时，会初始化一个 `EventLoop`，处理那些通过**异步api调用**、**定时器**或者调用 `process.nextTick()` 提供的 `script`或者输入到 `REPL` 中的 `script`。  下图展示了事件循环的操作顺序以及概要。  <img alt="node事件循环" src="https://i.loli.net/2019/09/27/jZNezAMIwUkbxWR.png" width="90%">  ### 浏览器中的事件循环  - 执行一个**宏任务（macrotask）**。  - 执行过程中如果遇到**微任务（microtask）**，就将它添加到微任务的任务队列中。  - **宏任务（macrotask）**执行完毕后，立即执行当前**微任务（microtask）**队列中的所有微任务（先进先出）。  - 当前**宏任务（macrotask）**执行完毕，开始检查渲染，然后 `GUI` 线程接管渲染。    <img alt="浏览器事件循环" src="https://i.loli.net/2019/09/27/vskWbIJrhP5CKX9.png" width="50%">  ### 差异： **Node.js 中**，微任务 `microtask` 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 `microtask` 队列的任务。  <img alt="node事件循环" src="https://i.loli.net/2019/09/27/THPNqOjWvIAXsBG.png" width="70%">  **浏览器环境下**，微任务 `microtask` 任务队列是每个宏任务 `macrotask` 执行完之后执行。  <img alt="浏览器事件循环" src="https://i.loli.net/2019/09/27/7rbNAxsjhLf3uZM.png" width="70%">  ## 7. 如何在保证页面运行流畅的情况下处理海量数据。  '},{title:"正则表达式",path:"/posts/Chapter1/%E6%AD%A3%E5%88%99.html",strippedContent:' ## 1. JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题。  ### 修饰符 修饰符写在结尾的 `/` 之后，影响整个正则表达式的匹配行为。  - **`i` 不区分大小写（ignore）：**      在匹配时忽略英文字母的大小写。  - **`g` 全局匹配（global）：**      正则表达式默认只会返回第一个匹配结果，使用标志符 `g` 则可以返回所有匹配。  - **`m` 多行匹配（multiline）：**      将开始和结束字符（ `^` 和 `$` ）视为在多行上工作。      即分别匹配每一行（由 `\\n` 或 `\\r` 分割）的开始和结束，而不只是只匹配整个输入字符串的最开始和最末尾处。  ### 字符集 用于匹配字符集中的任意一个字符。  - `[xyz]`：匹配所包含的`x`、`y`、`z` 任意一个字符。  - `[^xyz]`：补集，匹配除 `x`、`y`、`z` 以外的字符。  - `[a-z]`：匹配从 `a` 到 `z` 的任意字符。  - `[^a-n]`：补集，匹配除`a` 到 `n` 的其他字符。  - `[A-Z]`：匹配从 `A` 到 `Z` 的任意字符。  - `[0-9]`：匹配从 `0` 到 `9` 的任意数字。  ```js 匹配所有的字母和数字可以写成：/[a-zA-Z0-9]/ 或者 /[a-z0-9]/i ```  ### 量词 使用量词达到重复匹配的目的。  - **`{n}`**：匹配 `n` 次。  - **`{n,m}`**：匹配 `n-m` 次。  - **`{n,}`**：匹配 `>=n` 次。  - **`?`**：匹配 `0 || 1` 次。  - **`*`**：匹配 `>=0` 次，等价于 `{0,}`。  - **`+`**：匹配 `>=1` 次，等价于 `{1,}`。   ### 元字符 元字符就是描述字符的字符，它用于对字符表达式的内容、转换及各种操作信息进行描述。  - **`\\d`**：匹配任意数字，等价于 `[0-9]`。  - **`\\D`**：匹配任意非数字字符，`\\d` 的补集。  - **`\\w`**：匹配任意基本拉丁字母表中的字母和数字，以及下划线，等价于 `[A-Za-z0-9_]`。  - **`\\W`**：匹配任意非基本拉丁字母表中的字母和数字，以及下划线，`\\w` 的补集。  - **`\\s`**：匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。  - **`\\S`**：匹配一个非空白符，`\\s` 的补集。  - **`\\b`**：匹配一个零宽单词边界，如一个字母与一个空格之间。     ```js     例如 /\\bno/ 匹配 "at noon" 中的 "no"。     /ly\\b/ 匹配 "possibly yesterday." 中的 "ly"。     ```  - **`\\B`**：匹配一个零宽非单词边界，如两个字母之间或两个空格之间。     ```js     例如，/\\Bon/ 匹配 "at noon" 中的 "on"。     /ye\\B/ 匹配 "possibly yesterday." 中的 "ye"。     ```  - **`\\t`**：匹配一个水平制表符（tab)。  - **`\\n`**：匹配一个换行符（newline)。  - **`\\r`**：匹配一个回车符（carriage return)。  ### 特殊字符 它们不会按照字面意思进行匹配，而有特殊的意义，比如前文讲过用于量词的 `?`、`*`、`+`。  其他常见的特殊字符有：  - **`\\`**：转义字符。可以将普通字符转成特殊字符。也可以将特殊字符转成字面意思。     ```js     比如 \\+ 匹配 +。     ```  - **`.`**：匹配任意单个字符，但是换行符除外（`\\n`, `\\r`, `\\u2028`或 `\\u2029`）。     ```js     在字符集中 [.]，无特殊含义，即表示 \'.\' 的字面意思。     ```  - **`|`**：替换字符，匹配 `|` 前或后的表达式。     ```js     比如需要同时匹配 "bear" 和 "pear"，可以使用 /(b|p)ear/ 或者 /bear|pear/。     但是不能用 /b|pear/，该表达式只能匹配 "b" 和 "pear"。     ```  - **`^`**：匹配输入的开始。     ```js     比如，/^A/ 不匹配 "an Apple" 中的 "A"，但匹配 "An apple" 中的 "A"。     ```  - **`$`**：匹配输入的结尾。     ```js     比如，/t$/ 不匹配 "eater" 中的 "t"，但匹配 "eat" 中的 "t"。     ^ 和 $ 在表单验证时常需要使用，因为需要验证从开始到结尾的一个完整输入，而不是匹配输入中的某一段。     ```   ### 分组 - **`(xyz)`**：捕获分组，匹配并捕获匹配项。     ```     例如，/(foo)/ 匹配且捕获 "foo bar." 中的 "foo"。     被匹配的子字符串可以在结果数组的元素 [1], …, [n] 中找到，     或在被定义的 RegExp 对象的属性 $1, …, $9中找到。     ``` - **`(?:xyz)`**：非捕获分组，匹配但不会捕获匹配项，匹配项不能再次被访问到。  - **`\\n`**：n 是一个正整数，表示反向引用，指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。 \t```js \t例如，/apple(,)\\sorange\\1/ 匹配 "apple, orange, cherry, peach." 中的 "apple,orange,"。     ```  ### 断言  - **`x(?=y)`**：仅匹配被 `y` 跟随的 `x`。 \t```js     例如， /bruce(?=wayne)/，如果 "bruce" 后面跟着 wayne，则匹配之。     /bruce(?=wayne|banner)/，如果 "bruce" 后面跟着 "wayne" 或者 banner，则匹配之。     但是，"wayne" 和 "banner" 都不会在匹配结果中出现。     ``` \t - **`x(?!y)`**：仅匹配不被 `y` 跟随的 `x`。 \t```js     /\\d+(?!.)/ 只会匹配不被 "." 跟随的数字。      ```  **`/\\d+(?!\\.)/.exec(\'3.141\')` 匹配 "141"，而不是 "3.141"。**   ### 应用 #### 1. 匹配手机号码  目前国内的手机号码是 `1(3/4/5/7/8)` 开头的 `11` 位数字，因此手机号码的正则可以分解为以下几部分：  - 以 `1` 开头：`/^1/`。  - 第 `2` 位为 `3、4、5、7、8` 中的一个：`/[34578]/` 或 `/(3|4|5|7|8)/`。  - 剩余 `3-11` 位均为数字，并以数字结尾：`/\\d{9}$/`。  - 组合起来即为 `/^1[34578]\\d{9}$/` 或 `/^1(3|4|5|7|8)\\d{9}$/`，因为使用捕获括号存在性能损失，所以推荐使用第一种写法。  #### 2. 匹配电子邮件  标准的电子邮件组成为 `<yourname>@<domain>.<extension><optional-extension>`，每部分的格式标准为（进行了相应的简化，主要为展示如何书写正则）：  - `yourname`：任意英文字母`（a-z/A-Z）`、数字`（0-9）`、下划线`（_）`、英文句点`（.）`、连字符`（-）`，长度大于 `0`。   -`domain`：任意英文字母`（a-z/A-Z）`、数字`（0-9）`、连字符`（-）`，长度大于 `0`。  - `extension`：任意英文字母`（a-z/A-Z）`，长度 `2-8`。  - `optional-extension`：`"."` 开头，后面跟任意英文字母`（a-z/A-Z）`，长度 `2-8` 可选。  每部分的正则表达式为：  - **yourname**：`/[a-z\\d._-]+/`；  - **domain**：`/[a-z\\d-]+/`；  - **extension**： `/[a-z]{2,8}/`；  - **optional-extension**：`/(.[a-z]{2,8})?/`。  组合起来形成最后的正则表达式：`/^([a-z\\d._-]+)@([a-z\\d-]+)\\.([a-z]{2,8})(\\.[a-z]{2,8})?$/`；为了增加可读性可以将每部分用 `"()"` 包起来，并不要忘记起始和结束符 `^$`。  *本节参考[还不会正则表达式？看这篇！](https://mp.weixin.qq.com/s/f6ii_hKgY0gLdhMFda6S6Q)* '},{title:"类型转换",path:"/posts/Chapter1/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html",strippedContent:' # 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用？  ## 类型转换表  |值\t|转换为字符串\t|转换为数字\t|转换为布尔值\t|转换为对象| |---|------------|----------|----------|---------| |undefined\t|“undefined”|\tNaN\t|false|\tthrow TypeError| |null\t|“null”|\t0\t|false\t|throw TypeError |true|\t“true”\t|1\t|\tnew Boolean(“true”) |false\t|“false”|\t0\t\t|new Boolean(“false”) |“”\t|\t0\t|false|\tnew String("") |“1.2”\t|\t1.2\t|true|\tnew String(“1.2”) |“1.2a”\t|\tNaN\t|true|\tnew String(“1.2a”) |“aaa”|\t\tNaN\t|true\t|new String(“aaa”) |0\t|“0”\t|\tfalse|\tnew Number(0) |-0\t|“0”\t|\tfalse\t|new Number(-0) |1\t|“1”|\t\ttrue|\tnew Number(1) |NaN\t|“NaN”\t|\tfalse\t|new Number(NaN) |Infinity\t|“Infinity”\t|\ttrue\t|new Number(Infinity) |-Infinity|\t“-Infinity”\t|\ttrue|\tnew Number(-Infinity) |[]\t|“”|\t0\t|true\t |[9]|\t“9”\t|9|\ttrue\t |[“a”, “b”]\t|“a,b”|\tNaN\t|true\t |{} | 参见下 | 参见下 |true | | |function() {} | 参见下 | NaN |true | |   ## 对象类型的转换  ### 对象转换成字符( 这里说的是 String()方法的原理 ) 1. 若对象具有 `toString()` 方法，调用 `toString()`，如果返回一个原始值，则将这个原始值转换为字符串返回。  2. 若无 `toString()` 方法，或 `toString()` 的返回值并不是一个原始值，寻找其 `valueOf()` 方法，若存在这个方法，调用它，如果它返回一个原始值，将这个原始值转换为字符串返回。  3. 若无 `valueOf()`或 `valueOf()` 的返回值不是原始值，则 JavaScript 无法得一个原始值，会抛出 `throw TypeError`。  ### 对象转换成数字（这里说的是 Number() 方法的原理） 1. 若具有 `valueOf()` 方法，调用 `valueOf()`，如果它返回一个原始值，将这个原始值转换为数字返回。  2. 若无 `valueOf()` 方法，或 `valueOf()` 的返回值并不是一个原始值，寻找其 `toString()` 方法，若存在这个方法，调用它，如果它返回一个原始值，将这个原始值转换为数字返回。  3. 若无 `toString()` 或 `toString()` 的返回值不是原始值，则 JavaScript 无法得一个原始值，会抛出 `throw TypeError`。  ```js  1. 对象转字符串：先调用 toString() 再尝试调用 valueOf()。 2. 对象转数字： 先调用 valueOf() 再尝试调用 toString()。 3. 数组类型的转换也遵循以上三条，不过数组的 join() 方法的返回结果覆盖了原型链上的toString() 方法。 ```  ### 对象转换成布尔值 对象类型转换为布尔值：均为 `true`，不管其 `toString()`、`valueOf()` 方法返回什么。  ## 各类型的 toString()、valueOf() 方法的返回值  ### 1. 对象 - `toString()` 返回：*"[object Object]"*。 - `valueOf()` 返回：*对象本身*。  ### 2. 数组 - `toString()` 返回：*`arr.join()` 的返回值*。 - `valueOf()` 返回：*数组本身*。  ### 3. 函数 - `toString()` 返回：*整个函数字符串*。 - `valueOf()` 返回：*函数本身*。 ```js function foo() {return "foo"}; foo.toString() // "function foo() {return "foo"}" foo.valueOf() // ƒ foo() {return "foo"} ``` ### 4. 日期  - `toString()` 返回：*完整时间字符串*。 - `valueOf()` 返回：*从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期的毫秒数。*  ```js var date = new Date() date.toString() // "Tue Nov 05 2019 13:54:57 GMT+0800 (中国标准时间)" date.valueOf() // 1572933297576 ```  ### 5. Error - `toString()` 返回：*"Error: 错误描述"*。 - `valueOf()` 返回：*错误本身*。  ### 6. RegExp - `toString()` 返回：*正则式完整字符串*。 - `valueOf()` 返回：*正则本身*。  ```js var a = new RegExp(\'^ass[^fsf]\\w?\',\'gi\'); a.toString(); // "/^ass[^fsf]\\w?/gi" a.valueOf(); //  /^ass[^fsf]\\w?/gi ```  ## 运算符中的隐式类型转换  以上只是一些原理的介绍，下面介绍运算符中的隐式类型转换。  ### 1.算术运算符（+、-、*、/、++、–、% …） - `+` 作为一个双目运算符： 若 `+` 两边存在一个字符串，将另一个也转为字符串进行字符串拼接。  - 其他情况下，不管双目还是单目，都转为数值类型。  ### 2. 关系运算符（>、<、==、!= …） - `===`、`!==`：同时对比类型和值，两个都为真才返回真。  - `==`、`!=`： 若两边均为对象，对比它们的引用是否相同。  - 逻辑非 `!`： 将其后变量或表达式转为布尔值。  - 字符串比较：从头至尾扫描逐个比较每个字符的 `unicode` 码，直到分出大小。  - 其他情况下，两边均转为数值类型。   ### 注意  1. `NaN` 与任何值都不相同，与任何值比较都返回 `false`。  2. 对象类型在运算时进行类型转换都先调用 `valueOf()` 方法，再尝试 `toString()` 方法。  3. 在进行对象字面量运算时要注意，若运算符两边都是字面量，则将它们都视为对象字面量进行类型转换；若只有一个字面量时要注意，当这个字面量在首位时，会被当做一个块（表达式）看待。  ```js {} + {} \t\t// "[object Object][object Object]" [1,2,3] + [] \t//\t "1,2,3" + "" -> "1,2,3"  [] + {} \t\t// "" + "[object Object]" -> "[object Object]" {} + []\t\t    // 0 -> {} 被当做一个块（表达式），相当于执行 ({},+[])，返回值为小括号最后面的表达式的返回值。 {q:1} + [] \t\t// 0  var a = {q:1}; a + []\t //  "[object Object]"     变量形式运算正常 [] + a \t // "[object Object]"  {} == []  => 报错   ({}, ==[]) -> 报错 [] == 0   => true\t[] -> "" -> 0 ![] == 0  => true   ![] -> false -> 0 [] == ![] => true   [] -> "" -> 0    ![] -> false -> 0 [] == []  => false  比较引用地址 {} == {}  => false  比较引用地址 {} == !{} => false  !{} -> false -> 0    {} -> "[object Object]" -> NaN ```  '},{title:"Symbol",path:"/posts/Chapter1/symbol.html",strippedContent:" # Symbol 类型在实际开发中的应用？  `symbol` 是 ES6 新增，是一种基本数据类型，该类型具有静态属性和静态方法。  `Symbol()` 函数会返回 `symbol` 类型的值，但它不支持语法 `new Symbol()`。  > 每个从 Symbol()返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。  ## symbol 的特性  ### 1. 独一无二  使用 `Symbol()` 函数可以创建一个 `symbol` 类型的值，可传入一个可选的字符串作为描述，当传入对象时，将调用对象的 `toString()` 方法。  ```js var sym1 = Symbol();              // Symbol() var sym2 = Symbol('foo');         // Symbol(foo) var sym3 = Symbol('foo');         // Symbol(foo) var sym4 = Symbol({name: 'foo'}); // Symbol([object Object]) ``` 我们使用 `Symbol()` 创建了四个新的 `symbol` 类型，它每次都会创建一个新的 `symbol` 类型，即使传入相同的参数：  ```js Symbol('foo') == Symbol('foo')  //false ``` **可见 `symbol` 类型具有独一无二的特性。**    上面使用 `Symbol()` 函数的语法，不会在你的整个代码库中创建一个可用的全局 `symbol` 类型。  要创建跨文件可用的 `symbol`，甚至跨域（每个都有它自己的全局作用域)， 可以使用 `Symbol.for()` 方法和  `Symbol.keyFor()` 方法从全局的 `symbol` 注册表设置和取得 `symbol`。   使用静态方法 `Symbol.for(key)` 可以创造两个相等的 `symbol` 变量。   ```js Symbol.for('L') === Symbol('L'); // true  var key = Symbol.for('L'); Symbol.keyFor(key) === Symbol.keyFor(key); // true ```  ### 2. 原始类型  `symbol` 是一个原始类型的数据，但是它不能使用 `new Symbol()` 创建一个 Symbol 包装对象：  ```js var sym = new Symbol(); // TypeError ```  *围绕原始数据类型创建一个显式的包装对象从 `ECMAScript 6` 开始不再被支持。*  如果想创建一个 `Symbol` 包装对象 ，可以使用 `Object()` 函数：  ```js var sym = Symbol(\"foo\"); typeof sym;     // \"symbol\" var symObj = Object(sym); typeof symObj;  // \"object\" ```  ### 3. 不可枚举  当使用 `symbol` 作为对象属性时，可以保证对象不会出现重名属性，调用 `for...in` 不能将其枚举出来。  另外调用 `Object.getOwnPropertyNames()`、`Object.keys()` 也不能获取 `symbol` 类型属性。  ```js var obj = {     name: 'L',     [Symbol('occ')]: 'Web' } for(var key in ojb) {     console.log(key)  // name } Object.getOwnPropertyNames(obj); // [\"name\"] Object.keys(obj); // [\"name\"] ```  如果要获取对象上的 `symbol` 属性，可以使用 `Object.getOwnPropertySymbols()`：  ```js Object.getOwnPropertySymbols(obj); // [Symbol(occ)] ```  如果要获取对象上的所有属性，可以使用新增的 `Reflect.ownKeys()`：  ```js Reflect.ownKeys(obj); //  [\"name\", Symbol(occ)] ```  ## symbol 的应用场景  1. 不需要对外操作和访问的属性使用 `Symbol` 来定义（React $$typeof 标识）。 2. 使用 `Symbol` 代替常量。 3. 设置类的私有属性。 4. 防止属性污染。"},{title:"原型和原型链",path:"/posts/Chapter1/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.html",strippedContent:' ## 1. 理解原型设计模式以及 JavaScript 中的原型规则。  我们创建的每个函数都有一个 `protoype` 属性，这个 `prototype` 属性是一个指针，指向**原型对象**。  **这个对象的用途**：包含由特定类型的所有实例共享的属性和方法（通俗的说就是，所有特定类型的实例都可以共享这个对象上的属性和方法）。  ### 原型对象的两种赋值方法：  ##### 1. 给原型对象添加属性或方法： ```js function Person() {} // Person 原型对象上默认只有一个 constructor 属性 // 这个 constructor 指向 Person Person.prototype.name = "jser"; Person.prototype.age = 16; Person.prototype.sayName = function() {     return this.name; }  let per1 = new Person(); let per2 = new Person(); per1.sayName === per2.sayName; // true per1.age === per2.age;  // true ``` 正如上边所说，实例 `per1` 和 `per2` 共享 `Person` 原型对象的属性和方法。  ##### 2. 重写原型对象： ```js function Person() {} Person.prototype = {     name: "jser",     age: 16,     sayName() {         return this.name;     } } let per1 = new Person(); let per2 = new Person(); per1.sayName === per2.sayName; // true per1.age === per2.age;  // true ``` 这种方式会重写原型对象，重写后的原型对象默认的 `constructor` 属性不再指向 `Person` 此时它指向 `Object`。（下文会有讲到）  我们可以手动将它指向 `Person`： ```js Person.prototype = {     constructor: Person,     ... } ```  ### 原型对象内存分析：  ![屏幕快照 2019-09-25 下午4.25.37.png](https://i.loli.net/2019/09/25/kC9hIFf1PJosjHX.png)  默认情况下，原型对象 `Person.prototype` 会包含一个 `constructor` 属性，这个属性上也有一个 `prototype` 属性，这个属性是一个指针，指向**原型对象**。  ```js 创建的实例也有 constructor 属性，可以使用 实例.constructor.prototype 去修改或扩展原型对象。 ``` ```js Person.prototype.constructor === Person // true Person.prototype.constructor.prototype === Person.prototype // true ```  当调用构造函数创建一个新实例后，该实例内部会包含一个内部属性 `__proto__`，它指向构造函数的原型对象。  ```js person1.__proto__ === Person.prototype // true ```  这个`连接`只存在于**实例**与构造函数的**原型对象**之间，而不是存在于实例与构造函数之间，**也就是说这个内部属性和构造函数没有直接的关系。**  ### 原型对象的值不能被实例重写： ```js function Person() {} Person.prototype = {     constructor: Person,     name: "jser",     age: 16,     sayName() {         return this.name;     } } let per1 = new Person(); let per2 = new Person(); per1.name = "zxl"; // 重写 name console.log(per1.name);  // zxl person实例 在自身查到到了 name  console.log(per2.name);  // jser 在原型对象上查找到的 name ``` 可以看到原型对象中的 `name` 没有被改变，`person2.name` 在原型对象上查找的值仍为 `"jser"`。  **原型模式查找属性原则：**  - 在**原型模式**中，当通过实例读取属性值时，首先会在实例自身上查找，如果实例上没有，则就会去原型对象上搜索；  - 如果在**自身**上找到，就使用这个值，不会再继续去原型对象上查找。  ![屏幕快照 2019-09-25 下午5.13.55.png](https://i.loli.net/2019/09/25/QdMBUg5YSR6ce3p.png)  ### 原型模式的动态性：  上文说到不能通过实例对象来重写原型对象上的属性，如果想要重写原型对象上的属性，只能通过原型对象自身去修改。 ```js ... Person.prototype.age = 22; ``` **原型模型原则：由于在原型中查找值的过程是一次搜索，因此在对原型对象做的任何修改都会立即从实例上反映出来，即使是先创建实例后修改原型也如此。** ```js // 先创建实例 后修改原型对象 let per2 = new Person(); Person.prototype.age = 22; console.log(per2.age); // 变成改写后的 22  // 后创建实例 先修改原型对象 Person.prototype.age = 22; let per2 = new Person(); console.log(per2.age); // 变成改写后的 22 ``` **如果先创建了实例，之后用字面量赋值的方式来重写原型对象，这就会切断现有原型对象与之前存在的任何实例之间的联系。** ```js function Person() {} let per1 = new Person(); Person.prototype = {     name: "jser",     age: 16,     sayHi() {         console.log("Hi");     } } per1.sayHi(); ``` 这段代码会报 `Uncaught TypeError: per1.sayHi is not a function`，说明实例 `per1` 没有搜索不到 `sayHi` 这个方法，因为在创建 `per1` 实例之前，`per1.__proto__` 指向的原型对象只有一个默认属性 `constructor`。 ```js { constructor: ƒ } ``` 重写的 `Person.prototype` 被分配在了新的内存空间中：  ![屏幕快照 2019-09-25 下午5.58.18.png](https://i.loli.net/2019/09/25/3nq4eFlfZCEhuNy.png)  ### 原型对象的缺点： **原型对象**的好处是原型中的所有属性和方法可以被很多实例共享。  缺点是当原型中包含引用类型的值的属性时，一个实例对象对这个引用类型的属性做了修改，在其他实例对象中也可以体现出来。  ```js function Person() {} Person.prototype = {     constructor: Person,     name: "jser",     age: 16,     friends: ["javaer", "phper"] } let per1 = new Person(); per1.friends.push("pythener"); let per2 = new Person(); console.log(per2.friends) ``` 原型对象中引用类型属性 `friends` 被修改成了 ` ["javaer", "phper", "pythener"]`，因此实例对象 `per2` 搜索到的结果也被 `per1` 修改了。  ### 从原型对象中体现的一些原型模式的规则可以总结如下：  - 构造函数有一个 `prototype` 指针指向原型对象，构造函数的实例共享原型对象上的属性和方法。  - 实例与原型对象之间有一个 `__proto__` 连接。  - 原型对象上有一个 `constructor` 属性默认指向构造函数，`constructor` 属性上有一个 `prototype` 指针指向原型对象。  - 原型对象上的值不能被实例重写。  - 在原型模式中，通过实例子搜索属性时，实例上的属性会屏蔽原型对象上的同名属性。  - 原型模式中查找值的过程是一次搜索，因此在对原型对象做的任何修改都会立即从实例上反映出来，即使是先创建实例后修改原型也如此。 - 如果先创建了实例，之后用字面量赋值的方式来重写原型对象，这就会切断现有原型对象与之前存在的任何实例之间的联系。  - 原型可以被继承，如通过 `Object.create(prototype, optionalDescriptorObjects)` 来实现原型继承。  ## 2. instanceof 的底层实现原理，手动实现一个 instanceof。  **instanceof**是用来判断 `a` 是否为 `B` 的实例，表达式为：a `instanceof` B，如果 `a` 是 `B` 的实例，则返回 `true`，否则返回 `false`。   **在这里需要特别注意的是：`instanceof` 检测的是原型对象。** ```js // 底层实现原理： instanceof (a,B) = {     var L = a.__proto__;     var R = B.prototype;     if(L === R) {         // A的内部属性 __proto__ 指向 B 的原型对象         return true;     }     return false; } ``` 代码的基本实现： ```js function _instanceof(instance, F) {     if(!F) `Right-hand side of \'instanceof\' is not an object`;     const L = instance.__proto__;     const R = F.prototype;     if(!L) throw `Unexpected identifier`;     if(instance.__proto__ === F.prototype) {         return true;     }     return false; } ```  ## 3. 实现继承的几种方式以及他们的优缺点。  继承的继承方式：`原型链继承`、 `构造继承（call/apply）`、`组合继承`、`寄生组合继承` `ES6继承`。  ### 原型链继承  ##### 首先回顾下构造函数、原型、和实例之间的关系： 每一个构造函数都有一个原型对象 `F.prototype`，原型对象都包含一个指向构造构造的指针 `constructor`，而实例都包含一个指向原型对象的内部指针 `__proto__`。 ```js function F() {} var f = new F() F.prototype.constructor === F; f.__proto__ === F.prototype;  ``` **原型链继承的思想：**将父类的实例作为子类的原型对象。 ```js function Tiger(leg) {     this.leg = leg; } Tiger.prototype.getLeg = function() {     return this.leg; }  function Cat(eat) {     this.eat =  eat; }  // 将 Tiger 的实例对象 Tiger {leg: "四条腿"} 作为 Cat 的原型对象 // 这是一个重写 Cat 原型对象的过程 Cat.prototype = new Tiger("四条腿");    Cat.prototype.getEat = function() {     return this.eat; }  let cat = new Cat("鱼"); console.log(cat.getLeg()); // 四条腿 console.log(cat.getEat()); // 鱼 ``` **原型链继承实际上是重写子类原型对象的过程，子类原型对象的 `constructor` 属性会被默认指向父类。** ```js Cat.prototype.constructor === Tiger; // true ```  **原型链继承的缺点：** 当父类的原型对象修改后，子类也会访问到修改后的结果，父类一变其他都跟着变了。  *遵循了原型模式的动态性（请看第 1 小节）*  ### 构造继承（call/apply）  **构造继承的思想：** 利用 `call` 或 `apply` 将父类的 `this` 硬绑定到子类上。  ```js function Tiger (leg) {     this.leg = leg;     this.getLeg = function () {         return this.leg;     } }; //对原型对象进行的扩展的方法就无法被继承了 Tiger.prototype.getEat = function () {         console.log("吃肉"); };  function Cat(eat) {     // 使用 call 将 this 硬绑定到 Cat 类上     // 创建 Cat 类实例后，实例调用方法时，this 指向 Cat     // console.log(this); Cat      Tiger.call(this, \'四条腿\');　　     this.eat = eat; };  let cat = new Cat("鱼"); console.log(cat.leg);　　　　  // 四条腿 （继承自 Tiger 类） console.log(cat.getEat());　　// 报错 调用不到 Tiger 类原型对象上面的方法　　 ```  **构造继承的缺点：**  - 只能继承父类的实例属性或方法，不能继承父类原型上的属性或方法，无法实现函数复用。  - 每个子类都有父类实例函数的副本，性能会有耗损。  ### 组合继承  **组合继承的思想：**是将`原型链继承`和`构造继承`组合起来使用，是常用的一种继承方式。 ```js function Tiger(leg) {     this.leg = leg; } Tiger.prototype.getLeg = function() {     return this.leg; }  function Cat(eat) {     // 构造继承 使用 call 调用父类 将 this 硬绑定到子类上     // 继承父类的实例属性或方法     Tiger.call(this, "四条腿"); // 第二次调用父类     this.eat =  eat; }  // 使用原型链继承 将 Tiger 的实例对象 Tiger {leg: "四条腿"} 作为 Cat 的原型对象 // 继承父类的原型属性或原型方法 Cat.prototype = new Tiger("四条腿");   // 第一次调用父类  Cat.prototype.getEat = function() {     return this.eat; }  let cat = new Cat("鱼"); // 触发第二次调用 console.log(cat.leg);  // 四条腿 （继承自父的实例属性 ） console.log(cat.getLeg()); // 四条腿 （继承自父类的原型方法） console.log(cat.getEat()); // 鱼 ``` 第一次调用 `Tiger` 构造函数时，`Cat.prototype` 会得到属性 `leg`，它是父类的实例属性，只不过现在位于子类的原型对象中。 当 使用 `new` 调用 `Cat` 构造函数时，又会调用一次 `Tiger` 构造函数，这一次会在 `new` 创建的新对象上创建实例属性 `leg`， 于是这个属性就屏蔽了原型对象上的同名属性。  **组合继承的缺点：** 调用了两次父类，第二次调用父类时，会在新对象上创建实例属性，这会屏蔽存在子类原型对象上的同名属性。  ### 寄生式继承  **寄生继承的思想：**创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。  ```js function cloneObj(parent) {     let clone = object(parent);     clone.getLeg = function() {        return this.leg;     }     return clone; }  // 寄生 function object(obj) {     function F() {};     F.prototype = obj;     return new F(); }  let tiger = {     eat: "肉",     leg: "四条" } let cat = cloneObj(tiger); cat.getLeg();  // 四条 ```  **寄生继承的缺点：**使用寄生式继承为对象添加方法，会由于不能做到方法的复用而降低效率，这一点和构造函数模式类似。   ### 寄生组合继承 **寄生组合继承思想：**是在组合继承的基础上，使用`寄生`方式对组合继承进行的一次优化。 ```js function Tiger(name) {     this.name = name; } Tiger.prototype.leg = "四条腿";  Tiger.prototype.getEat = function() {     return this.eat; } function Cat(eat) {     // 构造继承 使用 call 调用父类 将 this 硬绑定到子类上     // 继承父类的实例属性或方法     Tiger.call(this, "老虎");      this.eat = eat; } // 寄生 !function() {     let F = function() {};         // 创建一个空对象作为寄生     F.prototype = Tiger.prototype; // 将父类的原型对象寄生到空对象的原型对象上     new F().constructor  = Cat;    // 构造指针手动指向子类     Cat.prototype = new F();       // 将空对象的实例作为子类的原型对象 （子类只继承了父类的原型上的方法和属性） }();  let cat = new Cat("鱼"); console.log(cat.eat); // 鱼 // （子类实例自身的属性） console.log(cat.leg); // 四条腿 （继承了父类原型上的属性） console.log(cat.getEat()); ``` **寄生组合继承是实现基于类型的继承的最有效的方式，但是实现起来相对复杂，代码量会很大。**  ### ES6 继承（这里在本节作为了解） ES6 中提供了 `class` 构造函数的写法，对于继承 `class` 可以使用 `extends` 关键字。 ```js class Tiger {     constructor(leg){         this.leg = leg;     }     getLeg() {         console.log(this.leg);     } } class Cat extends Tiger {       constructor(leg, eat) {         super(leg);  //相当于构造继承中的 Tiger.call(this, leg);         this.eat = eat;     }     //子类独有的方法     getEat() {         return this.eat;     } }      const cat = new Cat("四条腿", "鱼");     cat.getLeg();     cat.getEat();     console.log(cat instanceof Cat);    //true     console.log(cat instanceof Tiger);  //true ``` **拓展：**  ```js ES6 提供了 Object.create() 方法也可以实现继承。 语法：Object.create(proto[, propertiesObject]) ```   ## 4. 至少说出一种开源项目(如Node)中应用原型继承的案例。  ## 5. 描述 new 一个对象的详细过程，手动实现一个 new 操作符。  **使用 `new`操作符来调用函数时，会自动执行下面的操作：**  1.创建一个新的空对象；  2.这个对象会被执行 `[[prototpye]]` 连接；  3.这个新对象会绑定到函数调用的 `this`；  4.如果函数没用返回其他对象，那么 `new` 调用的函数会自动返回这个新对象。  **手动实现：** ```js // new 操作符的模拟实现 function _new() {     let o = {}; // 创建一个空对象     let C = arguments[0];  // 获得构造函数     o.constructor = C;     // 将空对象的 constructor 默认指向构造函数     o.__proto___ = C.prototype;  // 进行 [[prototype]] 连接     let res = C.apply(o, arguments);  // 进行 this 绑定 并获得构造函数返回值     // 返回处理     return typeof res === "object" ? res : o; } // 测试 function Person() {     this.name = "jser" } var p = _new(Person); p.name; // ”jser“ p.constructor  // Person ```  ## 6. 理解 es6 中 class 构造以及继承的底层实现原理。 '}]}}]);