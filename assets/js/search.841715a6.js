(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{300:function(t,e,o){"use strict";o.r(e),e.default=[{title:"浏览器原理",path:"/posts/Chapter5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86.html",strippedContent:" ## 1. 各浏览器使用的 JavaScript 引擎以及它们的异同点、如何在代码中进行区分。  ## 2. 请求数据到请求结束与服务器进行了几次交互。  ## 3. 可详细描述浏览器从输入 URL 到页面展现的详细过程。  [从输入URL到浏览器显示页面发生了什么](https://www.cnblogs.com/yuanzhiguo/p/8119470.html)  ## 4. 浏览器解析HTML代码的原理，以及构建 DOM 树的流程。  ## 5. 浏览器如何解析 CSS 规则，并将其应用到 DOM 树上。  ## 6. 浏览器如何将解析好的带有样式的DOM树进行绘制。  ## 7. 浏览器的运行机制，如何配置资源异步同步加载。  ## 8. 浏览器回流与重绘的底层原理，引发原因，如何有效避免。 ![浏览器的渲染过程](https://qiniu.mdnice.com/01ad76b52063b38398ffde4cade3edb9.png)  ### 浏览器的渲染过程： 1. 解析 `HTML` 树生成 `DOM` 树，解析 `CSS` 生成 `CSSOM` 树。 2. 将 `DOM` 树和 `CSSOM` 树结合生成渲染树 `renderTree`。 3. `Layout（回流）`：根据生成的 `renderTree` 进行回流（`Layout`），得到节点的几何信息（位置、大小）。 4. `Painting（重绘）`：根据 `renderTree` 以及回流 `Layout` 得到节点的绝对像素。 5. `Display`：将像素发送给 **GPU** 线程，展示在页面上。  #### 生成渲染树 - renderTree ![image](https://qiniu.mdnice.com/879265b75b6f3681721fff44b582b4ef.png)  为了构建渲染树，浏览器主要完成了以下工作。  - 从 `DOM` 树的根节点开始遍历每个可见节点。 - 对于每个可见的节点，找到 `CSSOM` 树中对应的规则，并应用它们。 - 根据每个可见节点以及其对应的样式，组合生成渲染树。  第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：  - 一些不会渲染输出的节点，比如 `script`、`meta`、`link` 等。 - 一些通过 `css` 进行隐藏的节点。比如 `display:none`。（注意，利用 `visibility` 和 `opacity` 隐藏的节点，还是会显示在渲染树上的，只有 `display:none;` 的节点才不会显示在渲染树上。）  ####  回流 - Layout 前面我们通过构造渲染树 `renderTree`，我们将可见 `DOM` 节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(`viewport`)内的确切位置和大小，这个计算的阶段就是**回流**。  为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历,而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。  #### 重绘 - Painting 通过回流(`Layout`)阶段，我们知道了所有的可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做**重绘**。  #### 何时会发生回流重绘？ 回流 `Layout` 阶段是计算节点的几何信息和位置，那么当**页面布局**或者**几何信息**发生改变时，就会发生回流。 1. 添加或者删除可见的 `DOM` 元素。 2. 元素的尺寸或者位置发生变化时。 3. 页面开始渲染的时候。 4. 浏览器的视口尺寸大小发生改变时（因为回流是根据浏览器视口的大小来计算元素的位置和尺寸大小）。  **注意：回流一定会触发重绘，而重绘不一定会触发回流（非几何信息的样式发生改变）, `reflow` 回流的成本开销要高于 `repaint` 重绘，一个节点的回流往往回导致子节点以及同级节点的回流。**  根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。  #### 基于回流（Layout）、重绘（Painting）的优化方法  ##### 1. 避免扰乱现代浏览器的优化机制 在现代浏览器的中，由于每次回流、重绘的时候，都需要额外的计算消耗，因此会通过队列化修改，并批量执行来优化这一过程。 浏览器会将修改操作放入队列里面，直到过了一段时间或者达到一个阈值，才清空队列。   但是当你获取布局信息时，会强制刷新队列，例如：  ```js offsetTop、offsetLeft、offsetWidth、offsetHeight  scrollTop、scrollLeft、scrollWidth、scrollHeight  clientTop、clientLeft、clientWidth、clientHeight  getComputedStyle()  getBoundingClientRect() ```  上面这些方法，都需要获取最新的布局信息，所以浏览器会强制刷新队列并执行回流、重绘，来获取最新的信息。 因此我们在修改样式的时候，应该尽量避免使用上面的属性、方法，如果非要使用，可以先缓存起来然后一起获取。  ##### 2. `CSS` 的修改方式  考虑以下代码： ```js const el = document.getElementById('el') el.style.padding = 'xxx' el.style.margin = 'xxx' el.style.border = 'xxx' ```  这里元素的几何信息有三次被修改了，但是现代浏览器会将起缓存起来，但是如果这期间有通过前面列出来的属性、方法访问位置信息的话就会触发三次回流、重绘。所以还是建议通过 `cssText` 或者 `class` 的方法一次性修改。  ```js el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;'; // 或者 el.className += 'xxx'; ```  ##### 3. 批量修改 DOM 当我们需要对 `DOM` 进行一系列修改的时候，可以通过以下几种方式减少回流重绘次数：  - 隐藏元素，应用修改，重新显示：     ```js     function appendDataToElement (appendToElement, data) {          let li;         for ( let i = 0; i < data.length; i++) {         li = document.createElement('li');         li.textContent = 'text';         appendToElement.appendChild(li);             }     }      const ul = document.getElementById('list');     ul.style.display = 'none'; // 首先脱离文档流     appendDataToElement(ul, data);     ul.style.display = 'block'; // 操作完以后再可见          ```  - 使用文档片段(`document fragment`)在当前 `DOM` 之外构建一个子树，再把它拷贝回文档。     ```js     const ul = document.getElementById('list');     const fragment = document.createDocumentFragment();     appendDataToElement(fragment , data);     ul.appendChild(fragment);     ``` ##### 4. 独立图层 一个图层的回流和重绘只会在该图层当中进行，不会影响其他图层，所以有必要的时候，可以将某些元素放到单独的图层。  例如对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流， 成为一个单独的图层。否则会引起父元素以及后续元素频繁的回流。但是因该尽量少量使用图层，因为图层的合成是特别消耗性能，一个页面当中不能有过多的图层, 在使用了图层之后需要进行前后对比。   会自动建立图层的情况:  - `3d` 或者透视变换、过渡 `css` 属性。 - 使用 `<video>` 节点。 - `<canvas>`。 - `flash`。 - 多透明度做 `css` 动画。   ##### 5. 其他优化  - 用 `translate` 替代 `top` 改变：`top` 会触发回流，而前者不会。 - 用 `opacity` 替代 `visibility`： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发。 - 不要使用 `table` 布局，`table` 可能很小的一个改动会造成回流，很影响性能，应该尽量使用 `div`。 - 动画实现的速度选择。 - 对于动画新建图层。 - 启用 GPU 硬件加速: 使用 `transform:translateZ(0)`、`transform:translate3d(0,0,0)` 来开启 GPU 硬件加速。   ### CSS 和 JS 是这样阻塞 DOM 解析和渲染的  通过 `<script>` 与 `<link>` 引入外部资源，当解析到该标签的时候，会进行下载。  1. CSS 脚本的加载不会阻塞 `DOM` 解析过程，但是会阻塞渲染过程(`painting`)。 2. JS 脚本的加载与执行会阻塞 `DOM` 解析过程, 但是不会阻塞后续资源的加载。 3. JS 脚本的加载中，如果你确定没必要阻塞 `DOM` 解析的话，不妨按需要加上 `defer` 或者 `async` 属性，此时脚本下载的过程中是不会阻塞 `DOM` 解析的。 4. 浏览器遇到 `<script>` 且没有 `defer` 或 `async` 属性的标签时，为了为 `<script>` 标签内部的 js 提供最新的信息，会触发页面的回流、重绘过程。 5. 如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕之后再执行脚本。即 css 不阻塞 js 的加载，但阻塞它的执行。  所以 `<script>` 最好放底部(防止阻塞 `DOM` 解析)。 `<link>` 最好放头部(为渲染过程提供样式)。如果头部同时有 `<script>` 与 `<link>` 的情况下，最好将 `<script>` 放在 `<link>` 上面(为了防止 CSS 脚本加载时间过长，使 js 等待时间也很长)。  ### defer 和 async  绿色的代表 `html` 解析，蓝色的代表 `javascript` 脚本的下载，红色的代表 `javaScript` 脚本的执行。   ![defer&async](https://qiniu.mdnice.com/d5471718236806507193c95751fba3a9.png)   ## 9. 浏览器的垃圾回收机制，如何避免内存泄漏。  JavaScript 使用垃圾回收机制来自动管理内存。  JavaScript 的回收机制分两种：1.标记清除； 2.引用计数。（各大浏览器常用的是前）。  ### 引用计数 跟踪记录每个值被引用的次数。  - 当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是 `1`。 - 如果同一个值又被赋给另一个变量，则该值的引用次 数加 `1`。 - 相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减 `1`。 - 当这个值的引用次数变成 `0` 时，则说明没有办法访问这个值了，因此就可以将其占用的内存空间回收回来。  ```js var a = {};     对象 a 的引用计数为 1 b = a;          对象 a 的引用计数为 1 + 1  a = null;       对象 a 的引用计数为 2 - 1 不能被回收。 ``` ### 标记清除 标记清除的算法分为两个阶段： - 标记（mark）：从引用根节点开始标记所有被引用的对象。 - 清除（sweep）：遍历整个堆，把未标记的对象进行清除。  ```js markFromRoots():     worklist <- empty     for each fld in Roots         ref <- *fld         if ref != null && isNotMarked(ref)              setMarked(ref)            add(worklist,ref)            mark() mark():     while not isEmpty(worklist)           ref <- remove(worklist)             for each fld in Pointers(ref)                   child <- *fld                 if child != null && isNotMarked(child)                    setMarked(child)                    add(worklist,child)  sweep(start,end):     scan <- start    while scan < end        if isMarked(scan)           setUnMarked(scan)       else           free(scan)       scan <- nextObject(scan)  atomic collect():     markFromRoots()     sweep(HeapStart,HeapEnd) ```   ### 开发过程中遇到的内存泄露情况  #### 1. 定义和用法  内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。  *`C#` 和 `Java` 等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。*  我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有 `bug`，会产生内存泄露。     由于每次的垃圾回收开销都相对较大，并且由于机制的一些不完善的地方，可能会导致内存泄露。我们可以利用一些方法减少垃圾回收，并且**尽量避免循环引用**的问题。  - 例如，在对象结束使用后，令 `obj = null`（这样利于解除循环引用，使得无用变量及时被回收）。  - 再如，JS 中开辟空间的操作有 `new()`、`[]`、`{}`、`function (){..}`，在创建新对象的时候要尽量考虑增大对象的**复用性**。  #### 2. 内存泄漏的几种情况 虽然有垃圾回收机制，但是，我们编写代码操作不当还是会造成内存泄漏。  1. 意外的全局变量引起的内存泄漏。     ```     原因：全局变量，不会被回收。     解决：使用严格模式避免。     ```  2. 闭包引起的内存泄漏。     ```     原因：闭包可以维持函数内局部变量，使其得不到释放。     解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对 dom 的引用。     ``` 3. 没有清理的 `DOM` 元素引用。     ```     原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用。     解决：手动删除。     ```  4. 被遗忘的定时器或者回调。     ```     原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。     解决：手动删除定时器和 dom。     ```  5. 子元素存在引用引起的内存泄漏。     ```     原因：造成父元素间接引用子元素，即使子元素被清空，也还是在内存中。     解决：手动删除清空。     ```     2、内存泄露的几种情况:  虽然有垃圾回收机制，但是，我们编写代码操作不当还是会造成内存泄漏。  1.    意外的全局变量引起的内存泄漏。  原因：全局变量，不会被回收。  解决：使用严格模式避免。  2.    闭包引起的内存泄漏  原因：闭包可以维持函数内局部变量，使其得不到释放。  解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。  3.    没有清理的DOM元素引用  原因：虽然别的地方删除了，但是对象中还存在对dom的引用  解决：手动删除。  4.    被遗忘的定时器或者回调  原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。  解决：手动删除定时器和dom。  5.    子元素存在引用引起的内存泄漏  原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。  解决：手动删除清空。   ## 10. 浏览器采用的缓存方案，如何选择和控制合适的缓存方案。"},{title:"编译原理",path:"/posts/Chapter3/",strippedContent:' ## 1. 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序？ ## 2. 正则表达式的匹配原理和性能优化。 ## 3. 如何将JavaScript代码解析成抽象语法树(AST)。  https://juejin.im/post/5d84ae08e51d4561a705bbde       ## 4. base64 的编码原理。 ## 5. 几种进制的相互转换计算方法，在JavaScript 中如何表示和转换。      # 从 Object.defineProperty 到 Proxy 深入 Vue3.0 新的响应系统  > 最近被公众号各种推送关于 Vue 3 的文章（真是不想学都不行啊），因为现在 Vue 还处于 pre-alpha 状态，所以很多功能尚未实现（这就意味着源码量相对较少，阅读起来也相对比较容易）。此次版本中的重大改进之一是全新的响应式系统 - 基于 Proxy 的变更检测。由于在项目中几乎没有使用过 Proxy，出于盲区的补漏，就写下了这篇文章，才疏学浅，如有纰漏，欢迎指正。  ## 新版本前瞻  10 月 5 日，尤雨溪在 GitHub 开放了 [Vue 3.0](https://github.com/vuejs/vue-next) 处于 pre-alpha 状态的源码，这次 [Vue 3.0 Updates](https://www.oschina.net/news/101906/vue-3-0-updates) 版本的更新，将带来五项重大改进： 1. 速度 2. 体积 3. 可维护性 4. 面向原生 5. 易用性  截止目前，Vue 3.0 主要的架构改进、优化和新功能均已完成，剩下的主要任务是完成一些 Vue 2 现有功能的移植。  ![vue 3](https://qiniu.mdnice.com/8d3fa66d7d9b429cf9c01dc0f5782d8a.png)  结合目前的 [RFCs](https://github.com/vuejs/rfcs/pulls) 和已经完成的改进，可以窥探到 Vue 3.0 将带来： - 模块化架构，支持 tree-shaking。 - API 暴露为函数。 - Composition API + Options API。 - 基于 Proxy 的变更检测。 - 支持 Fragments。 - 支持 Portals。 - 支持 Suspense w/ async setup()。 - 全局挂载/配置 API 更改（createApp().mount(...)）。  - Component v-model API 更改。 - Custom Directive API 更改。 - 函数组件和异步组件 API 更改。 - Render 函数 API 更改。 - ...  看了这么多的改进和新功能的介绍，新版本到底会给性能带来多大的提升，真的很值得期待。   ## 全新的变更检测  Vue 2 中响应系统是基于 `Object.defineProperty` 的，递归遍历 data 对象上的所有属性，将其转换为 getter/setter，当 setter 触发时，通知 watcher，来进行变更检测的。  ![data](https://qiniu.mdnice.com/c39fd3458c7a09dd9425d5ebf9f9821b.png)   这种变更检测机制存在一个限制，那就是 **Vue 无法检测到对象属性的添加或删除**。为此我们需要使用 `Vue.set` 和 `Vue.delete` 来保证响应系统的运行符合预期。  ```js // vue 2 Vue.set(vm.state, \'name\', \'vue 2\');  // vue 3 this.state.name = \'vue 3\'; ``` Vue 3 进行了全新改进，使用 Proxy 代理的作为全新的变更检测，不再使用 `Object.defineProperty`。  使用代理的好处是，对目标对象 `target` 架设了一层拦截，可以对外界的访问进行过滤和改写，不用再递归遍历对象的所有属性并进行 `getter/setter` 转换操作，这使得组件更快的初始化，运行时的性能上将得到极大的改进，据测试新版本的 Vue 比之前 速度快了 `2` 倍（非常夸张）。    ![image](https://qiniu.mdnice.com/44c761ffc1d2b500a7116ff92f0b6446.png)   ### 从 Proxy 代理开始  由于 Vue 3 的变更检测是基于 Proxy 代理的，所以有必要熟知 Proxy 具有哪些特性和它能解决什么问题。  #### 背景 JavaScript 运行环境包含了一些不可枚举、不可写入的对象属性，然而在 ES5 之前开发者无法定义他们自己的不可枚举属性或不可写入属性。ES5 引入 `Object.defineProperty()` 方法以便开发者在这方面能够像 JS 引擎那样做。  ES6 为了让开发者能进一步接近 JS 引擎的能力，推出了 Proxy，代理是一种封装，能够拦截并改变 JS 引擎的底层操作。简单的说，就是在目标对象上架设一层 `“拦截”`，外界对该对象的访问，都必须先通过这层拦截，提供了一种改变 JS 引擎过滤和改写的能力。 ```js let target = {}; let proxy = new Proxy(target, {   get: function(target, property) {     return 35;   } });  proxy.time // 35 proxy.name // 35 proxy.title // 35 ``` #### 代理的创建  通过调用 `new Proxy()` 来创建一个代理时，需要传递两个参数：目标对象 `target` 以及一个处理器 `handler`，`handler` 是一个对象，可以定义一个或多个陷阱函数 **（能够响应特定操作的函数）**，来定制拦截行为。  *如果未提供陷阱函数，代理会对所有操作采取默认行为。* ```js let target = {};  let proxy = new Proxy(target, {});  proxy.name = "proxy"; console.log(proxy.name); // "proxy" console.log(target.name); // "proxy"  target.name = "target"; console.log(proxy.name); // "target" console.log(target.name); // "target" ```  **代理对目标对象进行了虚拟化，因此该代理与该目标对象 `taeget` 表面上可以被当作同一个对象来对待。**  #### 陷阱函数  每个陷阱函数都可以重写 JS 对象的一个特定内置行为，允许你拦截并修改它。  *如果仍然需要使用原先的内置行为，则可使用对应的反射 `Reflect` 接口方法，一旦创建了代理，你就能清晰了解代理与反射接口之间的关系。*  每个陷阱函数都有一个对应的反射方法，每个方法都与对应的陷阱函数同名，并且接收的参数也与之一致。（反射不是本文的重点）  |陷阱函数 |被重写的行为 |默认行为| |-------|----------|-------| |get|读取一个属性的值|Reflect.get()| |set|写入一个属性  | Reflect.set()| |has|in 运算符| Reflect.has()| |deleteProperty |delete 运算符 | Reflect.deleteProperty()| |getPrototypeOf| Object.getPrototypeOf()| Reflect.getPrototypeOf()| |setPrototypeOf |Object.setPrototypeOf() |Reflect.setPrototypeOf()| |isExtensible| Object.isExtensible() |Reflect.isExtensible()| |preventExtensions| Object.preventExtensions()| Reflect.preventExtensions()| |getOwnPropertyDescriptor |Object.getOwnPropertyDescriptor()| Reflect.getOwnPropertyDescriptor()| |defineProperty |Object.defineProperty()| Reflect.defineProperty| |ownKeys|Object.keys、Object.getOwnPropertyNames() 与 Object.getOwnPropertySymbols()| Reflect.ownKeys()| |apply |调用一个函数|Reflect.apply()| |construct |使用 new 调用一个函数|Reflect.construct()|  #### 陷阱函数 set 假设你想要创建一个对象，并要求其属性值只能是数值，这就意味着该对象的每个新增属性 都要被验证，并且在属性值不为数值类型时应当抛出错误。为此你需要定义 set 陷阱函数来 重写设置属性值时的默认行为，该陷阱函数能接受四个参数：  1. trapTarget ：将接收属性的对象（即代理的目标对象）； 2. key ：需要写入的属性的键（字符串类型或符号类型）； 3. value ：将被写入属性的值； 4. receiver ：操作发生的对象（通常是代理对象）。 Reflect.set() 是 set 陷阱函数对应的反射方法，同时也是 set 操作的默认行为。 Reflect.set() 方法与 set 陷阱函数一样，能接受这四个参数，让该方法能在陷阱函数内部 被方便使用。该陷阱函数需要在属性被设置完成的情况下返回 true ，否则就要返回 false ，而 Reflect.set() 也会基于操作是否成功而返回相应的结果。 你需要使用 set 陷阱函数来拦截传入的 value 值，以便对属性值进行验证。这里有个例 子： ```js let target = { name: "target" };  let proxy = new Proxy(target, { set(trapTarget, key, value, receiver) {  // 忽略已有属性，避免影响它们 if (!trapTarget.hasOwnProperty(key)) { if (isNaN(value)) { throw new TypeError("Property must be a number."); } }  // 添加属性 return Reflect.set(trapTarget, key, value, receiver); } });  // 添加一个新属性 proxy.count = 1; console.log(proxy.count); // 1 console.log(target.count); // 1  // 你可以为 name 赋一个非数值类型的值，因为该属性已经存在 proxy.name = "proxy"; console.log(proxy.name); // "proxy" console.log(target.name); // "proxy"  // 抛出错误 proxy.anotherName = "proxy"; ```            ### 创建响应式数据  Vue 3.0 创建响应式数据可以有三种方法：  1. `data` 选项（ 兼容 2.x ）。 2. `reactive API`。 3. `ref API`。  #### data 选项 ```html // 根组件 <template>   <div id="app">     <div>{{ name }}</div>   </div> </template> <script> import { createApp } from Vue; export default { const App = {   data: {     name: \'Vue 3\',   \t// count: ref(0)    } } createApp().mount(App, \'#app\') <\/script> ```  `data` 选项定义的数据，最终也会被 `reactive` 转换为响应式的 `Proxy` 代理。 ```js  // runtime-core > src > apiOptions.ts instance.data = reactive(data) ```  #### reactive 函数 返回原始对象的响应式 `Proxy` 代理（ 同 2.x 的 Vue.observate() ）。  ```html <template>   <div>{{ state.name }}</div> </template>  <script> import { reactive } from Vue; export default {   setup() {     const state = reactive({       name: "Vue 3"     })     return {       state     }   } } <\/script> ``` `reactive()` 函数最终返回一个可观察的响应式 `Proxy` 代理。  ```js // reactivity > src > reactive.ts reactive(target) => observed => new Proxy(target, handlers) ```  #### ref 函数  获取一个内部值并返回一个响应式的可变 `ref` 对象。  ```html <template>   <div>{{ name }}</div> </template>  <script> import { ref } from Vue; export default {   setup() {     return {       name: ref(\'Vue 3\')     }   } } <\/script> ```  `ref` 对象有一个指向内部值的单个属性 `.value`。如果将一个值分配为 `ref` 对象，则 `reactive()` 方法会使该对象具有高度的响应性。 ```js ... const r = {   _isRef: true,   get value() {       track(r, "get" /* GET */, \'value\');       return raw;   },   set value(newVal) {       raw = convert(newVal);       // trigger 方法扮演通信员的角色，贯穿整个响应系统，使得 ref 具有高度的响应性       trigger(r, "set" /* SET */, \'value\',  { newValue: newVal } );   } };  return r ... ``` 因此，无需在模版中追加 `.value`。 ```js const count = ref(0) console.log(count.value) // 0  count.value++ console.log(count.value) // 1 ```              '},{title:"HTML汇总",path:"/posts/Chapter2/html.html",strippedContent:' ## 1. 从规范的角度理解 HTML，从分类和语义的角度使用标签。  ## 2. 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式。  ## 3. 元信息类标签（head、title、meta）的使用目的和配置方法。  ## 4. HTML5 离线缓存原理。  使用 `HTML5` 通过创建 `cache manifest` 文件，可以轻松地创建 web 应用的离线版本。  ### 什么是应用程序缓存（Application Cache）？  `HTML5` 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。  **应用程序缓存为应用带来三个优势：**  - 离线浏览 - 用户可在应用离线时使用它们。 - 速度 - 已缓存资源加载得更快。 - 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。    ### Cache Manifest 基础  如需启用应用程序缓存，请在文档的 `<html>` 标签中包含 `manifest` 属性：  ```html <!DOCTYPE HTML> <html manifest="demo.appcache"> ... </html> ``` 每个指定了 `manifest` 的页面在用户对其访问时都会被缓存。如果未指定 `manifest` 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。  **manifest 文件的建议的文件扩展名是：`.appcache`。**  ***请注意，`manifest` 文件需要配置正确的 `MIME-type`，即 `"text/cache-manifest"`。必须在 web 服务器上进行配置。***   ### Manifest 文件  `manifest` 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）它分为三个部分：  - **CACHE MANIFEST** - 在此标题下列出的文件将在首次下载后进行缓存。  - **NETWORK** - 在此标题下列出的文件需要与服务器的连接，且不会被缓存。  - **FALLBACK** - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）。  #### CACHE MANIFEST 第一行 `CACHE MANIFEST`，是必需的。  ``` CACHE MANIFEST /theme.css /logo.gif /main.js ``` 无论用户何时与因特网断开连接，`CACHE MANIFEST` 下列出的资源依然是可用的。  #### NETWORK 下面的 `NETWORK` 字段规定文件 `login.php` 永远不会被缓存，且离线时是不可用的。  ``` NETWORK: login.php ``` 可以使用星号来指示所有其他资源/文件都需要因特网连接。 ``` NETWORK: * ``` #### FALLBACK  下面的 `FALLBACK` 字段规定如果无法建立因特网连接，则用 `offline.html` 替代 `/html5/` 目录中的所有文件。  ``` FALLBACK: /html/ /offline.html ``` ***注意: 第一个 URI 是资源，第二个是替补。***  #### 完整的 Manifest 文件 ```appcache CACHE MANIFEST # 2012-02-21 v1.0.0  /theme.css /logo.gif /main.js  NETWORK: login.php  FALLBACK: /html/ /offline.html ```  ***注意：浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。***  参考：[https://www.runoob.com/html/html5-app-cache.html](https://www.runoob.com/html/html5-app-cache.html)  ## 5. 可以使用 Canvas API、SVG 等绘制高性能的动画。 '},{title:"水平垂直居中方案",path:"/posts/Chapter2/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html",strippedContent:' ## 元素水平垂直居中的方案、可以实现 6 种以上并对比它们的优缺点。  <img alt="元素居中" width="30%" src="http://qiniu.mdnice.com/164c36b8b16a017a344a634667b05eb8.png">  ### 1. 绝对定位 transform 变形 （不定宽高）  *IE8 不支持*  采用 `transform: translate(-50%, -50%)` ，父元素设置相对定位 `position: relative`。  ```css body {     position: relative; } div {     position: absolute;     left: 50%;     top: 50%;     transform: translate(-50%, -50%);     background: red; } ```   ### 2. 弹性盒模型 （不定宽高）  *兼容性不好，主要应用与移动端*  当前 `div` 父级设置 `display: flex; align-items: center; justify-content: center;` 。  ```css body {     display: flex;     align-items: center;     justify-content: center; } div {     background: red; } ```  ### 3. table-cell 单元格布局（不定宽高）  *不常用*  此方法是`内联块状元素`水平垂直剧中的解决方案。  将父元素设置 `dispaly: table-cell;` 转换成表格单元格。  ```css  body {     display: table-cell;     vertical-align: middle;     text-align: center;     width: 400px;     height: 400px;     border:1px solid #666; } div {     dispaly: inline-block;     background: red; } ```  ### 4. 绝对定位 margin 负间距（定宽高）  *比较流行的解决方案*  将 `margin-left` 和 `margin-top` 的值为当前 `div` 宽度的一半的负值。  ```css div {     width: 100px;     height: 100px;     position: absolute;     left: 50%;     top: 50%;     margin-left: -50px;     margin-top: -50px;     background: red; } ``` ### 5. 绝对定位 margin：auto（定宽高）  *不确定宽高时，会充满整个屏幕。*  设置绝对定位属性 `position: absolute`， `left`、`top`、`right`、`bottom` 值均为 `0`， `margin` 值为 `auto`。  ```css div {     width: 100px;     height: 100px;     position: absolute;     left: 0;     top: 0;     right: 0;     bottom: 0;     margin: auto;     background: red; } ```  ### 6. 绝对定位 和 salc() （定宽高）  *IE 8 不支持*  `calc()` 函数动态计算实现水平垂直剧中。  ```css body {     position: relative;     width: 100%;     height: 100%; } div {     position: absolute;     width: 200px;     height: 50px;     left: calc((100% - 200px)/2);     top: calc((100% - 50px)/2);     background: red; }　　 ```  ### 总结 ```js 不宽高： 1. absolute + transform 变形 2. flex 布局  3. table-cell 布局 （不常用）  定宽高： 1. absolute + margin 负间距离 （常用） 2. absolute + margin auto 3. absolute + calc() 函数 ``` '},{title:"CSS伪类和伪元素",path:"/posts/Chapter2/css%E4%BC%AA%E7%B1%BB.html",strippedContent:' ## CSS 伪类和伪元素有哪些，它们的区别和实际应用。  ### CSS 伪类  CSS 伪元素是用来对一些选择器添加特殊效果。  - **:link**：     用于设置未被访问的链接的样式。  - **:visited**：  用于设置已经被访问的链接的样式。  - **:hover**：    用于设置将鼠标悬浮在链接上的样式。  - **:active**：   用于设置鼠标点击链接时到鼠标松开时的样式。  - **:focus**：    用于设置用键盘将焦点放在链接上时的样式（如用tab键或者上下键来移动页面焦点时）。   - **:first-child**：选中列表中的第一个元素。  - **:last-child**：选中列表中的最后一个元素。  - **:nth-child()**：括号里面的取值可以为三类。 \t```js     1. 数字： :nth-child(3) 表示选中父元素的第三个子元素。 \t2. 自变量为 n 的表达式： :nth-child(3n) 代表选中父元素的第3 6 9 .. 3n 的子元素。 \t3. even 或者 odd： 分别代表选中父元素的奇数或者偶数个子元素。     ``` - **:nth-last-child()**：与 `:nth-child()` 的不同点在于，这个是从最后一个元素开始计算，取值都是一样的。   - **:not(name)**：除了 `name` 以外的元素。  ####CSS 伪元素  CSS 伪元素是用来对一些选择器添加特殊效果。  *CSS 伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称为伪元素。*  <img width="60%" alt="css伪元素" src="http://qiniu.mdnice.com/50ff5d10c5a8a83731a2fb8638171a09.png">  1. **::first-letter**：用于向文本的首字母设置特殊样式。  2. **::first-line**：用于向文本的首行设置特殊样式。  3. **::before**：可以向元素内容的前面插入新内容。  4. **::after**：可以向元素内容的后面插入新内容。  5. **::selection**  6. **::placeholder**  7. **::backdrop**   ### 伪类和伪元素的区别  1. 为了避免混淆，`css3` 中的标准规定伪类使用单冒号 `:` ，伪元素使用双冒号 `::`，为了保证兼容伪元素两种使用方法都是可以的。  2. 伪类可以叠加使用，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。     ```css     .content:first-child:hover { color: #fff;}   //使用伪类     .content:first-letter { color: #fff;}   //使用伪元素     .conrent:first-letter:hover { color: #fff;}   //错误写法      ```  3. 伪类和类的优先级相同，伪元素和元素的优先级相同。   '},{title:"BFC 实现原理",path:"/posts/Chapter2/bfc.html",strippedContent:' ## BFC 实现原理，可以解决的问题，如何创建 BFC。  **BFC** 即 `Block Formatting Contexts`（块级格式上下文），它的布局模式为`流动模型`，是一个独立的渲染区域。 `BFC` 决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。  **具有 `BFC` 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。**  ### BFC 的生成  - `body` 根元素。 - `float` 的值不为 `none`。 - `overflow` 的值不为 `visible`。 - `display`的值为`inline-block`、`table-cell`、`table-caption`。 - `position` 的值为 `absolute`、`fiexd`。  ### BFC 解决的问题  #### 1. 阻止 margin 重叠（margin 塌陷问题）  在标准文档流中，块级元素之间竖直方向的 `margin` 会以大的为准，这就会导致 `margin` 重叠（塌陷）问题。  ```html <body>     <p></p>     <p></p> </body> <style>     p {         width: 100px;         height: 100px;         background: rgb(19, 149, 192);         margin: 50px;     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/2e633e8c5ac02c1678493bb5a2bec7bb.png">  **解决 margin 塌陷问题：将其放在不同的 `BFC` 容器中来解决，设置 `overflow: hidden;`。**  ```html <body>     <div>         <p></p>     </div>     <p></p> </body> <style>     div {         overflow: hidden;     }     p {         width: 100px;         height: 100px;         background: rgb(19, 149, 192);         margin: 50px;     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/5096d81caa2cc88fc31c09a13ce8e1c7.png">   #### 2. 高度塌陷问题  在通常情况下，父元素的高度会被子元素撑开，而将其子元素设置为浮动元素时，子元素就会脱离文档流，父元素就会发生高度塌陷问题，上下边界重回。  ```html <div style="border: 1px solid #333;">     <div class="child"></div> </div> <style>       div.child {         float: left;         width: 100px;         height: 100px;         background: rgb(19, 149, 192);     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/17fa72870ee407c086d9e2e6c35e31e9.png">  **解决高度塌陷问题：设置 `overflow: hidden;` 将父元素变成 BFC 容器。**  ```js BFC约束准则：计算 BFC 容器的高度时，浮动元素也参与计算。 ``` ```html <div style="border: 1px solid #333; overflow: hidden;">     <div class="child"></div> </div> <style>       div.child {         float: left;         width: 100px;         height: 100px;         background: rgb(19, 149, 192);     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/dd9bdf163c040175aa5beb718ae9466b.png">  #### 3. 阻止元素被浮动元素覆盖  由于左侧块级元素发生了浮动脱离了文档流，和右侧未发生浮动的块级元素不在同一层内，所以会发生 `div` 遮挡问题。  ```html <div class="contanier">     <div>左浮动的元素</div>     <div>没有触发 BFC 的元素</div> </div> <style>     .contanier div:nth-child(1) {         float: left;         height: 100px;         width: 100px;         background: rgb(27, 178, 228);     }     .contanier div:nth-child(2) {         width: 200px;          height: 200px;         background: rgb(248, 234, 172);     } </style> ```  <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/f12e54cdeafe5eeedfe1fa3d67683109.png">  **解决元素被这遮挡问题：给右侧元素设置 `overflow: hidden;` 触发 `BFC` 来解决。**  ```js BFC 约束准则：BFC 的区域不会与浮动的元素区域重叠。 ``` ```html <div class="contanier">     <div>左浮动的元素</div>     <div>触发 BFC 的元素</div> </div> <style>     .contanier div:nth-child(1) {         float: left;         height: 100px;         width: 100px;         background: rgb(27, 178, 228);     }     .contanier div:nth-child(2) {         width: 200px;          height: 200px;         overflow: hidden;         background: rgb(248, 234, 172);     } </style> ``` <img alt="bfc" width="60%" src="http://qiniu.mdnice.com/47d7e0fb31a734bb5bee749cc75ad50c.png">  ### 总结  ```js 1. 内部的块元素会在垂直方向上一个接一个的放置。 2. 属于同一个 BFC 的两个相邻块元素的 margin 会发生重叠（重叠）。 3. 计算BFC的高度时，浮动子元素也参与计算。（解决高度塌陷问题）。 4. BFC 容器不会与 float 的元素区域重叠。（解决浮动元素遮挡问题）。 5. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。 ``` '},{title:"Vue组件通信",path:"/posts/Chapter6/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",strippedContent:' ## Vue 组件间通信方法汇总  ### 父组件向子组件传值   #### 1. 通过属性传值 props   `props` 可以是数组或对象，用于接收来自父组件的数据。  ```js // 父组件 List.vue <template>   <div>     <List-item :str="str" :obj="obj" :arr="arr"></List-item>   </div> </template> <script> import ListItem from "./ListItem"; export default {   data() {     return {       str: "给子组件传值",       obj: {msg: "给子组件传值"},       arr: [1, 2, 3]     }   },   components: {     ListItem   } } <\/script>  // 子组件 ListItem.vue <template>   <div>     <div>{{msg}}</div>     <div>{{obj}}</div>     <div>{{arr}}</div>   </div> </template> <script> export default {   props: {     msg: String, // props是字符串     obj: Object, // props是对象     arr: Array   // props是数组   } } <\/script> ``` **子组件渲染结果：**  ![父子组件通信](http://qiniu.mdnice.com/7ad4bf7bc983458d7a903befd7a33fe6.png)   #### 2. 使用修饰符 `.sync`  修饰符 [.sync](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6) 是 `2.3.0+` 新增，它对 `props` 起到了一种修饰的作用，使用 `.sync` 进行修饰的 `props` 意味子组件有修改它的意图，这种情况下它只起到一个标注性作用，有它没它都不会影响逻辑（后文会介绍使用 .sync 的其他作用）。  使用 `.sync` 修改上边的代码：  ```js // 父组件 List.vue <template>   \x3c!-- 这里不写 .sync 也不会影响结果 --\x3e   <List-item :title.sync="title" @update:title="updataTitle"></List-item> </template> <script> import ListItem from "./ListItem"; export default {   data() {     return {       title: "我是title",     }   },   components: {     ListItem   },   methods: {    updataTitle(res) {     this.title = res;    }   } } <\/script>  // 子组件 ListItem.vue <template>   <div>     <button @click="handleClick">Click me</button>     <div>{{title}}</div>   </div> </template> <script> export default {   props: {     title: String,    },   methods: {    handleClick() {     // 子组件向父组件传值     this.$emit(\'update:title\', \'我要父组件更新 title\');    }   } } <\/script> ```  <img width="30%" src="https://i.loli.net/2019/10/24/wi87HNTJLsDdOIf.png" alt="props"> <img width="50%" src="http://qiniu.mdnice.com/78ce8a9205e20962af4300138ce62b24.png" alt="props">   **使用`.sync` 向子组件传递 多个props：**  当我们用一个对象同时设置多个 `prop` 的时候，也可以将这个 `.sync` 修饰符和 `v-bind` 配合使用： ```js <text-document v-bind.sync="doc"></text-document> ```  这样会把 `doc` 对象中的每一个属性 (如 title) 都作为一个独立的 `prop` 传进去，然后各自添加用于更新的 `v-on 监听器。  更多介绍，[.sync](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6) 。  #### 3. 通过 $parent 获取父组件实例的方法或者属性  这种方式，从严格意思上讲不是值的传递，而是一种"取"（不推荐直接通过实例进行值的获取）。  可以通过 Vue 的[实例属性](https://cn.vuejs.org/v2/api/#vm-parent) `$parent` 获得父组件的实例，借助实例可以调用父实例中的方法，或者获取父实例上的属性，从而达到取值的目的。   <img width="80%" src="http://qiniu.mdnice.com/103331d17ba700350a5e60a48773b837.jpeg" alt="$parent">  ```js // 父组件 List.vue ... <script> export default {   data() {     return {       message: "hello children",       msg: "hello"     }   },   methods: {     sendMessage() {       return this.message;     }   } } <\/script>  // 子组件 ListItem.vue <template>   <div>     <div>{{data}}</div>     <div>{{msg}}</div>   </div> </template> <script> export default {   data() {     return {       data: "",       msg: ""     }   },   mounted() {     this.data = this.$parent.sendMessage(); // 调用父实例中的方法     this.msg = this.$parent.msg; // 获取父实例中的属性   } } <\/script> ``` **拓展**  子组件调用父组件中的方法：  - 通过 `$parent` 获取父实例 `this.$parent.event`。  - 通过 通过 `props` 传递方法。  - 通过 `$emit` 监听父组件中的方法 `this.$emit("envnt")`。   ### 子组件向父组件传值   #### 1. 通过事件传值 $emit  - 子组件使用 `$emit` 发送一个自定义事件，事件名称是一个字符串。 - 父组件使用指令 `v-on` 绑定子组件发送的自定义事件。  ```js // 父组件 List.vue <template>   <div>     \x3c!-- 监听自定义事件 --\x3e     <List-item v-on:welcome="getWelcome"></List-item>   </div> </template> <script> import ListItem from "./List-item"; export default {   components: {     ListItem   },   methods: {     getWelcome(data) {       alert(data)     }   } } <\/script>  // 子组件 ListItem.vue <template>   <button @click="handleClick">Click me</button> </template> <script> export default {   methods: {     handleClick() {    // 使用 $emit 发送自定义事件 welcome       this.$emit(\'welcome\', \'hello\');     }   } } <\/script> ```  ![image](http://qiniu.mdnice.com/66401cecb6a809c6c5527c855c4f45f9.png)  #### 2. 通过 $children 获取子组件实例  此方式同 `$parent`，这里就不进行介绍了。  #### 3. 通过 ref 注册子组件引用  尽管存在 `prop` 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，可以通过 `ref` 特性为这个子组件赋予一个 ID 引用。  ```js <template>   <div>     <List-item ref="item" :title="title"></List-item>     <div>{{data}}</div>   </div> </template> <script> import ListItem from "./List-item"; export default {   data() {     return {       title: "我是title",       data: ""     }   },   components: {     ListItem   },   mounted() {     this.data = this.$refs.item.message;   } } <\/script> ``` [更多 ref 用法](https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0)。  ### 兄弟组件传值  #### 1. Bus 中央事件总线  非父子组件传值，可以使用一个空的 Vue 实例作为中央事件总线，结合[实例方法](https://cn.vuejs.org/v2/api/?#vm-on) `$on` 和 `$emit` 完成传值操作。  **Bus 的定义方式有以下三种：**  1. 将 `Bus` 抽离出来，组件有需要时进行引入。     ```js     // Bus.js     import Vue from \'vue\'     const Bus = new Vue()     export default Bus     ``` 2. 将 `Bus` 挂载到 Vue 根实例的原型上。     ```js     import Vue from \'vue\'     Vue.prototype.$bus = new Vue();     ``` 3. 将 `Bus` 注入到 Vue 根对象上。     ```js     import Vue from \'vue\'     const Bus = new Vue()     new Vue({       el:\'#app\',       data: {         Bus       }　　     })     ```  **下面案例中的 `Bus` 挂载在 Vue 原型上：**  ```js // 组件1 使用 $emit 向外部发布自定义事件 <template>   <button @click="handleClick"> Send Message</button> </template> <script> export default {   data() {     return {       message: "给兄弟组件传值",     }   },   methods: {     handleClick() {       this.$Bus.$emit("sendMessage", this.message)     }   } } <\/script>  // 组件2 使用 $on 订阅外部发布的事件 <template>   <div>     {{data}}   </div> </template> <script> export default {   data() {     return {       data: "",     }   },   mounted() {     this.$Bus.$on("sendMessage", data => {       this.data = data;     })   } } <\/script> ``` **注意：注册的 `Bus` 要在组件销毁时卸载，否则会多次挂载，造成触发一次但多个响应的情况。** ```js beforeDestroy () {   this.$Bus.$off(\'sendMessage\', this.message); } ``` #### 2. Vuex 状态管理器  Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。  <img src="https://vuex.vuejs.org/vuex.png" alt="vuex"/>  Vuex 的[具体使用](https://vuex.vuejs.org/zh/)。   #### 3. 通过父组件进行过渡  *不是方法的方法：*  1. 子组件 `A` 通过事件 `$emit` 传值传给父组件。  2. 父组件通过属性 `props` 传值给子组件 `B`。  ### 深层次嵌套组件传值  #### 1. 依赖注入 provide/inject  `provide` 选项允许我们指定我们想要提供给后代组件的数据/方法。  ```js provide: function () {   return {     getMap: this.getMap   } } ```  然后在任何后代组件里，我们都可以使用 `inject` 选项来接收指定的我们想要添加在这个实例上的属性：  ```js inject: [\'getMap\'] ```  ***`provide` 和 `inject` 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。***  ```js // 父级组件提供 \'foo\' var Provider = {   provide: {     foo: \'bar\'   },   // ... }  // 子组件注入 \'foo\' var Child = {   inject: [\'foo\'],   created () {     console.log(this.foo) // => "bar"   }   // ... } ```  >然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root 做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。  ---  #### 2. $attrs/inheritAttrs  这个两个属性是 `2.4` 新增的特性。  **$attrs：**   **官网介绍的很累赘，可以理解为非 `props` 属性集合。**[更多介绍](https://cn.vuejs.org/v2/api/?#inheritAttrs)。  当一个组件中没有声明任何 prop 时，`this.$attrs` 可以获取到所有父作用域的属性绑定 (class 和 style 除外)，并且可以通过 `v-bind="$attrs"` 传给其内部组件 —— 在创建高级别的组件时非常有用。  **inheritAttrs：**   控制元素属性是否显示在 dom 上，默认值为 `true`。  >默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。   **祖先组件：** ```html <template>   <div>     <List-item :title="title" :message="message"></List-item>   </div> </template> <script> import ListItem from "./List-item"; export default {   data() {     return {       title: "我是title",       message: "传给后代"     }   },   components: {     ListItem   } } <\/script> ```  **父组件：** ```html <template>   <div>     <h1>{{title}}</h1>     <h2>{{$attrs.message}}</h2>     \x3c!-- 通过 v-bind="$attrs" 传入后代组件--\x3e     <ListItem2 v-bind=\'$attrs\'></ListItem2>   </div> </template> <script> import ListItem2 from \'./List-item2\' export default {   props: {     title: String   },   components: {     ListItem2   },   // 默认为 true，如果传入的属性子组件没有 prop 接受，就会以字符串的形式作为标签的属性存在 <div message="传给后代"></div>   // 设为 false，在 dom 中就看不到这些属性 <div>...</div>   inheritAttrs: false } <\/script> ```  **后代组件：** ```html <template>   <div>     {{$attrs.message}}   </div> </template> <script> export default {   mounted() {     console.log(this.$attrs)\t// {message: "传给后代"}   } } <\/script> ``` **渲染出来的结果为：**  <img width="50%" src="http://qiniu.mdnice.com/c78bfa9a349c4b3f46096b878e0fb129.png" alt="$attrs/inheritAttrs">  ### 插槽 slot 与子组件传值  在实际项目中确实有遇到插槽 *`后备内容`* 动态显示的情况，所以这里要补充一下插槽 *`后备内容`* 是如何与子组件进行通信的。  **插槽后备内容是指：写在父组件中，包含在子组件标签里的，与子组件中的 `slot` 对应。**  ```html <template>   <child-component>     我是插槽的后备内容   </child-component> </template> ```  比如这里有一个含有 `slot` 的 `current-user` 组件，它的模版结构是这样的： ```html \x3c!-- 子组件 current-user.vue --\x3e <template>   <div>     <div>current-user组件</div>     <slot>插槽里默认显示：{{user.firstName}}</slot>   </div> </template>  <script> export default {   data() {     return {       user: {         firstName: "zhao",         lastName: "xinglei"       }     }   } } <\/script> ``` 它的父组件是这样的：  ```html \x3c!-- 父组件 Users.vue --\x3e <template>   <div>     <div>我是Users组件</div>     <current-user>       我是插槽里的后备内容： {{user.lastName}}（我想显示为子组件中 user.lastName ）     </current-user>   </div> </template>  <script> import CurrentUser from \'./Current-User.vue\' export default {   components: {     CurrentUser   } } <\/script> ```  我们看到，在父组件 `Users` 中，为子组件 `current-user` 提供的后备内容中，想要显示子组件定义的 `user.firstName` 是不能做到的。  官网中提供一个指令 [v-slot](https://cn.vuejs.org/v2/guide/components-slots.html)，它与 `props` 结合使用从而达到插槽后备内容与子组件通信的目的。  我们首先需要在子组件的 `slot` 中传递一个 `props`（这个`props` 叫做插槽props），这里我们起名叫 `user`：  ```html \x3c!-- 子组件 current-user.vue --\x3e <template>   <div>     <div>current-user组件</div>     <slot :user="user">       插槽里默认显示：{{user.firstName}}     </slot>   </div> </template> ```  在父组件中，包含插槽后备内容的子组件标签上我们绑定一个 `v-slot` 指令，像这样： ```html <template>   <div>     <div>我是Users组件</div>     \x3c!-- slotProps里的内容就是子组件传递过来的 props --\x3e     \x3c!-- "user": { "firstName": "zhao", "lastName": "xinglei" } --\x3e     <current-user v-slot="slotProps">       {{slotProps}}     </current-user>   </div> </template> ```  最后渲染出来的结果为：  ![作用域插槽](https://qiniu.mdnice.com/19b47dbffd18c928ec122eef6f46f099.png)  官网给这种插槽起名叫做`作用域插槽`，[更多了解](https://cn.vuejs.org/v2/guide/components-slots.html)。     ### 总结  ```js 1. 组件之间传值无非就是通过属性、事件和操作 Vue 实例进行的。 2. 操作实例进行组件件通信，实例属性 $root、$parent、$children 分别对应了根实例、父实例、子实例。 3  ref 子组件引用，在操作表单元素时会应用的到。 4. Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，简单的应用不要使用 Vuex。 5. Vue.observable() 让一个对象可响应，可以作为最小化的跨组件状态存储器（本文未提到）。 ```  '},{title:"CSS选择器",path:"/posts/Chapter2/css%E9%80%89%E6%8B%A9%E5%99%A8.html",strippedContent:' ## CSS 所有选择器及其优先级、使用场景，哪些可以继承，如何运用 @ 规则。  ### CSS 选择器优先级及使用场景  1. 在属性后面使用 `!important`， 权重最高。  2. 内联样式，如 `style=""`，权重 `1000`。  3. `id` 选择器，如 `#header`，权重 `100`。  4. 类、伪类、属性选择器，如 `.header div:last-child input[type="text"]`，权重 `10`。(伪类使用 `:`)  5. 元素、伪元素选择器，如 `div p ::before`，权重 `1`。(伪元素使用`::`)     6. 通配符、子选择器、相邻选择器，如 `*、>、+`，权重 `0`。     7. 继承的样式、浏览器默认的属性，没有权重。   |选择器\t|权重 |----|---- |!important|\t1/0(无穷大) |内联样式|\t1000 |ID|\t100 |类/伪类/属性\t|10 |元素/伪元素|\t1 |通配符/子选择器/相邻选择器|\t0   ```js !important > 内联样式 > ID 选择器 > 类选择器 > 元素选择器 > 通配符（*）选择器 > 浏览器默认属性 ``` ### 继承性  1. 以 `color`、`font-`、`text-`、`line` 开头属性可继承。  2. 只要是后代就可继承。  3. `<a>` 标签文字颜色和下划线无法继承。  4. `<h>` 标签的文字大小无法继承。  ### at 规则介绍  `at`规则由一个 `@` 关键字和后续的一个区块组成，如果没有区块，则以分号结束。  #### @charset  用于提示 `css` 文件使用的字符串编码方式，它如果被使用，必须出现在最前面。  这个规则只是在给出语法解析阶段前使用，并不影响页面上展示效果。  ```css @charset "utf-8" ``` #### @import  用于引入一个 `css` 文件，除 `@charset` 规则不会被引入外，可以引入一个文件的全部内容。  ```css @import "style.css"; @import url("style.css"); ``` #### @ media  对设备类型进行判断，用于媒体查询。  ```css @media screen and (max-width: 600px) {     body {         background: blue;     } } ``` #### @keyframes  `@keyframes` 规则用于定义动画关键帧。创建动画的原理是：将一套 `CSS` 样式逐渐变化为另一套样式。  ```css @keyframes .move {     from: { top: 0px; }     to: { top: 20px; } } ```  #### @fontace `@fontace` 用于定义字体，`iconfont` 技术就是利用这个特性来实现。 ```css @font-face{ \tfont-family: myFirstFont;     src: url(\'Sansation_Light.ttf\')          ,url(\'Sansation_Light.eot\'); /* IE9 */ } div { \tfont-family: myFirstFont; } ```  ####  其他 - **@page**：用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。  - **@counter-style**： 产生一种数据，用于定义列表项的表现。  - **@support**：support 检查环境的特性，它与 `media` 比较类似。  - **@namespace**：用于跟 `xml` 命名空间配合的一个规则，表示内部的 `css` 选择器全都带上特定命名空间。  - **@viewport**：用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 `html`的 `meta` 代替。  - **@color-profile**  - **@document**  - **@font-feature-values** '},{title:"CSS盒模型",path:"/posts/Chapter2/css%E7%9B%92%E6%A8%A1%E5%9E%8B.html",strippedContent:" ## CSS 盒模型，在不同浏览器下的差异。  ### 标准盒模型和怪异盒模型  - **标准盒模型**：宽度只是内容（content）的宽度。      ![1265396-20171119143703656-1332857321.png](https://i.loli.net/2019/09/30/D7Wl59TfMQcdmwG.png)  - **怪异（IE）盒模型**：宽度是内容（content）+ 填充（padding）+ 边框（border）的总宽度。      ![1265396-20171119144229156-49945808.png](https://i.loli.net/2019/09/30/imUEr4skWPlI2dF.png)  ### 设置盒模型 使用 CSS3 新增的属性 `box-sizing` 可以模拟标准盒模型和怪异盒模型。  - **content-box**：默认值，标准盒模型。      ```css     /* 标准模型 */     box-sizing: content-box;     ``` - **border-box**：IE 盒子模型。      ```css     /* IE 盒模型 */     box-sizing: border-box;     ``` - **padding-box**：`padding` 计算入 `width` 内。  ### 注意 ```js ie8+ chrome 浏览器支持 content-box 和 border-box 属性。 Firfox （2-49）支持 padding-box 属性。 IE 浏览器在 getComputedStyle 得到的 width/height 是按照标准模式计算的，而不论 box-sizing 的取值。 ``` "},{title:"三栏布局",path:"/posts/Chapter2/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80.html",strippedContent:' ##  三栏布局有几种实现方式，并说出它们的优缺点。  *三栏布局是指左栏和右栏固定宽度，中间的宽度自适应。三栏布局也被称为圣杯布局或者双飞翼布局。*  ### 1. 浮动布局   ```html <style type="text/css">     .left, .center, .right {         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         float: left;         background: red;     }     .right {         float: right;         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="right"></div>     <div class="center"></div> </body> ```  ### 2. 绝对定位布局   ```html <style type="text/css">     .left, .center, .right {         position: absolute;         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         left: 0;         background: red;     }     .right {         right: 0;         background: blue;     }     .center {         left: 300px;         right: 300px;         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```  ### 3. flex 布局   ```html <style type="text/css">     body {         display: flex;     }     .left, .center, .right {         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         flex: 1;         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```   ### 4. bable-cell 表格布局   ```html <style type="text/css">     body {         display: table;         width: 100%;         height: 200px;     }     .left, .center, .right {         display: table-cell;     }     .left, .right {         width: 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```   ### 5. grid 网格布局   ```html <style type="text/css">     body {         display: grid;         width: 100%;         grid-template-rows: 200px;         grid-template-columns: 300px auto 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```  ### 总结  ```html 1. 浮动布局：兼容性比较好，但是浮动元素脱离了文档流，会造成父容器高度塌陷，需要清除浮动。 2. 绝对定位布局：绝对定位布局快捷，但是有效性比较差，元素脱离了文档流，高度未知的时候会有问题。 3. flex 布局：移动端常用的布局方案，解决了上述两种布局的不足。 4. table-cell 表格布局：兼容性好，但是有时候单元格高度超出的时候，其他单元格的高度也会被撑高；无法设置边距；对SEO不好。 5. grid 网格布局：比较新的二维布局方式，兼容性没那么好。 ``` '},{title:"CSS汇总",path:"/posts/Chapter2/",strippedContent:' ## 1. HTML 文档流的排版规则，CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理。  ### 文档流的排版规则  元素默认从左向右、从上到下进行排列。  标准文章流分为：**块级元素**和**行内元素**。  **块级元素：**独占一行，水平方向不能与其他元素并排显示，可设置宽、高，宽度默认为父级的100%。 **行内元素：**    ## 2. 可使用 CSS 函数复用代码，实现特殊效果。  #### CSS 中的函数： | 函数  | 描述 | CSS 版本 | |----- |-----|-----| |attr()|  返回选择元素的属性值 |  2  |calc()|  允许计算 CSS 的属性值（比如动态计算长度值）| 3 |linear-gradient()| 创建一个线性渐变的图像|  3 |radial-gradient()| 用径向渐变创建图像|  3 |repeating-linear-gradient()  |用重复的线性渐变创建图像|  3 |repeating-radial-gradient()  |类似 radial-gradient()，用重复的径向渐变创建图像| 3   ## 3. PostCSS、Sass、Less 的异同，以及使用配置，至少掌握一种。  https://blog.csdn.net/JoeBlackzqq/article/details/98885880  ## 4. CSS 模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染。  ### 如何防止 CSS 阻塞渲染  通过**媒体类型**和**媒体查询**，设置 `link` 标签的 `media` 属性值，根据特定场景（设备类型、显示、打印、屏幕方向变化、屏幕分辨率等）按需渲染 CSS 资源。  ```html \x3c!-- 屏幕分辨率为 800px 时，渲染 style.css --\x3e <link href="style.css" rel="stylesheet" media="(min-width: 800px)">  \x3c!-- 打印网页或者在打印预览模式下打开时，渲染 print.css  --\x3e <link rel="stylesheet" type="text/css" href="print.css" media="print"/>  \x3c!-- 手持设备（小屏幕、有限带宽）设备时，渲染 handheld.css  --\x3e <link rel="stylesheet" type="text/css" href="handheld.css" media="handheld"/> ``` **注意：**无论哪一种情况，浏览器仍会下载全部 CSS 资源，只不过将不阻塞渲染资源的优先级降低罢了。    ## 5. 熟练使用 CSS 实现常见动画，如渐变、移动、旋转、缩放等等。   ## 6. CSS 浏览器兼容性写法，了解不同 API 在不同浏览器下的兼容性情况。   ## 7. 掌握一套完整的响应式布局方案。   '},{title:"实现轮子",path:"/posts/Chapter4/",strippedContent:' ## 1. 手动实现 call、apply、bind。  ### 手动实现 call() 方法  **实现思路：调用 `call` 方法时，`this` 指向传入的第一个参数，参数不固定。**   ```js Function.prototype._call = function() {     let thisArg = arguments[0];     if(thisArg === null || thisArg === undefined)  thisArg = window;     let args = Array.prototype.slice.call(arguments, 1, arguments.length);     thisArg._prov_ = this; // 将 this 存储到到临时属性中，为了之后的删除操作     thisArg._prov_(...args); // 这一步相当于直接调用 this this(...args)     delete thisArg._prov_; // 删除临时属性 防止副作用 }  // 测试 let thisArg = {     name: "thisArg" } let thisArg1 = {     name: "thisArg1",     fun: function(age) {        console.log(this.name, age)      } }  thisArg1.fun.call(thisArg); // "thisArg" undefined thisArg1.fun.call(thisArg, 23); // "thisArg" 23 thisArg1.fun._call(thisArg);  // "thisArg" undefined thisArg1.fun._call(thisArg, 23) // "thisArg" 23 ```  ### 手动实现 apply() 方法  **实现思路：`apply()` 与 `call()` 的区别是第二个参数是一个数组。**  ```js Function.prototype._call = function() {     let thisArg = arguments[0];     if(thisArg === null || thisArg === undefined) thisArg = window;     let args = Array.prototype.slice.call(arguments, 1, arguments.length);     thisArg._prov_ = this;     thisArg._prov_(args);     delete thisArg._prov_; } ```  ### 手动实现 bind() 方法  **实现思路：** 1. 调用 `bind()` 方法时，返回一个新函数，普通调用时，新函数的 `this` 指向传入的参数。 2. 如果使用 `new` 调用 `bind` 返回的新函数时，`this` 指向这个新函数。[new 操作符](http://localhost:8080/posts/Chapter1/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html#_4-new-%E7%BB%91%E5%AE%9A%EF%BC%9Athis-%E6%8C%87%E5%90%91%E5%88%9B%E5%BB%BA%E7%9A%84%E7%A9%BA%E5%AF%B9%E8%B1%A1-%E3%80%82)  ```js Function.prototype._bind = function() {     let thisArg = arguments[0];  // 获取 this     let args = Array.prototype.slice.call(arguments, 1); // 获取调用 bind 时传入的参数     let that = this;     let newF = function() {         //调用 bind 返回的新函数时，         //如果通过 new 调用 this 指向返回的新函数         //普通调用时 this 指向传入的第一个参数         let ctx = this instanceof newF ? this : thisArg;            let newArgs = arguments;         let initArgs = args.concat(Array.from(newArgs));  // 合并调用 bind 时传入的参数和调用返回的新函数传入的参数         return that.apply(ctx, initArgs);   // 调用程序     }     return newF;  // 返回新函数 }  let obj1 = {     name: "obj1" } let obj = {     name: "obj",     fun: function(age) {         console.log(this)         console.log(this.name, age);     } }  var f = obj.fun._bind(obj1, 1);  f();  // 输出结果为 obj1 1  this 指向 obj1   new f(); // 输出结果为 undefined 1  this 指向返回的新对象  ```  ## 2. 手动实现符合 Promise/A+ 规范的Promise、手动实现 async await。  ### 手动实现 Promise   ## 3. 手写一个 EventEmitter 实现事件发布、订阅。   ## 4. 可以说出两种实现双向绑定的方案、可以手动实现。   ## 5. 手写 JSON.stringify、JSON.parse。   ## 6. 手写一个模版引擎，并能解释其中原理。   ## 7. 手写懒加载、下拉刷新、上拉加载、预加载等效果。 '},{title:"浏览器API",path:"/posts/Chapter5/%E6%B5%8F%E8%A7%88%E5%99%A8API.html",strippedContent:" ## 1. 浏览器提供的符合W3C标准的 DOM 操作API、浏览器差异、兼容性。  ## 2. 浏览器提供的浏览器对象模型（BOM）提供的所有全局API、浏览器差异、兼容性。  ## 3. 大量 DOM 操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)。  ## 4. 浏览器海量数据存储、操作性能优化。  ## 5. DOM 事件流的具体实现机制、不同浏览器的差异、事件代理。  ## 6. 前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、fetch、可以熟练使用第三方库。  ## 7. 浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型。  ## 8. 浏览器提供的几种存储机制、优缺点、开发中正确的选择。  ## 9. 浏览器跨标签通信。"},{title:"开发和测试",path:"/posts/Chapter6/%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95.html",strippedContent:" # 开发和调试  1. 熟练使用各浏览器提供的调试工具。  2. 熟练使用一种代理工具实现请求代理、抓包，如 charls。  3. 可以使用 Android、IOS 模拟器进行调试，并掌握一种真机调试方案。  4. 了解 Vue、React 等框架调试工具的使用。 "},{title:"React",path:"/posts/Chapter6/react.html",strippedContent:" ## 1. React 和 Vue 选型以及两者优缺点、核心架构的区别。  ## 2. React中 setState 的执行机制，如何有效的管理状态。  ## 3. React 的事件底层实现机制。  ## 4. React 的虚拟 DOM 和 Diff 算法的内部实现。  ## 5. React的 Fiber 工作原理，解决了什么问题。  ## 6. React Router 和 Vue Router 的底层实现原理、动态加载实现原理。  ## 7. 可熟练应用 React API、生命周期等，可应用 HOC、render props、Hooks 等高阶用法解决问题。  ## 8. 基于 React 的特性和原理，可以手动实现一个简单的 React。"},{title:"数据流管理",path:"/posts/Chapter6/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86.html",strippedContent:" 1. 掌握 React 和 Vue 传统的跨组件通信方案，对比采用数据流管理框架的异同。  2. 熟练使用 Redux 管理数据流，并理解其实现原理，中间件实现原理。  3. 熟练使用 Mobx 管理数据流，并理解其实现原理，相比 Redux 有什么优势。   4. 熟练使用 Vuex 管理数据流，并理解其实现原理。  5. 以上数据流方案的异同和优缺点，不情况下的技术选型。 "},{title:"数据结构",path:"/posts/Chapter4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",strippedContent:" ## 1. 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点。  ## 2. 理解数组、字符串的存储原理，并熟练应用他们解决问题。  ## 3. 理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题。  ## 4. 了解图、堆的基本结构和使用场景。"},{title:"Nginx",path:"/posts/Chapter7/nginx.html",strippedContent:" ## 1. 正向代理与反向代理的特点和实例。  ## 2. 可手动搭建一个简单的 nginx 服务器。  ## 3. 熟练应用常用的 nginx 内置变量，掌握常用的匹配规则写法。  ## 4. 可以用 nginx 实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理。"},{title:"Node",path:"/posts/Chapter5/node.html",strippedContent:" ## 1. 理解 Node 在应用程序中的作用，可以使用 Node 搭建前端运行环境、使用 Node 操作文件、操作数据库等等。  ## 2. 掌握一种 Node 开发框架，如 Express，Express 和 Koa 的区别。  ## 3. 熟练使用 Node 提供的 API 如 Path、Http、Child Process 等并理解其实现原理。  ## 4. Node 的底层运行原理、和浏览器的异同。  ## 5. Node 事件驱动、非阻塞机制的实现原理。  "},{title:"开发提速",path:"/posts/Chapter7/%E5%BC%80%E5%8F%91%E6%8F%90%E9%80%9F.html",strippedContent:" 1. 熟练掌握一种接口管理、接口 mock 工具的使用，如 yapi。  2. 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题。  3. 理解 TDD 与 BDD 模式，至少会使用一种前端单元测试框架。"},{title:"Angular",path:"/posts/Chapter6/angular.html",strippedContent:" "},{title:"持续集成",path:"/posts/Chapter7/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90.html",strippedContent:" 1. 理解 CI/CD 技术的意义，至少熟练掌握一种 CI/CD 工具的使用，如 Jenkins。  2. 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）。 "},{title:"Vue",path:"/posts/Chapter6/vue.html",strippedContent:" ## 1. 熟练使用 Vue 的 API、生命周期、钩子函数。  ## 2. MVVM 框架设计理念。  ## 3. Vue双向绑定实现原理、Diff 算法的内部实现。  ## 4. Vue 的事件机制。  ## 5. 从 template 转换成真实DOM的实现机制。"},{title:"实用库",path:"/posts/Chapter6/%E5%AE%9E%E7%94%A8%E5%BA%93.html",strippedContent:" 1. 至少掌握一种 UI 组件框架，如 antd design，理解其设计理念、底层实现。  2. 掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表。  3. 掌握一种 GIS 开发框架，如百度地图 API。  4. 掌握一种可视化开发框架，如 Three.js、D3。  5. 工具函数库，如lodash、underscore、moment 等，理解使用的工具类或工具函数的具体实现原理。"},{title:"手写",path:"/posts/Chapter2/%E6%89%8B%E5%86%99.html",strippedContent:' 1. 手写图片瀑布流效果。**[#](#1)**  2. 使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等）。**[#](#1)**  3. 使用纯 CSS 实现曲线运动（贝塞尔曲线）**[#](#3)**  4. 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点。**[#](#4)**  <h2 id="1">1. 手写图片瀑布流效果。</h2>  <h2 id="2">2. 使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等）。</h2>  <h2 id="3">3. 使用纯 CSS 实现曲线运动（贝塞尔曲线）</h2>  <h2 id="4">4. 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点。</h2>'},{title:"网络协议",path:"/posts/Chapter3/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html",strippedContent:" ## 1. 理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用。  ## 2. 三次握手和四次挥手详细原理，为什么要使用这种机制。  ## 3. 有哪些协议是可靠，TCP 有哪些手段保证可靠交付。  ## 4. DNS 的作用、DNS 解析的详细过程，DNS优化原理。  ## 5. CDN 的作用和原理。  ## 6. HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么？  ## 7. HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题。  ## 8. HTTP1.1、HTTP2.0 带来的改变。  ## 9. HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求。  ## 10. 理解 WebSocket 协议的底层原理、与 HTTP 的区别。"},{title:"项目构建",path:"/posts/Chapter7/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA.html",strippedContent:" 1. 理解 npm、yarn 依赖包管理的原理，两者的区别。  2. 可以使用 npm 运行自定义脚本。  3. 理解 Babel、ESLint、webpack 等工具在项目中承担的作用。  4. ESLint 规则检测原理，常用的 ESLint 配置。  5. Babel 的核心原理，可以自己编写一个 Babel 插件。  6. 可以配置一种前端代码兼容方案，如 Polyfill。  7. Webpack 的编译原理、构建流程、热更新原理，chunk、bundle 和 module 的区别和应用。  8. 可熟练配置已有的 loaders 和 plugins 解决问题，可以自己编写 loaders 和 plugins。  "},{title:"版本控制",path:"/posts/Chapter7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.html",strippedContent:" 1. 理解Git的核心原理、工作流程、和 SVN 的区别。  2. 熟练使用常规的 Git 命令、git rebase、git stash 等进阶命令。  3. 可以快速解决线上分支回滚、线上分支错误合并等复杂问题。"},{title:"TypeScript",path:"/posts/Chapter6/TypeScript.html",strippedContent:" ## 1. 理解泛型、接口等面向对象的相关概念，TypeScript 对面向对象理念的实现。  ## 2. 理解使用 TypeScript 的好处，掌握 TypeScript 基础语法。  ## 3. TypeScript 的规则检测原理。  ## 4. 可以在 React、Vue 等框架中使用 TypeScript 进行开发。"},{title:"多端开发",path:"/posts/Chapter6/%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html",strippedContent:" ## 1. 单页面应用（SPA）的原理和优缺点，掌握一种快速开发 SPA 的方案。  ## 2. 理解 viewport、em、rem 的原理和用法，px、ppi、dpi、dp 的区别和实际应用。  ## 3. 移动端页面适配解决方案、不同机型适配方案。  ## 4. 掌握一种 JavaScript 移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配。  ## 5. 掌握一种 JavaScript PC 客户端开发技术，如 Electron，可搭建 Electron 开发环境，熟练进行开发，可理解 Electron 的运作原理。  ## 6. 掌握一种小程序开发框架或原生小程序开发。  ## 7. 理解多端框架的内部实现原理，至少了解一个多端框架的使用。 "},{title:"设计模式",path:"/posts/Chapter3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",strippedContent:" ## 1. 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等。  ## 2. 发布订阅模式和观察者模式的异同以及实际应用。  ## 3. 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用。"},{title:"算法",path:"/posts/Chapter4/%E7%AE%97%E6%B3%95.html",strippedContent:" ## 1. 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗。  ## 2. 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度。  ## 3. 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用。  ## 4. 可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题。  ## 5. 前端处理海量数据的算法方案。 "},{title:"编码能力",path:"/posts/Chapter4/%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B.html",strippedContent:" ## 1. 多种方式实现数组去重、扁平化、对比优缺点。  ## 2. 多种方式实现深拷贝、对比优缺点。  ## 3. 手写函数柯里化工具函数、并理解其应用场景和优势。  ## 4. 手写防抖和节流工具函数、并理解其内部原理和应用场景。  ## 5. 实现一个 sleep 函数。  "},{title:"变量和类型",path:"/posts/Chapter1/",strippedContent:' ## 1. JavaScript 规定了几种语言类型？  JavaScript 规定了两种数据类型： - **原始类型：** `string`、`number`、`boolean` 、`null`、`undefined`、`symbol`  - **引用类型：** `Object`、`Function`、`Array`   ## 2. JavaScript 对象的底层数据结构是什么？  ## 3. Symbol 类型在实际开发中的应用？  `symbol` 是 ES6 新增，是一种基本数据类型，该类型具有静态属性和静态方法。  `Symbol()` 函数会返回 `symbol` 类型的值，但它不支持语法 `new Symbol()`。  > 每个从 Symbol()返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。  ### symbol 的特性  #### 1. 独一无二  使用 `Symbol()` 函数可以创建一个 `symbol` 类型的值，可传入一个可选的字符串作为描述，当传入对象时，将调用对象的 `toString()` 方法。  ```js var sym1 = Symbol();              // Symbol() var sym2 = Symbol(\'foo\');         // Symbol(foo) var sym3 = Symbol(\'foo\');         // Symbol(foo) var sym4 = Symbol({name: \'foo\'}); // Symbol([object Object]) ``` 我们使用 `Symbol()` 创建了四个新的 `symbol` 类型，它每次都会创建一个新的 `symbol` 类型，即使传入相同的参数：  ```js Symbol(\'foo\') == Symbol(\'foo\')  //false ``` **可见 `symbol` 类型具有独一无二的特性。**    上面使用 `Symbol()` 函数的语法，不会在你的整个代码库中创建一个可用的全局 `symbol` 类型。  要创建跨文件可用的 `symbol`，甚至跨域（每个都有它自己的全局作用域)， 可以使用 `Symbol.for()` 方法和  `Symbol.keyFor()` 方法从全局的 `symbol` 注册表设置和取得 `symbol`。   使用静态方法 `Symbol.for(key)` 可以创造两个相等的 `symbol` 变量。   ```js Symbol.for(\'L\') === Symbol(\'L\'); // true  var key = Symbol.for(\'L\'); Symbol.keyFor(key) === Symbol.keyFor(key); // true ```  #### 2. 原始类型  `symbol` 是一个原始类型的数据，但是它不能使用 `new Symbol()` 创建一个 Symbol 包装对象：  ```js var sym = new Symbol(); // TypeError ```  *围绕原始数据类型创建一个显式的包装对象从 `ECMAScript 6` 开始不再被支持。*  如果想创建一个 `Symbol` 包装对象 ，可以使用 `Object()` 函数：  ```js var sym = Symbol("foo"); typeof sym;     // "symbol" var symObj = Object(sym); typeof symObj;  // "object" ```  #### 3. 不可枚举  当使用 `symbol` 作为对象属性时，可以保证对象不会出现重名属性，调用 `for...in` 不能将其枚举出来。  另外调用 `Object.getOwnPropertyNames()`、`Object.keys()` 也不能获取 `symbol` 类型属性。  ```js var obj = {     name: \'L\',     [Symbol(\'occ\')]: \'Web\' } for(var key in ojb) {     console.log(key)  // name } Object.getOwnPropertyNames(obj); // ["name"] Object.keys(obj); // ["name"] ```  如果要获取对象上的 `symbol` 属性，可以使用 `Object.getOwnPropertySymbols()`：  ```js Object.getOwnPropertySymbols(obj); // [Symbol(occ)] ```  如果要获取对象上的所有属性，可以使用新增的 `Reflect.ownKeys()`：  ```js Reflect.ownKeys(obj); //  ["name", Symbol(occ)] ```  ### symbol 的应用场景  1. 不需要对外操作和访问的属性使用 `Symbol` 来定义（React $$typeof 标识）。 2. 使用 `Symbol` 代替常量。 3. 设置类的私有属性。 4. 防止属性污染。    ## 4. JavaScript 变量类型在内存中的具体存储形式？  - **基本类型：** 保存在`栈`内存中，通过按值访问，值都有固定的大小。  - **引用类型：** 保存在`堆`内存中，通过按引用访问（不允许直接访问堆内存），值大小不固定。  ```js let a: string = "123"; // 栈内存 let b: number = 123; // 栈内存 let c: null = null; // 栈内存 let d: object = { x: 10 }; // 变量d存在于栈中，{ x: 10 }作为对象存在于堆中 let e = [1, 2, 3]; // 变量e存在于栈中，[1, 2, 3]作为对象存在于堆中 ``` 如图所示：  ![屏幕快照 2019-09-20 下午3.26.23.png](https://i.loli.net/2019/09/20/Cu3irzOYkqGFfsD.png)  拓展：  - **原始类型**的比较是值的比较，只有它们的值相等时才相等。  - **引用类型**的比较是按引用的比较，当且仅当它们引用同一个基本对象时，它们才相等。  ## 5. 基本类型对应的内置对象，以及他们之间的装箱拆箱操作？   ## 6. null 和 undefined 的区别？ **null** 表示`"空对象"`，即此处应该有值： ```js  - 在 if 语句中，会转换为 false. - 转换为数字时，表示为 0。 - 作为函数的参数，表示该函数的参数不是对象。 - 作为对象原型链的终点 Object.getPrototypeOf(Object.prototype); ``` **undefined** 表示  `"缺少值"`，就是此处应该有一个值，但是还没有定义： ```js - 在 if 语句中，会转换为 false. - 转换为数字时，表示为 NaN. - 变量被声明了，但没有被赋值，就等于 undefined. - 调用函数时，没有提供对应的实参，该参数显示为 undefined. - 对象没有赋值的属性，该属性的值为 undefined. - 函数没有返回值时，默认返回 undefined. ``` 拓展： ```html typeof null 为 "object" 的解释： 不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型。 null 的二进制表示都是 0，自然前三位都是 0，所以执行 typeof null 时，会返回 ”object”。 ```  ## 7. 至少说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型？  ### typeof `typeof`是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。 ```js typeof \'\';             // string 有效 typeof 1;              // number 有效 typeof Symbol();       // symbol 有效 typeof true;           // boolean 有效 typeof undefined;      // undefined 有效 typeof null;           // object 无效 typeof [] ;            // object 无效 typeof new Function(); // function 有效 typeof new Date();     // object 无效 typeof new RegExp();   // object 无效 ``` **缺点：**  ```js typeof 对于引用类型中的数组、日期、正则等类型的处理，只返回了处于其原型链最顶端的 Object 类型； 对应 null 返回的是 "object"，而 null 有自己的数据类型 Null。 ``` ### instanceof `instanceof` 是用来判断 `a` 是否为 `B` 的实例，表达式为：`a instanceof B`，如果 `a` 是 `B` 的实例，则返回 `true`，否则返回 `false`。 **在这里需要特别注意的是：`instanceof` 检测的是原型对象。** ```js // 伪代码实现 instanceof (a,B) = {     var L = a.__proto__;     var R = B.prototype;     if(L === R) {         // A的内部属性 __proto__ 指向 B 的原型对象         return true;     }     return false; } ``` 从上述过程可以看出，当 `a` 的 `__proto__` 指向 `B` 的原型对象时，就认为 `a` 就是 `B` 的实例，我们再来看几个例子： ```js [] instanceof Array; // true {} instanceof Object;// true new Date() instanceof Date;// true   function Person(){}; new Person() instanceof Person;   [] instanceof Object; // true new Date() instanceof Object;// true new Person instanceof Object;// true ``` 我们发现，虽然 `instanceof` 能够判断出 `[]` 是 `Array` 的实例，但它认为 `[]` 也是 `Object` 的实例，为什么呢？  我们来分析一下 `[]`、`Array`、`Object` 三者之间的关系：  从 `instanceof` 能够判断出 `[].__proto__`  指向 `Array.prototype`，而 `Array.prototype.__proto__` 又指向了 `Object.prototype`，最终 `Object.prototype.__proto__`指向了 `null`，标志着原型链的结束。  因此，`[]`、`Array`、`Object` 就在内部形成了一条原型链：  ![849589-20160112232510850-2003340583.png](https://i.loli.net/2019/09/21/fevn2goItbBzqKc.png)  从原型链可以看出，`[]` 的 `__proto__`  直接指向 `Array.prototype`，间接指向 `Object.prototype`，所以按照 `instanceof` 的判断规则，`[]` 就是 `Object` 的实例。依次类推，类似的 `new Date()`、`new Person()` 也会形成一条对应的原型链 。  **缺点：**  ```js instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 ```  **拓展：**  `instanceof` 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。  ```js var iframe = document.createElement(\'iframe\'); document.body.appendChild(iframe); xArray = window.frames[0].Array; var arr = new xArray(1,2,3); // [1,2,3] arr instanceof Array; // false ``` ### Array.isArray()  针对数组的这个问题，ES5 提供了 `Array.isArray()` 方法。该方法用以确认某个对象本身是否为 `Array` 类型，而不区分该对象在哪个环境中创建。 ```js if (Array.isArray(value)){    //对数组执行某些操作 } ``` `Array.isArray()` 本质上检测的是对象的 `[[Class]]` 值，`[[Class]]` 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 `[object Xxx]` ，`Xxx` 就是对应的具体类型。对于数组而言，`[[Class]]` 的值就是 [object Array] 。  ### toStrig()  `toString()` 是 `Object` 的原型方法，调用该方法，默认返回当前对象的 `[[Class]]`。这是一个内部属性，其格式为 `[object Xxx]`，其中 `Xxx` 就是对象的类型。  对于 `Object` 对象，直接调用 `toString()` 就能返回 `[object Object]`。而对于其他对象，则需要通过 `call / apply` 来调用才能返回正确的类型信息。  ```js Object.prototype.toString.call(\'\') ;   // [object String] Object.prototype.toString.call(1) ;    // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object Window] window 是全局对象  ```  ### constructor  当一个函数 `F` 被定义时，JS 引擎会为 `F` 添加 `prototype` 原型对象，然后再在 `prototype`上添加一个 `constructor` 属性，并让其指向 `F` 的引用。  如下所示：  ![849589-20170508125250566-1896556617.png](https://i.loli.net/2019/09/21/iFpwzxHVIlKDRJL.png)  当执行 `var f = new F()` 时，`F` 被当成了构造函数，`f` 是 `F` 的实例对象，此时 `F` 原型上的 `constructor` 传递到了 `f` 上，因此 `f.constructor == F`。  ![849589-20170508125714941-1649387639.png](https://i.loli.net/2019/09/21/veHsCKjrDYIFUAW.png)  可以看出，`F` 利用原型对象上的 `constructor` 引用了自身，当 `F` 作为构造函数来创建对象时，原型上的 `constructor `就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 `F` 就是新对象的类型。**这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。**  同样，`JavaScript` 中的内置对象在内部构建时也是这样做的：  ![849589-20170508131800457-2091987664.png](https://i.loli.net/2019/09/21/uHZb16KyLsComNq.png)  **细节问题：**  **`null` 和 `undefined` 是无效的对象，因此是不会有 `constructor` 存在的，这两种类型的数据需要通过其他方式来判断。**  函数的 `constructor` 是不稳定的，这个主要体现在自定义对象上，当开发者重写 `prototype` 后，原有的 `constructor` 引用会丢失，`constructor` 会默认为 `Object`。  ![849589-20170508132757347-1999338357.png](https://i.loli.net/2019/09/21/9hrsbizMQag3kpI.png)   因为 `prototype` 被重新赋值的是一个 `{}`， `{}` 是 `new Object()` 的字面量，因此 `new Object()` 会将 `Object` 原型上的 `constructor` 传递给 `{}`，也就是 `Object` 本身。  因此，为了规范开发，在重写对象原型时一般都需要重新给 `constructor` 赋值，以保证对象实例的类型不被篡改。  **总结：** - `typeof` 检测引用类型和 `null` 时，除了函数都会显示 `"object"`。 - 检测函数使用推荐使用 `typeof`。 - **instanceof：** 检测对象是否是某个构造函数的实例。 - **Array.isArray()：** 判断是否为 `Array` 数据类型时使用。 - **constructor：** 可以使用 `constructor` 属性验证实例的原始类型（与操作符 `instanceof` 非常类似）。 - **toString()：** 万能。  ```js 检测对象的属性是否存在使用 in 运算符或者使用 Object.hasOwnProperty() ```  *本节参考：[一像素-判断数据类型的四种方法](https://www.cnblogs.com/onepixel/p/5126046.html)*  ## 8. 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用？  ### 类型转换表  |值\t|转换为字符串\t|转换为数字\t|转换为布尔值\t|转换为对象| |---|------------|----------|----------|---------| |undefined\t|“undefined”|\tNaN\t|false|\tthrow TypeError| |null\t|“null”|\t0\t|false\t|throw TypeError |true|\t“true”\t|1\t|\tnew Boolean(“true”) |false\t|“false”|\t0\t\t|new Boolean(“false”) |“”\t|\t0\t|false|\tnew String("") |“1.2”\t|\t1.2\t|true|\tnew String(“1.2”) |“1.2a”\t|\tNaN\t|true|\tnew String(“1.2a”) |“aaa”|\t\tNaN\t|true\t|new String(“aaa”) |0\t|“0”\t|\tfalse|\tnew Number(0) |-0\t|“0”\t|\tfalse\t|new Number(-0) |1\t|“1”|\t\ttrue|\tnew Number(1) |NaN\t|“NaN”\t|\tfalse\t|new Number(NaN) |Infinity\t|“Infinity”\t|\ttrue\t|new Number(Infinity) |-Infinity|\t“-Infinity”\t|\ttrue|\tnew Number(-Infinity) |[]\t|“”|\t0\t|true\t |[9]|\t“9”\t|9|\ttrue\t |[“a”, “b”]\t|“a,b”|\tNaN\t|true\t |{} | 参见下 | 参见下 |true | | |function() {} | 参见下 | NaN |true | |   ### 对象类型的转换  #### 对象转换成字符( 这里说的是 String()方法的原理 ) 1. 若对象具有 `toString()` 方法，调用 `toString()`，如果返回一个原始值，则将这个原始值转换为字符串返回。  2. 若无 `toString()` 方法，或 `toString()` 的返回值并不是一个原始值，寻找其 `valueOf()` 方法，若存在这个方法，调用它，如果它返回一个原始值，将这个原始值转换为字符串返回。  3. 若无 `valueOf()`或 `valueOf()` 的返回值不是原始值，则 JavaScript 无法得一个原始值，会抛出 `throw TypeError`。  #### 对象转换成数字（这里说的是 Number() 方法的原理） 1. 若具有 `valueOf()` 方法，调用 `valueOf()`，如果它返回一个原始值，将这个原始值转换为数字返回。  2. 若无 `valueOf()` 方法，或 `valueOf()` 的返回值并不是一个原始值，寻找其 `toString()` 方法，若存在这个方法，调用它，如果它返回一个原始值，将这个原始值转换为数字返回。  3. 若无 `toString()` 或 `toString()` 的返回值不是原始值，则 JavaScript 无法得一个原始值，会抛出 `throw TypeError`。  ```js  1. 对象转字符串：先调用 toString() 再尝试调用 valueOf()。 2. 对象转数字： 先调用 valueOf() 再尝试调用 toString()。 3. 数组类型的转换也遵循以上三条，不过数组的 join() 方法的返回结果覆盖了原型链上的toString() 方法。 ```  #### 对象转换成布尔值 对象类型转换为布尔值：均为 `true`，不管其 `toString()`、`valueOf()` 方法返回什么。  ### 各类型的 toString()、valueOf() 方法的返回值  #### 1. 对象 - `toString()` 返回：*"[object Object]"*。 - `valueOf()` 返回：*对象本身*。  #### 2. 数组 - `toString()` 返回：*`arr.join()` 的返回值*。 - `valueOf()` 返回：*数组本身*。  #### 3. 函数 - `toString()` 返回：*整个函数字符串*。 - `valueOf()` 返回：*函数本身*。 ```js function foo() {return "foo"}; foo.toString() // "function foo() {return "foo"}" foo.valueOf() // ƒ foo() {return "foo"} ``` #### 4. 日期  - `toString()` 返回：*完整时间字符串*。 - `valueOf()` 返回：*从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期的毫秒数。*  ```js var date = new Date() date.toString() // "Tue Nov 05 2019 13:54:57 GMT+0800 (中国标准时间)" date.valueOf() // 1572933297576 ```  #### 5. Error - `toString()` 返回：*"Error: 错误描述"*。 - `valueOf()` 返回：*错误本身*。  #### 6. RegExp - `toString()` 返回：*正则式完整字符串*。 - `valueOf()` 返回：*正则本身*。  ```js var a = new RegExp(\'^ass[^fsf]\\w?\',\'gi\'); a.toString(); // "/^ass[^fsf]\\w?/gi" a.valueOf(); //  /^ass[^fsf]\\w?/gi ```  ### 运算符中的隐式类型转换  以上只是一些原理的介绍，下面介绍运算符中的隐式类型转换。  #### 1.算术运算符（+、-、*、/、++、–、% …） - `+` 作为一个双目运算符： 若 `+` 两边存在一个字符串，将另一个也转为字符串进行字符串拼接。  - 其他情况下，不管双目还是单目，都转为数值类型。  #### 2. 关系运算符（>、<、==、!= …） - `===`、`!==`：同时对比类型和值，两个都为真才返回真。  - `==`、`!=`： 若两边均为对象，对比它们的引用是否相同。  - 逻辑非 `!`： 将其后变量或表达式转为布尔值。  - 字符串比较：从头至尾扫描逐个比较每个字符的 `unicode` 码，直到分出大小。  - 其他情况下，两边均转为数值类型。   #### 注意  1. `NaN` 与任何值都不相同，与任何值比较都返回 `false`。  2. 对象类型在运算时进行类型转换都先调用 `valueOf()` 方法，再尝试 `toString()` 方法。  3. 在进行对象字面量运算时要注意，若运算符两边都是字面量，则将它们都视为对象字面量进行类型转换；若只有一个字面量时要注意，当这个字面量在首位时，会被当做一个块（表达式）看待。  ```js {} + {} \t\t// "[object Object][object Object]" [1,2,3] + [] \t//\t "1,2,3" + "" -> "1,2,3"  [] + {} \t\t// "" + "[object Object]" -> "[object Object]" {} + []\t\t    // 0 -> {} 被当做一个块（表达式），相当于执行 ({},+[])，返回值为小括号最后面的表达式的返回值。 {q:1} + [] \t\t// 0  var a = {q:1}; a + []\t //  "[object Object]"     变量形式运算正常 [] + a \t // "[object Object]"  {} == []  => 报错   ({}, ==[]) -> 报错 [] == 0   => true\t[] -> "" -> 0 ![] == 0  => true   ![] -> false -> 0 [] == ![] => true   [] -> "" -> 0    ![] -> false -> 0 [] == []  => false  比较引用地址 {} == {}  => false  比较引用地址 {} == !{} => false  !{} -> false -> 0    {} -> "[object Object]" -> NaN ```    ## 10. 出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript 处理大数字的方法、避免精度丢失的方法？  参考： 1. [JavaScript数字精度丢失问题总结](https://www.cnblogs.com/thinkingthigh/p/8073526.html) 2. [最大安全整数](https://segmentfault.com/a/1190000002608050) 3. [超出JavaScript安全整数限制的数字计算-BigInt](https://www.cnblogs.com/wangmeijian/p/9217352.html)   JavaScript 处理大数字避免精度丢失，可以在存储时使用字符串进行存储。'},{title:"执行机制",path:"/posts/Chapter1/%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html",strippedContent:' ## 1. 为何 try 里面放 return，finally 还会执行，理解其内部机制。  如果存在 `finally` 代码块，`try` 中的 `return` 语句不会立马返回给调用者， 而是记录下返回值等待 `finally` 代码块执行完毕之后再返回。  **注意的几点：**  - 不管 `try` 里有没有返回值，`finally` 都会执行。  - 不管有没有异常，`finally` 都会被执行。  - `finally` 里边的返回值会覆盖 `try` 中返回的值。    ## 2. JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制。  ## 3. 宏任务和微任务分别有哪些?  **宏任务：** 事件队列中每一个事件、`setImmediate（node环境）`、 `MessageChannel`、 `setTimeout`、`setInterval`。  **微任务：** `Promise.then()` 、`MutationObserver`、`process.nextTick（node环境）`。  ## 4. 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法。  ## 5. 使用`Promise`实现串行。 不对  **Promise 串行的实现原理：** 让每个串行中的任务都返回一个 `Promise`，最后统一由 `Promise` 进行 `then` 链式调用达到串行的目的。  ```js function task(fn) {     return new Promise((resolve, reject) => {         fn()         resolve();     }) } function first() {     console.log(1); } function second() {     console.log(2); } function third() {     console.log(3); }  let promise = new Promise((resolve, reject) => {     resolve("promise"); }) promise.then(task(first))     .then(task(second))     .then(task(third))     .then((res) => {         console.log(res);     }) // 1 // 2 // 3 // promise ```     ## 6. Node 与浏览器 EventLoop 的差异。  ### 事件循环   ```html 事件循环是计算机系统的一种运行机制，JavaScript 采用事件循环机制来处理异步任务的执行。 ```  [HTML规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop) 中指出：一个事件循环有一个或者多个**任务队列（Task Queue）**，一个任务队列有一组**任务（异步任务）**。  任务可以分成两种，一种是**同步任务**，另一种是**异步任务**。  **同步任务**是指在主线程上排队执行的任务，同步任务形成 `执行栈`。  **异步任务**不进入主线程排队，而是进入 `Task Queue` 排队的任务，只有 `Task Queue` 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。  ```html 执行栈中的同步任务执行完毕后，才会将 Task Queue 中的异步任务加入到主线程执行。 ```  异步任务分为：**宏任务（macrotask）**和**微任务（microtask）**。  - **宏任务（macrotask）：**     包含执行整体的 JavaScript 代码、事件回调、XHR 回调、定时器（setTimeout/setInterval/setImmediate）、IO操作以及UI渲染。  - **微任务（microtask）：**     更新应用程序状态的任务，包括 `promise` 回调、`MutationObserver`、`process.nextTick` 以及 `Object.observe`。  <img alt="event-loop" src="https://i.loli.net/2019/09/27/wNb9KecBHvyGtWL.png" width="80%">  ### Node.js 中的事件循环  当 `node.js` 运行时，会初始化一个 `EventLoop`，处理那些通过**异步api调用**、**定时器**或者调用 `process.nextTick()` 提供的 `script`或者输入到 `REPL` 中的 `script`。  下图展示了事件循环的操作顺序以及概要。  <img alt="node事件循环" src="https://i.loli.net/2019/09/27/jZNezAMIwUkbxWR.png" width="90%">  ### 浏览器中的事件循环  - 执行一个**宏任务（macrotask）**。  - 执行过程中如果遇到**微任务（microtask）**，就将它添加到微任务的任务队列中。  - **宏任务（macrotask）**执行完毕后，立即执行当前**微任务（microtask）**队列中的所有微任务（先进先出）。  - 当前**宏任务（macrotask）**执行完毕，开始检查渲染，然后 `GUI` 线程接管渲染。    <img alt="浏览器事件循环" src="https://i.loli.net/2019/09/27/vskWbIJrhP5CKX9.png" width="50%">  ### 差异： **Node.js 中**，微任务 `microtask` 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 `microtask` 队列的任务。  <img alt="node事件循环" src="https://i.loli.net/2019/09/27/THPNqOjWvIAXsBG.png" width="70%">  **浏览器环境下**，微任务 `microtask` 任务队列是每个宏任务 `macrotask` 执行完之后执行。  <img alt="浏览器事件循环" src="https://i.loli.net/2019/09/27/7rbNAxsjhLf3uZM.png" width="70%">  ## 7. 如何在保证页面运行流畅的情况下处理海量数据。  '},{title:"作用域和闭包",path:"/posts/Chapter1/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html",strippedContent:' ## 1. 理解词法作用域和动态作用域。  ### 什么是词法作用域？  **词法作用域：** 是定义在词法阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和函数作用域写在哪里来决定的。  因此当词法分析器处理代码时会保持作用域不变。词法作用域即**静态作用域**。  **动态作用域：** 需要明确的是，JavaScript 并不具有动态作用域，它只有词法作用域，简单明了。  **`this` 的执行机制表现的像动态作用域，因为 `this` 的绑定是在代码执行时确定的。**  所谓 **`动态作用域`** 是指作用域在代码执行之前都不确定，也就是说拥有动态作用域的编程语言，函数的作用域是在函数调用的时候才决定的。  为什么说 JavaScript 没有动态作用域？ ```js var num = 1; function foo() {     console.log(num); } function bar() {     var num = 2;     foo(); } bar(); // 输出结果是？ ```  假设 JavaScript 采用动态作用域，让我们分析下执行过程：  执行 `foo()`时 ，依然是从 `foo` 函数内部查找是否有局部变量 `num`。如果没有，就会顺着调用栈在调用 `foo` 函数的位置，也就是 `bar` 函数内部查找 `num` 变量，结果会打印 `2`。  而上段代码的输出结果是 `1`，在执行 `foo()` 时，先从 `foo` 函数内部查找是否有局部变量 `num`，如果没有，就根据书写的位置，查找上一层层的代码，找到了 `var num = 1`，所以结果会打印 1。所以 JavaScript 采用的是静态作用域，作用域在书写代码时就已经决定了**与调用位置没有关系。**  总结： ``` html JavaScript 只有词法作用域，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 ```  **思考：** ```js var scope = "global scope"; function checkscope() {     var scope = "local scope";     function f() {         return scope;     }     return f(); } checkscope(); ``` ```js var scope = "global scope"; function checkscope() {     var scope = "local scope";     function f() {         return scope;     }     return f; } checkscope()(); ```  ## 2. 理解 JavaScript 的作用域和作用域链。   **作用域：** JavaScript 中的作用域就是词法作用域(事实上大部分语言都是基于词法作用域的)。  `词法作用域`是一套关于引擎如何寻找变量以及会在何处找到变量的规则。  `词法作用域`最重要的特征是**它的定义过程发生在代码的书写阶段**(假设你没有使用 `eval()` 或 `with`)。   **作用域链：** 当在查找变量时，首先会在当前作用域中进行查找，如果没有找到，就会向上级进行查找，直到全局作用域。这个过程形成的关系链就是作用域。  如下代码：  ```js function foo(a) {     var b = a * 2;     function bar(c) {         console.log(a, b, c);     }     bar(b * 3); } foo(1); ```   在上段代码中，引擎执行 `console.log()` 声明，并查找 `a`、`b` 和 `c` 三个变量的引用。它首先从最内部的作用域，也就是 `bar()` 函数的作用域开始查找，引擎首先这里找到了`c`，而无法在这里找到 `a`，因此会去上一级到所嵌套的 `foo()` 的作用域中继续查找，在`foo()` 中查找到了`b`，而扔没有找到 `a`的引用， 因此引擎会继续去上一级（这级是全局作用域）继续查找，最后在找到了 `a`。最后经过一些列的向上查找，得到最后的输出结果 `1, 2, 6`。  **注意：** 词法作用域查找只会查找**一级标识符**，如果代码中引用了 `foo.bar.baz`，词法作用域查找只会试图查找 `foo` 标识符，找到这个变量后，对象属性访问规则会分别接管对 `bar` 和 `baz` 属性的访问。  ![屏幕快照 2019-09-23 下午4.25.28.png](https://i.loli.net/2019/09/23/BTSID9FgkGLid45.png)   **思考如下代码：** ```js var a = 10; var foo = {     a: 11,     bar: {         baz: function() {             console.log(a);         }     } } foo.bar.baz(); ```  ## 3. 理解 JavaScript 的执行上下文。  #### 什么是执行上下文？ 当函数执行时，会创建一个称为执行上下文的变量对象`可理解为作用域`。一个执行上下文定义了一个函数执行时的环境。  `执行上下文`也分为两种类型：  - **全局执行上下文：** 代码首次执行时候的默认环境，在代码的整个执行过程中，只用一个全局执行上下文。  - **函数执行上下文：** 每当执行流程进入到一个函数体内部的时候，就会创建一个函数执行上下文，`可以有任意数量的函数执行上下文`。  **执行上下文主要有两个阶段：** `创建阶段`和`执行阶段`。  **创建阶段：** - 首先，为每个函数或变量创建与外部环境的连接，这这个连接形成`作用域链`。`作用链`告诉执行上下文它应该包含什么，以及它应该在哪里查找解析函数的引用和变量的值。  - 扫描`作用链`后，将创建一个环境存储器，其中`全局上下文`、`变量`、`函数及函数参数`的创建和引用在内存中完成。  - 最后，在第一步中创建的每个执行上下文中确定 `this` 关键字的值。   **每个执行上下文包含了三个重要属性：`变量对象（VO）`、`作用域链`、`this`。**   创建阶段伪代码： ```js createContext = { // 创建阶段   \'outerEnvironmentConnection\': { // 创建外部连接         // 形成作用域链    },        \'variableObjectMapping\': {         // 变量、函数和函数参数的创建和引用在内存中完成。    },    \'valueOfThis\': {},  // 确定 this 的值 } ```  **执行阶段：**  `执行阶段`是代码在创建阶段形成的执行上下文中的运行的阶段，并且逐行分配变量值。  当执行开始时，JavaScript 引擎在其创建阶段形成的`AO对象`中查找执行函数的引用。如果在当前对象中没有找到，它将沿着作用域继续向上查找，直到它到达全局环境。  如果在全局环境中找不到函数引用，则将返回错误。  如果找到了引用并且函数正确执行，那么这个特定函数的执行上下文将从栈中弹出，接着 JavaScript 引擎将移动到下一个函数，它们的函数执行上下文将被加入到栈中并执行，以此类推。  下面结合代码来理解`两种执行上下文`的`两个阶段`：  ```js let name = "webinfoq"; var title = "execution context"; const message = "hello world";  function func1(num) {   var author = "deepak";   let value = 3;   let func2 = function multiply() {     return num * value;   }   const fixed = "Divine";   function addFive() {     return num + 5;   } } func1(10); ``` 因此`全局执行上下文`的`创建阶段`将如下所示： ```js globalExecutionContext = {  // 全局执行上下文     outerEnvironmentConnection: null,  // 全局上下文外部环境为 null     variableObjectMapping: {          name: uninitialized,  // 在创建阶段，let 声明的变量是未初始化状态         title: undefined,     // 在创建阶段，var 声明的变量表示为未定义         date: uninitialized,  // 在创建阶段，const 声明的变量是未初始化状态         func1: `<func1 reference>`,  // func1 地址引用     },     this: window // Global Object   } ``` 在`执行阶段`完成对变量的赋值等操作：  ```js globalExectutionContext = {  // 全局执行上下文     outerEnvironmentConnection: null, // 全部上下文外部环境为 null     variableObjectMapping: {         name: "webinfoq",         title: "execution context",         message: "hello world",         func1: pointer to function func1, // 指向 func1 的指针     },     this: window //Global Object } ```  当执行到 `func1` 时，将形成新的`函数执行上下文`，`创建阶段`如下所示： ```js func1ExecutionContext = {  // func1 函数执行上下文     outerEnvironmentConnection: Global,  // 外部环境为全局环境     variableObjectMapping: {        arguments: {             0: 10,             length: 1         },         num: 10,         author: undefined,  // var 声明的         value: uninitialized,  // let 声明的         func2: uninitialized,  // let 声明的         fixed: uninitialized,  // const 声明         addFive: `<addFive reference>`  // addFive 地址引用     },     this: Global Object or undefined   } ``` `执行阶段`如下所示： ```js func1ExecutionContext = {     outerEnvironmentConnection: Global,       variableObjectMapping: {        arguments: {  // 先处理 arguments 参数             0: 10,             length: 1         },         num: 10,         author: "deepak",  //变量赋值         val: 3,         func2: pointer to function func2()          fixed: "Divine"         addFive: pointer to function addFive()     },     this: Global Object or undefined } ``` **最后：**  Javascript 引擎创建执行上下文，调用栈。当有函数执行时，引擎就会创建一个新的函数执行上下文。最后所用函数执行完成后，将更新全局环境，然后全局代码完成，程序结束。   ## 4. 理解 JavaScript 执行上下文栈，可以应用堆栈信息快速定位问题。  通过阅读上一小节我们得知，每当有函数执行时，就会创建一个全新的`执行上下文`，那么怎么管理这些执行上下文呢？  JavaScript 引擎创建了**执行上下文栈** `Execution Context Stack` 来管理执行上下文。  可以把执行栈认为成一个储存函数调用的栈结构，遵循先进后出的原则。  下图为`执行上下文`入栈出栈示意图：  ![入栈出栈示意图](https://i.loli.net/2019/09/23/twsk5g6oaOBFEVq.gif)   **JavaScript 引擎是单线程执行，所有代码都是排队执行：**  - 一开始执行的是全局代码，首先创建`全局执行上下文`，然后将该执行上下文压入执行栈中。  - 当执行一个函数，就会创建该`函数执行上下文`，然后将其压入执行栈的顶部。  - 函数执行完成后，执行上下文从底部退出，等待垃圾回收。  **调用栈的应用：** ```js 你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。 另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具， 其中包含 JavaScript 调试器。 就本例来说，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger 语句。 运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。 因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 ```  ## 5. this 的原理以及几种不同使用场景的取值。  **this** 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于`函数调用时`的各种条件。  **this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**  当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。`this` 就是记录的其中一个属性，会在函数执行的过程中用到。  理解`调用栈`和`调用位置`： ```js function baz() {     // 当前调用栈是: baz     console.log( "baz" );     bar(); // <-- bar 的调用位置  } function bar() {     // 当前调用栈是 baz -> bar     console.log( "bar" );     foo(); // <-- foo 的调用位置，当前调用位置在 baz 中 } function foo() {     // 当前调用栈是 baz -> bar -> foo      // 因此，当前调用位置在 bar 中     console.log( "foo" ); } baz(); // <-- baz 的调用位置，当前调用位置是全局作用域   ``` **this 绑定遵循以下四种规则：** `默认绑定`、`隐式绑定`、`显示绑定`、`new 绑定`。  #### 1. 默认绑定：独立函数调用，`this` 指向全局对象。调用时前边没有或省略 `.` 操作符号。 ```js function foo() {      console.log(this.a); } var a = 2; // window.a = 2; foo(); // window.foo(); ``` **注意：** ```js 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined. ``` #### 2. 隐式绑定：调用位置是否有上下文对象，也就是说，函数被作为某个对象的方法被调用时，`this` 指向那个对象。  ```js function foo() {      console.log(this.a); } var obj2 = {      a: 42,     foo: foo  }; var obj1 = {      a: 2,     obj2: obj2  }; obj1.obj2.foo(); // 42 ``` 上段代码中，词法作用域只会查找最顶层的 `obj1`，按着对象属性访问规则，会在自身上查找属性 `obj2`，所以 `this` 指向 `obj2`，\b所以 `this.a` 等于 `bj2.a`。  **对象属性引用链中只有最顶层或者说最后一层会影响调用位置。**   **注意：** ```js 会出现隐式丢失的情况： this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定， 从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。 ```  #### 3. 显示绑定：使用 `call`、`apply` 或者 `bind` 绑定到指定的对象。**this指向传入的第一个参数。**  ```js function foo() {      console.log(this.a); } var obj = {      a:2 }; var bar = function() {      foo.call(obj); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的 bar 不可能再修改它的 this  bar.call( window ); // 2 ``` **注意：** ```js 把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则。 ```   #### 4. `new` 绑定：`this` 指向创建的空对象 `{}`。  使用 `new` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：  1. 创建(或者说构造)一个全新的对象。  2. 这个新对象会被执行`[[proto]]`连接。  3. 这个新对象会绑定到函数调用的 `this`。  4. 如果函数没有返回其他对象，那么 `new` 表达式中的函数调用会自动返回这个新对象。  ##### 总结：关于 `this` 绑定的场景，遵循以下 `4` 条规则：  1. 由 `new` 调用? 绑定到新创建的对象。  2. 由`call`或者 `apply` 或者 `bind` 调用? 绑定到**指定的对象**。  3. 由上下文对象调用? 绑定到那个上下文对象。  4. 在严格模式下绑定到 `undefined`，否则绑定到**全局对象**。  ##### 拓展： ``` 绑定优先级：new 绑定 > 硬绑定 > 隐式绑定 > 默认绑定 ``` *本节参考：你不知道的 JavaScript（上卷）*    ## 6. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用。  ##### 闭包的概念：闭包是可以记住并有权访问所在函数作用域的`函数`，即使这个`函数`是在当前函数作用域之外执行。  ```js function add() {     var a = 1;     return function closure(b) {          return a + b;      } } const closure = add(); console.log(closure(1)); // 2 ```  这段代码中，调用 `add()` 时会生成一个函数执行上下文，并推入到`执行上下文栈中`。 `add` 函数执行完毕后，它的执行上下文会从执行栈中推出，同时局部变量 `a` 会被清理才对，但我们在执行 `console.log(closure(1));`时却输出了结果 `2`。  我们发现，调用`add()`时，会返回一个函数 `ƒ closure(b) { return a + b; }`，说明局部变量 `a` 存储于 `closure` 函数作用域中，因此我们能得到结果 `2`。  返回的这个函数 `ƒ closure(b) { return a + b; }` 就是我们将要介绍的 **`闭包`**。  ### 闭包的实现原理  ##### 闭包是如何实现对外部作用域的变量存储的？  **我们需要先搞清楚：** 它是拷贝了变量 `a` 的值到其作用域中，还是 `a` 压根没有被销毁，而是给了闭包 `closure` 访问的权限。  ```js function add() {     var a = 1;     ++a;     return function closure(b) {         return a + b;     } } const closure = add(); console.log(closure(1)); ```  首先，我们在这段代码 `++a` 处打上断点，看下实际执行情况。  ![屏幕快照 2019-09-24 下午2.57.06.png](https://i.loli.net/2019/09/24/Raiyz5VeuqWP6jD.png)![屏幕快照 2019-09-24 下午2.53.13.png](https://i.loli.net/2019/09/24/p4urbaPhGJA1fxi.png)  我们发现调用栈为 `add`，在执行到断点处时，\b作用域对象 `Scope` 中存储了当前局部变量 `a` 的值为 `2`，这是我们预期的结果。  接着我们在代码 `return a + b;` 处打上断点，实际情况如下图所示：  ![屏幕快照 2019-09-24 下午3.06.28.png](https://i.loli.net/2019/09/24/itPuok97KMTNBfD.png)![屏幕快照 2019-09-24 下午2.49.18.png](https://i.loli.net/2019/09/24/SYpT7jrPiD8oBEV.png)  从 `Debug` 的结果来看，当执行到断点 `return a + b;` 处时，调用栈 `add` 被推出，当前调用栈变成了 `closure`，作用域对象 `Scope` 中局部变量 `a` 被销毁，只保存了当前调用栈 `closure` 中的变量 `b`。  而运行到此时，多出了一个 `Closure` 对象，它持有所在作用域 `add` 中的局部变量 `a` 属性，它的值为 `2`。  **这里我们应该能得知：** 它是拷贝了变量 `a` 的值到其作用域中进而给了闭包 `closure` 访问的权限。   **总结：**  JavaScript 在执行时，如果遇到上述含有 `闭包` 的代码，它会在内存开辟出一块空间，这个内存空间称为 `Closure` 对象，**它用来存储所在函数作用域中的变量，因此其所在作用域的变量即使被销毁，在外部也能访问到存储下来的变量。**  ***闭包查找变量是沿着作用域链向上查找的，本文并没有介绍的作用域链相关的知识，因为个人感觉闭包能缓存变量的原理并不是因为作用域链，作用域链只能说明闭包访问的范围。***  ### 闭包的应用场景 - **jQuery** 源码的实现（ jQuery 就是一个大的闭包 ）。 - 函数节流。 - **Ajax** 的回调函数。 - 处理循环中的异步操作。  ## 7. 理解堆栈溢出和内存泄漏的原理，如何防止？  ## 8. 如何处理循环的异步操作？  在实际项目中，我们可能会遇到，在循环中发起接口调用的请求，就像这样： ```js  const parmas = ["todos/1", "todos/2", "todos/3"]; const urls = \'https://jsonplaceholder.typicode.com\'; for(var i = 0; i < parmas.length; i++) {     fetch(urls + ${parmas[i]}).then(function(res) {         console.log(res)     }) } ```  #### async await ##### 1. 串行执行： ```js const urls = [   \'https://jsonplaceholder.typicode.com/todos/1\',   \'https://jsonplaceholder.typicode.com/todos/2\',   \'https://jsonplaceholder.typicode.com/todos/3\' ];  async function getTodos() {   for(var i = 0; i < urls.length; i++) {       const todo = await fetch(urls[i]);       console.log(todo);   } } getTodos()  ``` ##### 2. 并行执行： ```js // 第一种 async function getData() {   const promises = urls.map(url => fetch(url))   for (const promise of promises) {     const data = await promise     console.log(data);   } } getData()  // 第二种 async function getData() {     const promises = urls.map(async (url, index) => {         const data = await fetch(url);         console.log(data);     })     await Promise.all(promises); } getData(); ```   ## 9. 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理。  ```js  ```'},{title:"语法和API",path:"/posts/Chapter1/%E8%AF%AD%E6%B3%95%E5%92%8CAPI.html",strippedContent:' ## 1. 理解 `ECMAScript` 和 `JavaScript` 的关系。  ECMAScript 和 JavaScript 的关系是：前者是后者的规格，后者是前者的一种实现，在日常场合，这两个词是可以互换的。  ```js ECMAScript 是国际标准化组织 ECMA 为 JavaScript 制定的一种标准，之所以不叫 JavaScript： 一是因为商标问题，JavaScript 本身也已经被 Netscape 公司注册为商标，只有 Netscape 公司可以合法地使用 JavaScript 这个名字。 二是想体现这门语言的制定者是 ECMA，这样有利于保证这门语言的开放性和中立性。 ```  ## 2. 熟练运用 `es5`、`es6` 提供的语法规范。 这个只能在实践中多积累啦。 [babel 官网 Learn ES2015](https://babeljs.io/docs/en/learn) 提供了全面的语法介绍和使用。  ## 3. 熟练掌握 `JavaScript` 提供的全局对象（例如 `Date`、`Math`）、全局函数（例如 `decodeURI`、`isNaN`）、全局属性（例如`Infinity`、`undefined`）。  ## 4. 熟练应用 `map`、`reduce`、`filter` 等高阶函数解决问题。  列举一些 `map`、`reduce`、`filter` 高频使用场景。  ### [map 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map) `map()` 方法返回一个新数组，其结果是该数组每个成员调用提供的函数后返回的新数组。 ```js var arr = [1, 2, 3, 4]; var newArr = arr.map(x => x * 2); console.log(newArr); // [2, 4, 6, 8] ```  ### map 方法使用场景：  ##### 1. 将字符串成员转换为数组项  ```js var str = "yuanyuan"; var arr = Array.prototype.call(str, x => x + ""); console.log(arr); //["y", "u", "a", "n", "y", "u", "a", "n"] ``` ##### 2. 在 React 中用来渲染列表数据 ```js const names = ["jser", "phper", "javaer", "pythener"]; const NamesList = () => (<ul>{names.map(name => <li key={name}> {name} </li>)}</ul>); const rootElement = document.getElementById("root"); ReactDOM.render(<NamesList />, rootElement); ```  ##### 3. 格式化数组对象 ```js const myUsers = [     { name: \'jser\', age: 18 },     { name: \'phper\', age: 19 },     { name: \'javaer\', age: 20 } ] const mapFormat = myUsers.map((item) => {     const result = [];     result[item.name] = item.age;     result.sex = "男";     return result; }) console.log(mapFormat); // [{ jser: 18, sex: "男" },{ phper: 19, sex: "男" },{ javaer: 20, sex: "男" }] ``` ### [reduce 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)  `reduce()` 方法对数组每个元素执行一个 `reduce` 函数，将其结果汇总为单个返回值。  ```js const array = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) => accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array.reduce(reducer));  // 10 ```  ### reduce 方法使用场景：  ##### 1. 对数组进行求和 ```js 参见上段代码 ``` ##### 2. 将二维数组转换为一维数组 ```js let array = [[1, 2], [3, 4], [5, 6]]; const reducer = (acc, cur) => acc.concat(cur); let result = array.reduce(reducer, [])   // 将 [] 作为回到函数第一个参数 console.log(result); //[1, 2, 3, 4, 5, 6] ```  ##### 3. 计算数组每个元素出现的次数 ```js let names = [\'jser\', \'jser\', \'javaer\', \'javaer\', \'phper\', \'pythener\'] let obj = {}; names.reduce((acc, cur) => {     acc[cur]? acc[cur]++ : acc[cur] = 1;     return acc; }, obj)   // 将 obj 作为回到函数第一个参数 obj  //解析： //第一次遍历：acc = {} cur = "jser" //第二次遍历：acc = {jser: 1} cur = "jser" //第三次遍历：acc = {jser: 2} cur = "javaer" //第四次遍历：acc = {jser: 2, javaer: 1} cur = "javaer" //第五次遍历：acc = {jser: 2, javaer: 2} cur = "phper" //第六次遍历：acc = {jser: 2, javaer: 2, phper: 1} cur = "pythener" //第七次退出：acc = {jser: 2, javaer: 2, phper: 1, pythen: 1}   console.log(obj) // {jser: 2, javaer: 2, phper: 1, pythen: 1}   ```  ### [filter 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)  `filter()` 方法创建一个新数组，其成员是通过提供函数测试的所有元素。 ```js const words = [\'spray\', \'limit\', \'elite\', \'exuberant\', \'destruction\', \'present\']; const result = words.filter(word => word.length > 6);  // 元素的长度大于6的通过测试 console.log(result); ["exuberant", "destruction", "present"] ``` ### filter 方法使用场景  ##### 1. 数组去重 ```js function unique(arr) {   return arr.filter((item, index, arr) => arr.indexOf(item) === index); } let arr = [1, 1, false, false, undefined, undefined, null, null]; unique(arr); // [1, false, undefined, null] ```   ## 5. `setInterval`需要注意的点，使用 `setTimeout` 实现 `setInterval`。  **setInterval 需要注意的点：**  - `setInterval` 第一个参数可以是一个函数签名也可以是一个被引号包裹的函数调用。     ```js     setInterval(engine, 1000);      //or     setInterval("engine()", 1000);     ```  - 第一个参数不能传递带参数的函数。     ```js      setInterval(function(args), 300)  // 报错     ```      - `setInterval` 如果不使用 `clearInterval` 停止，将会一直运行，即使第二次使用传入了不同的函数处理程序。  - `setInterval` 只能在方法外使用。   **使用 setTimerout 实现 setInterval：**  ```js // 递归调用 _setInterval(); function _setInterval() {     console.log(1);     let timer = setTimeout(() => {         _setInterval();         clearInterval(timer);     }, 1000) } ```  ## 6. JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题。  ### 修饰符 修饰符写在结尾的 `/` 之后，影响整个正则表达式的匹配行为。  - **`i` 不区分大小写（ignore）：**      在匹配时忽略英文字母的大小写。  - **`g` 全局匹配（global）：**      正则表达式默认只会返回第一个匹配结果，使用标志符 `g` 则可以返回所有匹配。  - **`m` 多行匹配（multiline）：**      将开始和结束字符（ `^` 和 `$` ）视为在多行上工作。      即分别匹配每一行（由 `\\n` 或 `\\r` 分割）的开始和结束，而不只是只匹配整个输入字符串的最开始和最末尾处。  ### 字符集 用于匹配字符集中的任意一个字符。  - `[xyz]`：匹配所包含的`x`、`y`、`z` 任意一个字符。  - `[^xyz]`：补集，匹配除 `x`、`y`、`z` 以外的字符。  - `[a-z]`：匹配从 `a` 到 `z` 的任意字符。  - `[^a-n]`：补集，匹配除`a` 到 `n` 的其他字符。  - `[A-Z]`：匹配从 `A` 到 `Z` 的任意字符。  - `[0-9]`：匹配从 `0` 到 `9` 的任意数字。  ```js 匹配所有的字母和数字可以写成：/[a-zA-Z0-9]/ 或者 /[a-z0-9]/i ```  ### 量词 使用量词达到重复匹配的目的。  - **`{n}`**：匹配 `n` 次。  - **`{n,m}`**：匹配 `n-m` 次。  - **`{n,}`**：匹配 `>=n` 次。  - **`?`**：匹配 `0 || 1` 次。  - **`*`**：匹配 `>=0` 次，等价于 `{0,}`。  - **`+`**：匹配 `>=1` 次，等价于 `{1,}`。   ### 元字符 元字符就是描述字符的字符，它用于对字符表达式的内容、转换及各种操作信息进行描述。  - **`\\d`**：匹配任意数字，等价于 `[0-9]`。  - **`\\D`**：匹配任意非数字字符，`\\d` 的补集。  - **`\\w`**：匹配任意基本拉丁字母表中的字母和数字，以及下划线，等价于 `[A-Za-z0-9_]`。  - **`\\W`**：匹配任意非基本拉丁字母表中的字母和数字，以及下划线，`\\w` 的补集。  - **`\\s`**：匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。  - **`\\S`**：匹配一个非空白符，`\\s` 的补集。  - **`\\b`**：匹配一个零宽单词边界，如一个字母与一个空格之间。     ```js     例如 /\\bno/ 匹配 "at noon" 中的 "no"。     /ly\\b/ 匹配 "possibly yesterday." 中的 "ly"。     ```  - **`\\B`**：匹配一个零宽非单词边界，如两个字母之间或两个空格之间。     ```js     例如，/\\Bon/ 匹配 "at noon" 中的 "on"。     /ye\\B/ 匹配 "possibly yesterday." 中的 "ye"。     ```  - **`\\t`**：匹配一个水平制表符（tab)。  - **`\\n`**：匹配一个换行符（newline)。  - **`\\r`**：匹配一个回车符（carriage return)。  ### 特殊字符 它们不会按照字面意思进行匹配，而有特殊的意义，比如前文讲过用于量词的 `?`、`*`、`+`。  其他常见的特殊字符有：  - **`\\`**：转义字符。可以将普通字符转成特殊字符。也可以将特殊字符转成字面意思。     ```js     比如 \\+ 匹配 +。     ```  - **`.`**：匹配任意单个字符，但是换行符除外（`\\n`, `\\r`, `\\u2028`或 `\\u2029`）。     ```js     在字符集中 [.]，无特殊含义，即表示 \'.\' 的字面意思。     ```  - **`|`**：替换字符，匹配 `|` 前或后的表达式。     ```js     比如需要同时匹配 "bear" 和 "pear"，可以使用 /(b|p)ear/ 或者 /bear|pear/。     但是不能用 /b|pear/，该表达式只能匹配 "b" 和 "pear"。     ```  - **`^`**：匹配输入的开始。     ```js     比如，/^A/ 不匹配 "an Apple" 中的 "A"，但匹配 "An apple" 中的 "A"。     ```  - **`$`**：匹配输入的结尾。     ```js     比如，/t$/ 不匹配 "eater" 中的 "t"，但匹配 "eat" 中的 "t"。     ^ 和 $ 在表单验证时常需要使用，因为需要验证从开始到结尾的一个完整输入，而不是匹配输入中的某一段。     ```   ### 分组 - **`(xyz)`**：捕获分组，匹配并捕获匹配项。     ```     例如，/(foo)/ 匹配且捕获 "foo bar." 中的 "foo"。     被匹配的子字符串可以在结果数组的元素 [1], …, [n] 中找到，     或在被定义的 RegExp 对象的属性 $1, …, $9中找到。     ``` - **`(?:xyz)`**：非捕获分组，匹配但不会捕获匹配项，匹配项不能再次被访问到。  - **`\\n`**：n 是一个正整数，表示反向引用，指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。 \t```js \t例如，/apple(,)\\sorange\\1/ 匹配 "apple, orange, cherry, peach." 中的 "apple,orange,"。     ```  ### 断言  - **`x(?=y)`**：仅匹配被 `y` 跟随的 `x`。 \t```js     例如， /bruce(?=wayne)/，如果 "bruce" 后面跟着 wayne，则匹配之。     /bruce(?=wayne|banner)/，如果 "bruce" 后面跟着 "wayne" 或者 banner，则匹配之。     但是，"wayne" 和 "banner" 都不会在匹配结果中出现。     ``` \t - **`x(?!y)`**：仅匹配不被 `y` 跟随的 `x`。 \t```js     /\\d+(?!.)/ 只会匹配不被 "." 跟随的数字。      ```  **`/\\d+(?!\\.)/.exec(\'3.141\')` 匹配 "141"，而不是 "3.141"。**   ### 应用 #### 1. 匹配手机号码  目前国内的手机号码是 `1(3/4/5/7/8)` 开头的 `11` 位数字，因此手机号码的正则可以分解为以下几部分：  - 以 `1` 开头：`/^1/`。  - 第 `2` 位为 `3、4、5、7、8` 中的一个：`/[34578]/` 或 `/(3|4|5|7|8)/`。  - 剩余 `3-11` 位均为数字，并以数字结尾：`/\\d{9}$/`。  - 组合起来即为 `/^1[34578]\\d{9}$/` 或 `/^1(3|4|5|7|8)\\d{9}$/`，因为使用捕获括号存在性能损失，所以推荐使用第一种写法。  #### 2. 匹配电子邮件  标准的电子邮件组成为 `<yourname>@<domain>.<extension><optional-extension>`，每部分的格式标准为（进行了相应的简化，主要为展示如何书写正则）：  - `yourname`：任意英文字母`（a-z/A-Z）`、数字`（0-9）`、下划线`（_）`、英文句点`（.）`、连字符`（-）`，长度大于 `0`。   -`domain`：任意英文字母`（a-z/A-Z）`、数字`（0-9）`、连字符`（-）`，长度大于 `0`。  - `extension`：任意英文字母`（a-z/A-Z）`，长度 `2-8`。  - `optional-extension`：`"."` 开头，后面跟任意英文字母`（a-z/A-Z）`，长度 `2-8` 可选。  每部分的正则表达式为：  - **yourname**：`/[a-z\\d._-]+/`；  - **domain**：`/[a-z\\d-]+/`；  - **extension**： `/[a-z]{2,8}/`；  - **optional-extension**：`/(.[a-z]{2,8})?/`。  组合起来形成最后的正则表达式：`/^([a-z\\d._-]+)@([a-z\\d-]+)\\.([a-z]{2,8})(\\.[a-z]{2,8})?$/`；为了增加可读性可以将每部分用 `"()"` 包起来，并不要忘记起始和结束符 `^$`。  *本节参考[还不会正则表达式？看这篇！](https://mp.weixin.qq.com/s/f6ii_hKgY0gLdhMFda6S6Q)*  ## 7. JavaScript 异常处理的方式，统一的异常处理方案。  异常处理的方式：使用 `try...catch` 捕获异常并抛出、在一些不合理的情况下主动抛出异常 `throw...`。 '},{title:"原型和原型链",path:"/posts/Chapter1/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.html",strippedContent:' ## 1. 理解原型设计模式以及 JavaScript 中的原型规则。  我们创建的每个函数都有一个 `protoype` 属性，这个 `prototype` 属性是一个指针，指向**原型对象**。  **这个对象的用途**：包含由特定类型的所有实例共享的属性和方法（通俗的说就是，所有特定类型的实例都可以共享这个对象上的属性和方法）。  ### 原型对象的两种赋值方法：  ##### 1. 给原型对象添加属性或方法： ```js function Person() {} // Person 原型对象上默认只有一个 constructor 属性 // 这个 constructor 指向 Person Person.prototype.name = "jser"; Person.prototype.age = 16; Person.prototype.sayName = function() {     return this.name; }  let per1 = new Person(); let per2 = new Person(); per1.sayName === per2.sayName; // true per1.age === per2.age;  // true ``` 正如上边所说，实例 `per1` 和 `per2` 共享 `Person` 原型对象的属性和方法。  ##### 2. 重写原型对象： ```js function Person() {} Person.prototype = {     name: "jser",     age: 16,     sayName() {         return this.name;     } } let per1 = new Person(); let per2 = new Person(); per1.sayName === per2.sayName; // true per1.age === per2.age;  // true ``` 这种方式会重写原型对象，重写后的原型对象默认的 `constructor` 属性不再指向 `Person` 此时它指向 `Object`。（下文会有讲到）  我们可以手动将它指向 `Person`： ```js Person.prototype = {     constructor: Person,     ... } ```  ### 原型对象内存分析：  ![屏幕快照 2019-09-25 下午4.25.37.png](https://i.loli.net/2019/09/25/kC9hIFf1PJosjHX.png)  默认情况下，原型对象 `Person.prototype` 会包含一个 `constructor` 属性，这个属性上也有一个 `prototype` 属性，这个属性是一个指针，指向**原型对象**。  ```js 创建的实例也有 constructor 属性，可以使用 实例.constructor.prototype 去修改或扩展原型对象。 ``` ```js Person.prototype.constructor === Person // true Person.prototype.constructor.prototype === Person.prototype // true ```  当调用构造函数创建一个新实例后，该实例内部会包含一个内部属性 `__proto__`，它指向构造函数的原型对象。  ```js person1.__proto__ === Person.prototype // true ```  这个`连接`只存在于**实例**与构造函数的**原型对象**之间，而不是存在于实例与构造函数之间，**也就是说这个内部属性和构造函数没有直接的关系。**  ### 原型对象的值不能被实例重写： ```js function Person() {} Person.prototype = {     constructor: Person,     name: "jser",     age: 16,     sayName() {         return this.name;     } } let per1 = new Person(); let per2 = new Person(); per1.name = "zxl"; // 重写 name console.log(per1.name);  // zxl person实例 在自身查到到了 name  console.log(per2.name);  // jser 在原型对象上查找到的 name ``` 可以看到原型对象中的 `name` 没有被改变，`person2.name` 在原型对象上查找的值仍为 `"jser"`。  **原型模式查找属性原则：**  - 在**原型模式**中，当通过实例读取属性值时，首先会在实例自身上查找，如果实例上没有，则就会去原型对象上搜索；  - 如果在**自身**上找到，就使用这个值，不会再继续去原型对象上查找。  ![屏幕快照 2019-09-25 下午5.13.55.png](https://i.loli.net/2019/09/25/QdMBUg5YSR6ce3p.png)  ### 原型模式的动态性：  上文说到不能通过实例对象来重写原型对象上的属性，如果想要重写原型对象上的属性，只能通过原型对象自身去修改。 ```js ... Person.prototype.age = 22; ``` **原型模型原则：由于在原型中查找值的过程是一次搜索，因此在对原型对象做的任何修改都会立即从实例上反映出来，即使是先创建实例后修改原型也如此。** ```js // 先创建实例 后修改原型对象 let per2 = new Person(); Person.prototype.age = 22; console.log(per2.age); // 变成改写后的 22  // 后创建实例 先修改原型对象 Person.prototype.age = 22; let per2 = new Person(); console.log(per2.age); // 变成改写后的 22 ``` **如果先创建了实例，之后用字面量赋值的方式来重写原型对象，这就会切断现有原型对象与之前存在的任何实例之间的联系。** ```js function Person() {} let per1 = new Person(); Person.prototype = {     name: "jser",     age: 16,     sayHi() {         console.log("Hi");     } } per1.sayHi(); ``` 这段代码会报 `Uncaught TypeError: per1.sayHi is not a function`，说明实例 `per1` 没有搜索不到 `sayHi` 这个方法，因为在创建 `per1` 实例之前，`per1.__proto__` 指向的原型对象只有一个默认属性 `constructor`。 ```js { constructor: ƒ } ``` 重写的 `Person.prototype` 被分配在了新的内存空间中：  ![屏幕快照 2019-09-25 下午5.58.18.png](https://i.loli.net/2019/09/25/3nq4eFlfZCEhuNy.png)  ### 原型对象的缺点： **原型对象**的好处是原型中的所有属性和方法可以被很多实例共享。  缺点是当原型中包含引用类型的值的属性时，一个实例对象对这个引用类型的属性做了修改，在其他实例对象中也可以体现出来。  ```js function Person() {} Person.prototype = {     constructor: Person,     name: "jser",     age: 16,     friends: ["javaer", "phper"] } let per1 = new Person(); per1.friends.push("pythener"); let per2 = new Person(); console.log(per2.friends) ``` 原型对象中引用类型属性 `friends` 被修改成了 ` ["javaer", "phper", "pythener"]`，因此实例对象 `per2` 搜索到的结果也被 `per1` 修改了。  ### 从原型对象中体现的一些原型模式的规则可以总结如下：  - 构造函数有一个 `prototype` 指针指向原型对象，构造函数的实例共享原型对象上的属性和方法。  - 实例与原型对象之间有一个 `__proto__` 连接。  - 原型对象上有一个 `constructor` 属性默认指向构造函数，`constructor` 属性上有一个 `prototype` 指针指向原型对象。  - 原型对象上的值不能被实例重写。  - 在原型模式中，通过实例子搜索属性时，实例上的属性会屏蔽原型对象上的同名属性。  - 原型模式中查找值的过程是一次搜索，因此在对原型对象做的任何修改都会立即从实例上反映出来，即使是先创建实例后修改原型也如此。 - 如果先创建了实例，之后用字面量赋值的方式来重写原型对象，这就会切断现有原型对象与之前存在的任何实例之间的联系。  - 原型可以被继承，如通过 `Object.create(prototype, optionalDescriptorObjects)` 来实现原型继承。  ## 2. instanceof 的底层实现原理，手动实现一个 instanceof。  **instanceof**是用来判断 `a` 是否为 `B` 的实例，表达式为：a `instanceof` B，如果 `a` 是 `B` 的实例，则返回 `true`，否则返回 `false`。   **在这里需要特别注意的是：`instanceof` 检测的是原型对象。** ```js // 底层实现原理： instanceof (a,B) = {     var L = a.__proto__;     var R = B.prototype;     if(L === R) {         // A的内部属性 __proto__ 指向 B 的原型对象         return true;     }     return false; } ``` 代码的基本实现： ```js function _instanceof(instance, F) {     if(!F) `Right-hand side of \'instanceof\' is not an object`;     const L = instance.__proto__;     const R = F.prototype;     if(!L) throw `Unexpected identifier`;     if(instance.__proto__ === F.prototype) {         return true;     }     return false; } ```  ## 3. 实现继承的几种方式以及他们的优缺点。  继承的继承方式：`原型链继承`、 `构造继承（call/apply）`、`组合继承`、`寄生组合继承` `ES6继承`。  ### 原型链继承  ##### 首先回顾下构造函数、原型、和实例之间的关系： 每一个构造函数都有一个原型对象 `F.prototype`，原型对象都包含一个指向构造构造的指针 `constructor`，而实例都包含一个指向原型对象的内部指针 `__proto__`。 ```js function F() {} var f = new F() F.prototype.constructor === F; f.__proto__ === F.prototype;  ``` **原型链继承的思想：**将父类的实例作为子类的原型对象。 ```js function Tiger(leg) {     this.leg = leg; } Tiger.prototype.getLeg = function() {     return this.leg; }  function Cat(eat) {     this.eat =  eat; }  // 将 Tiger 的实例对象 Tiger {leg: "四条腿"} 作为 Cat 的原型对象 // 这是一个重写 Cat 原型对象的过程 Cat.prototype = new Tiger("四条腿");    Cat.prototype.getEat = function() {     return this.eat; }  let cat = new Cat("鱼"); console.log(cat.getLeg()); // 四条腿 console.log(cat.getEat()); // 鱼 ``` **原型链继承实际上是重写子类原型对象的过程，子类原型对象的 `constructor` 属性会被默认指向父类。** ```js Cat.prototype.constructor === Tiger; // true ```  **原型链继承的缺点：** 当父类的原型对象修改后，子类也会访问到修改后的结果，父类一变其他都跟着变了。  *遵循了原型模式的动态性（请看第 1 小节）*  ### 构造继承（call/apply）  **构造继承的思想：** 利用 `call` 或 `apply` 将父类的 `this` 硬绑定到子类上。  ```js function Tiger (leg) {     this.leg = leg;     this.getLeg = function () {         return this.leg;     } }; //对原型对象进行的扩展的方法就无法被继承了 Tiger.prototype.getEat = function () {         console.log("吃肉"); };  function Cat(eat) {     // 使用 call 将 this 硬绑定到 Cat 类上     // 创建 Cat 类实例后，实例调用方法时，this 指向 Cat     // console.log(this); Cat      Tiger.call(this, \'四条腿\');　　     this.eat = eat; };  let cat = new Cat("鱼"); console.log(cat.leg);　　　　  // 四条腿 （继承自 Tiger 类） console.log(cat.getEat());　　// 报错 调用不到 Tiger 类原型对象上面的方法　　 ```  **构造继承的缺点：**  - 只能继承父类的实例属性或方法，不能继承父类原型上的属性或方法，无法实现函数复用。  - 每个子类都有父类实例函数的副本，性能会有耗损。  ### 组合继承  **组合继承的思想：**是将`原型链继承`和`构造继承`组合起来使用，是常用的一种继承方式。 ```js function Tiger(leg) {     this.leg = leg; } Tiger.prototype.getLeg = function() {     return this.leg; }  function Cat(eat) {     // 构造继承 使用 call 调用父类 将 this 硬绑定到子类上     // 继承父类的实例属性或方法     Tiger.call(this, "四条腿"); // 第二次调用父类     this.eat =  eat; }  // 使用原型链继承 将 Tiger 的实例对象 Tiger {leg: "四条腿"} 作为 Cat 的原型对象 // 继承父类的原型属性或原型方法 Cat.prototype = new Tiger("四条腿");   // 第一次调用父类  Cat.prototype.getEat = function() {     return this.eat; }  let cat = new Cat("鱼"); // 触发第二次调用 console.log(cat.leg);  // 四条腿 （继承自父的实例属性 ） console.log(cat.getLeg()); // 四条腿 （继承自父类的原型方法） console.log(cat.getEat()); // 鱼 ``` 第一次调用 `Tiger` 构造函数时，`Cat.prototype` 会得到属性 `leg`，它是父类的实例属性，只不过现在位于子类的原型对象中。 当 使用 `new` 调用 `Cat` 构造函数时，又会调用一次 `Tiger` 构造函数，这一次会在 `new` 创建的新对象上创建实例属性 `leg`， 于是这个属性就屏蔽了原型对象上的同名属性。  **组合继承的缺点：** 调用了两次父类，第二次调用父类时，会在新对象上创建实例属性，这会屏蔽存在子类原型对象上的同名属性。  ### 寄生式继承  **寄生继承的思想：**创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。  ```js function cloneObj(parent) {     let clone = object(parent);     clone.getLeg = function() {        return this.leg;     }     return clone; }  // 寄生 function object(obj) {     function F() {};     F.prototype = obj;     return new F(); }  let tiger = {     eat: "肉",     leg: "四条" } let cat = cloneObj(tiger); cat.getLeg();  // 四条 ```  **寄生继承的缺点：**使用寄生式继承为对象添加方法，会由于不能做到方法的复用而降低效率，这一点和构造函数模式类似。   ### 寄生组合继承 **寄生组合继承思想：**是在组合继承的基础上，使用`寄生`方式对组合继承进行的一次优化。 ```js function Tiger(name) {     this.name = name; } Tiger.prototype.leg = "四条腿";  Tiger.prototype.getEat = function() {     return this.eat; } function Cat(eat) {     // 构造继承 使用 call 调用父类 将 this 硬绑定到子类上     // 继承父类的实例属性或方法     Tiger.call(this, "老虎");      this.eat = eat; } // 寄生 !function() {     let F = function() {};         // 创建一个空对象作为寄生     F.prototype = Tiger.prototype; // 将父类的原型对象寄生到空对象的原型对象上     new F().constructor  = Cat;    // 构造指针手动指向子类     Cat.prototype = new F();       // 将空对象的实例作为子类的原型对象 （子类只继承了父类的原型上的方法和属性） }();  let cat = new Cat("鱼"); console.log(cat.eat); // 鱼 // （子类实例自身的属性） console.log(cat.leg); // 四条腿 （继承了父类原型上的属性） console.log(cat.getEat()); ``` **寄生组合继承是实现基于类型的继承的最有效的方式，但是实现起来相对复杂，代码量会很大。**  ### ES6 继承（这里在本节作为了解） ES6 中提供了 `class` 构造函数的写法，对于继承 `class` 可以使用 `extends` 关键字。 ```js class Tiger {     constructor(leg){         this.leg = leg;     }     getLeg() {         console.log(this.leg);     } } class Cat extends Tiger {       constructor(leg, eat) {         super(leg);  //相当于构造继承中的 Tiger.call(this, leg);         this.eat = eat;     }     //子类独有的方法     getEat() {         return this.eat;     } }      const cat = new Cat("四条腿", "鱼");     cat.getLeg();     cat.getEat();     console.log(cat instanceof Cat);    //true     console.log(cat instanceof Tiger);  //true ``` **拓展：**  ```js ES6 提供了 Object.create() 方法也可以实现继承。 语法：Object.create(proto[, propertiesObject]) ```   ## 4. 至少说出一种开源项目(如Node)中应用原型继承的案例。  ## 5. 描述 new 一个对象的详细过程，手动实现一个 new 操作符。  **使用 `new`操作符来调用函数时，会自动执行下面的操作：**  1.创建一个新的空对象；  2.这个对象会被执行 `[[prototpye]]` 连接；  3.这个新对象会绑定到函数调用的 `this`；  4.如果函数没用返回其他对象，那么 `new` 调用的函数会自动返回这个新对象。  **手动实现：** ```js // new 操作符的模拟实现 function _new() {     let o = {}; // 创建一个空对象     let C = arguments[0];  // 获得构造函数     o.constructor = C;     // 将空对象的 constructor 默认指向构造函数     o.__proto___ = C.prototype;  // 进行 [[prototype]] 连接     let res = C.apply(o, arguments);  // 进行 this 绑定 并获得构造函数返回值     // 返回处理     return typeof res === "object" ? res : o; } // 测试 function Person() {     this.name = "jser" } var p = _new(Person); p.name; // ”jser“ p.constructor  // Person ```  ## 6. 理解 es6 中 class 构造以及继承的底层实现原理。 '}]}}]);