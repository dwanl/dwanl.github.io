(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{300:function(t,e,o){"use strict";o.r(e),e.default=[{title:"实现轮子",path:"/posts/Chapter4/",strippedContent:' ## 1. 手动实现 call、apply、bind。  ### 手动实现 call() 方法  **实现思路：调用 `call` 方法时，`this` 指向传入的第一个参数，参数不固定。**   ```js Function.prototype._call = function() {     let thisArg = arguments[0];     if(thisArg === null || thisArg === undefined)  thisArg = window;     let args = Array.prototype.slice.call(arguments, 1, arguments.length);     thisArg._prov_ = this; // 将 this 存储到到临时属性中，为了之后的删除操作     thisArg._prov_(...args); // 这一步相当于直接调用 this this(...args)     delete thisArg._prov_; // 删除临时属性 防止副作用 }  // 测试 let thisArg = {     name: "thisArg" } let thisArg1 = {     name: "thisArg1",     fun: function(age) {        console.log(this.name, age)      } }  thisArg1.fun.call(thisArg); // "thisArg" undefined thisArg1.fun.call(thisArg, 23); // "thisArg" 23 thisArg1.fun._call(thisArg);  // "thisArg" undefined thisArg1.fun._call(thisArg, 23) // "thisArg" 23 ```  ### 手动实现 apply() 方法  **实现思路：`apply()` 与 `call()` 的区别是第二个参数是一个数组。**  ```js Function.prototype._call = function() {     let thisArg = arguments[0];     if(thisArg === null || thisArg === undefined) thisArg = window;     let args = Array.prototype.slice.call(arguments, 1, arguments.length);     thisArg._prov_ = this;     thisArg._prov_(args);     delete thisArg._prov_; } ```  ### 手动实现 bind() 方法  **实现思路：** 1. 调用 `bind()` 方法时，返回一个新函数，普通调用时，新函数的 `this` 指向传入的参数。 2. 如果使用 `new` 调用 `bind` 返回的新函数时，`this` 指向这个新函数。[new 操作符](http://localhost:8080/posts/Chapter1/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html#_4-new-%E7%BB%91%E5%AE%9A%EF%BC%9Athis-%E6%8C%87%E5%90%91%E5%88%9B%E5%BB%BA%E7%9A%84%E7%A9%BA%E5%AF%B9%E8%B1%A1-%E3%80%82)  ```js Function.prototype._bind = function() {     let thisArg = arguments[0];  // 获取 this     let args = Array.prototype.slice.call(arguments, 1); // 获取调用 bind 时传入的参数     let that = this;     let newF = function() {         //调用 bind 返回的新函数时，         //如果通过 new 调用 this 指向返回的新函数         //普通调用时 this 指向传入的第一个参数         let ctx = this instanceof newF ? this : thisArg;            let newArgs = arguments;         let initArgs = args.concat(Array.from(newArgs));  // 合并调用 bind 时传入的参数和调用返回的新函数传入的参数         return that.apply(ctx, initArgs);   // 调用程序     }     return newF;  // 返回新函数 }  let obj1 = {     name: "obj1" } let obj = {     name: "obj",     fun: function(age) {         console.log(this)         console.log(this.name, age);     } }  var f = obj.fun._bind(obj1, 1);  f();  // 输出结果为 obj1 1  this 指向 obj1   new f(); // 输出结果为 undefined 1  this 指向返回的新对象  ```  ## 2. 手动实现符合 Promise/A+ 规范的Promise、手动实现 async await。  ### 手动实现 Promise   ## 3. 手写一个 EventEmitter 实现事件发布、订阅。   ## 4. 可以说出两种实现双向绑定的方案、可以手动实现。   ## 5. 手写 JSON.stringify、JSON.parse。   ## 6. 手写一个模版引擎，并能解释其中原理。   ## 7. 手写懒加载、下拉刷新、上拉加载、预加载等效果。 '},{title:"Vue组件通信",path:"/posts/Chapter6/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",strippedContent:" ## Vue 组件间通信方法汇总 "},{title:"CSS",path:"/posts/Chapter2/",strippedContent:' ## 1. CSS 盒模型，在不同浏览器下的差异。  ### 标准盒模型和怪异盒模型：  - **标准盒模型**：宽度只是内容（content）的宽度。      ![1265396-20171119143703656-1332857321.png](https://i.loli.net/2019/09/30/D7Wl59TfMQcdmwG.png)  - **怪异（IE）盒模型**：宽度是内容（content）+ 填充（padding）+ 边框（border）的总宽度。      ![1265396-20171119144229156-49945808.png](https://i.loli.net/2019/09/30/imUEr4skWPlI2dF.png)  ### 设置盒模型： 使用 CSS3 新增的属性 `box-sizing` 可以模拟标准盒模型和怪异盒模型。  - **content-box**：默认值，标准盒模型。      ```css     /* 标准模型 */     box-sizing: content-box;     ``` - **border-box**：IE 盒子模型。      ```css     /* IE 盒模型 */     box-sizing: border-box;     ``` - **padding-box**：`padding` 计算入 `width` 内。  ##### 注意： ```js ie8+ chrome 浏览器支持 content-box 和 border-box 属性。 Firfox （2-49）支持 padding-box 属性。 IE 浏览器在 getComputedStyle 得到的 width/height 是按照标准模式计算的，而不论 box-sizing 的取值。 ```   ## 2. CSS 所有选择器及其优先级、使用场景，哪些可以继承，如何运用 @ 规则。 #### CSS 选择器优先级及使用场景：  1. 在属性后面使用 `!important`， 权重最高。  2. 内联样式，如 `style=""`，权重 `1000`。  3. `id` 选择器，如 `#header`，权重 `100`。  4. 类、伪类、属性选择器，如 `.header div:last-child input[type="text"]`，权重 `10`。(伪类使用 `:`)  5. 元素、伪元素选择器，如 `div p ::before`，权重 `1`。(伪元素使用`::`)     6. 通配符、子选择器、相邻选择器，如 `*、>、+`，权重 `0`。     7. 继承的样式、浏览器默认的属性，没有权重。   |选择器\t|权重 |----|---- |!important|\t1/0(无穷大) |内联样式|\t1000 |ID|\t100 |类/伪类/属性\t|10 |元素/伪元素|\t1 |通配符/子选择器/相邻选择器|\t0   ```js !important > 内联样式 > ID 选择器 > 类选择器 > 元素选择器 > 通配符（*）选择器 > 浏览器默认属性 ``` #### 继承性：  1. 以 `color`、`font-`、`text-`、`line` 开头属性可继承。  2. 只要是后代就可继承。  3. `<a>` 标签文字颜色和下划线无法继承。  4. `<h>` 标签的文字大小无法继承。  #### @ 规则：  `at`规则由一个 `@` 关键字和后续的一个区块组成，如果没有区块，则以分号结束。  ##### @charset  用于提示 `css` 文件使用的字符串编码方式，它如果被使用，必须出现在最前面。  这个规则只是在给出语法解析阶段前使用，并不影响页面上展示效果。  ```css @charset "utf-8" ``` ##### @import  用于引入一个 `css` 文件，除 `@charset` 规则不会被引入外，可以引入一个文件的全部内容。  ```css @import "style.css"; @import url("style.css"); ``` ##### @ media  对设备类型进行判断，用于媒体查询。  ```css @media screen and (max-width: 600px) {     body {         background: blue;     } } ``` ##### @keyframes  `@keyframes` 规则用于定义动画关键帧。创建动画的原理是：将一套 `CSS` 样式逐渐变化为另一套样式。  ```css @keyframes .move {     from: { top: 0px; }     to: { top: 20px; } } ```  ##### @fontace `@fontace` 用于定义字体，`iconfont` 技术就是利用这个特性来实现。 ```css @font-face{ \tfont-family: myFirstFont;     src: url(\'Sansation_Light.ttf\')          ,url(\'Sansation_Light.eot\'); /* IE9 */ } div { \tfont-family: myFirstFont; } ```  ##### 其他： - **@page**：用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。  - **@counter-style**： 产生一种数据，用于定义列表项的表现。  - **@support**：support 检查环境的特性，它与 `media` 比较类似。  - **@namespace**：用于跟 `xml` 命名空间配合的一个规则，表示内部的 `css` 选择器全都带上特定命名空间。  - **@viewport**：用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 `html`的 `meta` 代替。  - **@color-profile**  - **@document**  - **@font-feature-values**   ## 3. CSS 伪类和伪元素有哪些，它们的区别和实际应用。  #### CSS 伪类：  CSS 伪元素是用来对一些选择器添加特殊效果。  - **:link**：     用于设置未被访问的链接的样式。  - **:visited**：  用于设置已经被访问的链接的样式。  - **:hover**：    用于设置将鼠标悬浮在链接上的样式。  - **:active**：   用于设置鼠标点击链接时到鼠标松开时的样式。  - **:focus**：    用于设置用键盘将焦点放在链接上时的样式（如用tab键或者上下键来移动页面焦点时）。   - **:first-child**：选中列表中的第一个元素。  - **:last-child**：选中列表中的最后一个元素。  - **:nth-child()**：括号里面的取值可以为三类。 \t```js     1. 数字： :nth-child(3) 表示选中父元素的第三个子元素。 \t2. 自变量为 n 的表达式： :nth-child(3n) 代表选中父元素的第3 6 9 .. 3n 的子元素。 \t3. even 或者 odd： 分别代表选中父元素的奇数或者偶数个子元素。     ``` - **:nth-last-child()**：与 `:nth-child()` 的不同点在于，这个是从最后一个元素开始计算，取值都是一样的。   - **:not(name)**：除了 `name` 以外的元素。  #### CSS 伪元素：  CSS 伪元素是用来对一些选择器添加特殊效果。  *CSS 伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称为伪元素。*  <img width="60%" alt="css伪元素" src="http://qiniu.mdnice.com/50ff5d10c5a8a83731a2fb8638171a09.png">  1. **::first-letter**：用于向文本的首字母设置特殊样式。  2. **::first-line**：用于向文本的首行设置特殊样式。  3. **::before**：可以向元素内容的前面插入新内容。  4. **::after**：可以向元素内容的后面插入新内容。  5. **::selection**  6. **::placeholder**  7. **::backdrop**   #### 伪类和伪元素的区别：  1. 为了避免混淆，`css3` 中的标准规定伪类使用单冒号 `:` ，伪元素使用双冒号 `::`，为了保证兼容伪元素两种使用方法都是可以的。  2. 伪类可以叠加使用，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。     ```css     .content:first-child:hover { color: #fff;}   //使用伪类     .content:first-letter { color: #fff;}   //使用伪元素     .conrent:first-letter:hover { color: #fff;}   //错误写法      ```  3. 伪类和类的优先级相同，伪元素和元素的优先级相同。    ## 4. HTML 文档流的排版规则，CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理。  ### 文档流的排版规则  元素默认从左向右、从上到下进行排列。  标准文章流分为：**块级元素**和**行内元素**。  **块级元素：**独占一行，水平方向不能与其他元素并排显示，可设置宽、高，宽度默认为父级的100%。 **行内元素：**   ## 5. 元素水平垂直居中的方案、可以实现 6 种以上并对比它们的优缺点。  <img alt="元素居中" width="30%" src="http://qiniu.mdnice.com/164c36b8b16a017a344a634667b05eb8.png">  #### 1. 绝对定位 transform 变形 （不定宽高）  *IE8 不支持*  采用 `transform: translate(-50%, -50%)` ，父元素设置相对定位 `position: relative`。  ```css body {     position: relative; } div {     position: absolute;     left: 50%;     top: 50%;     transform: translate(-50%, -50%);     background: red; } ```   #### 2. 弹性盒模型 （不定宽高）  *兼容性不好，主要应用与移动端*  当前 `div` 父级设置 `display: flex; align-items: center; justify-content: center;` 。  ```css body {     display: flex;     align-items: center;     justify-content: center; } div {     background: red; } ```  #### 3. table-cell 单元格布局（不定宽高）  *不常用*  此方法是`内联块状元素`水平垂直剧中的解决方案。  将父元素设置 `dispaly: table-cell;` 转换成表格单元格。  ```css  body {     display: table-cell;     vertical-align: middle;     text-align: center;     width: 400px;     height: 400px;     border:1px solid #666; } div {     dispaly: inline-block;     background: red; } ```  #### 4. 绝对定位 margin 负间距（定宽高）  *比较流行的解决方案*  将 `margin-left` 和 `margin-top` 的值为当前 `div` 宽度的一半的负值。  ```css div {     width: 100px;     height: 100px;     position: absolute;     left: 50%;     top: 50%;     margin-left: -50px;     margin-top: -50px;     background: red; } ``` #### 5. 绝对定位 margin：auto（定宽高）  *不确定宽高时，会充满整个屏幕。*  设置绝对定位属性 `position: absolute`， `left`、`top`、`right`、`bottom` 值均为 `0`， `margin` 值为 `auto`。  ```css div {     width: 100px;     height: 100px;     position: absolute;     left: 0;     top: 0;     right: 0;     bottom: 0;     margin: auto;     background: red; } ```  #### 6. 绝对定位 和 salc() （定宽高）  *IE 8 不支持*  `calc()` 函数动态计算实现水平垂直剧中。  ```css body {     position: relative;     width: 100%;     height: 100%; } div {     position: absolute;     width: 200px;     height: 50px;     left: calc((100% - 200px)/2);     top: calc((100% - 50px)/2);     background: red; }　　 ```  ### 总结： ```js 不宽高： 1. absolute + transform 变形 2. flex 布局  3. table-cell 布局 （不常用）  定宽高： 1. absolute + margin 负间距离 （常用） 2. absolute + margin auto 3. absolute + calc() 函数 ```   ## 6. BFC 实现原理，可以解决的问题，如何创建 BFC。  **BFC** 即 `Block Formatting Contexts`（块级格式上下文），它的布局模式为`流动模型`，是一个独立的渲染区域。 `BFC` 决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。  **具有 `BFC` 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。**  ### BFC 的生成：  - `body` 根元素。 - `float` 的值不为 `none`。 - `overflow` 的值不为 `visible`。 - `display`的值为`inline-block`、`table-cell`、`table-caption`。 - `position` 的值为 `absolute`、`fiexd`。  ### BFC 解决的问题：  #### 1. 阻止 margin 重叠（margin 塌陷问题）  在标准文档流中，块级元素之间竖直方向的 `margin` 会以大的为准，这就会导致 `margin` 重叠（塌陷）问题。  ```html <body>     <p></p>     <p></p> </body> <style>     p {         width: 100px;         height: 100px;         background: rgb(19, 149, 192);         margin: 50px;     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/2e633e8c5ac02c1678493bb5a2bec7bb.png">  **解决 margin 塌陷问题：将其放在不同的 `BFC` 容器中来解决，设置 `overflow: hidden;`。**  ```html <body>     <div>         <p></p>     </div>     <p></p> </body> <style>     div {         overflow: hidden;     }     p {         width: 100px;         height: 100px;         background: rgb(19, 149, 192);         margin: 50px;     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/5096d81caa2cc88fc31c09a13ce8e1c7.png">   #### 2. 高度塌陷问题  在通常情况下，父元素的高度会被子元素撑开，而将其子元素设置为浮动元素时，子元素就会脱离文档流，父元素就会发生高度塌陷问题，上下边界重回。  ```html <div style="border: 1px solid #333;">     <div class="child"></div> </div> <style>       div.child {         float: left;         width: 100px;         height: 100px;         background: rgb(19, 149, 192);     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/17fa72870ee407c086d9e2e6c35e31e9.png">  **解决高度塌陷问题：设置 `overflow: hidden;` 将父元素变成 BFC 容器。**  ```js BFC约束准则：计算 BFC 容器的高度时，浮动元素也参与计算。 ``` ```html <div style="border: 1px solid #333; overflow: hidden;">     <div class="child"></div> </div> <style>       div.child {         float: left;         width: 100px;         height: 100px;         background: rgb(19, 149, 192);     } </style> ``` <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/dd9bdf163c040175aa5beb718ae9466b.png">  #### 3. 阻止元素被浮动元素覆盖  由于左侧块级元素发生了浮动脱离了文档流，和右侧未发生浮动的块级元素不在同一层内，所以会发生 `div` 遮挡问题。  ```html <div class="contanier">     <div>左浮动的元素</div>     <div>没有触发 BFC 的元素</div> </div> <style>     .contanier div:nth-child(1) {         float: left;         height: 100px;         width: 100px;         background: rgb(27, 178, 228);     }     .contanier div:nth-child(2) {         width: 200px;          height: 200px;         background: rgb(248, 234, 172);     } </style> ```  <img alt="bfc" width="40%" src="http://qiniu.mdnice.com/f12e54cdeafe5eeedfe1fa3d67683109.png">  **解决元素被这遮挡问题：给右侧元素设置 `overflow: hidden;` 触发 `BFC` 来解决。**  ```js BFC 约束准则：BFC 的区域不会与浮动的元素区域重叠。 ``` ```html <div class="contanier">     <div>左浮动的元素</div>     <div>触发 BFC 的元素</div> </div> <style>     .contanier div:nth-child(1) {         float: left;         height: 100px;         width: 100px;         background: rgb(27, 178, 228);     }     .contanier div:nth-child(2) {         width: 200px;          height: 200px;         overflow: hidden;         background: rgb(248, 234, 172);     } </style> ``` <img alt="bfc" width="60%" src="http://qiniu.mdnice.com/47d7e0fb31a734bb5bee749cc75ad50c.png">  ### 总结：  ```js 1. 内部的块元素会在垂直方向上一个接一个的放置。 2. 属于同一个 BFC 的两个相邻块元素的 margin 会发生重叠（重叠）。 3. 计算BFC的高度时，浮动子元素也参与计算。（解决高度塌陷问题）。 4. BFC 容器不会与 float 的元素区域重叠。（解决浮动元素遮挡问题）。 5. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。 ```   ## 7. 可使用 CSS 函数复用代码，实现特殊效果。  #### CSS 中的函数： | 函数  | 描述 | CSS 版本 | |----- |-----|-----| |attr()|  返回选择元素的属性值 |  2  |calc()|  允许计算 CSS 的属性值（比如动态计算长度值）| 3 |linear-gradient()| 创建一个线性渐变的图像|  3 |radial-gradient()| 用径向渐变创建图像|  3 |repeating-linear-gradient()  |用重复的线性渐变创建图像|  3 |repeating-radial-gradient()  |类似 radial-gradient()，用重复的径向渐变创建图像| 3   ## 8. PostCSS、Sass、Less 的异同，以及使用配置，至少掌握一种。  https://blog.csdn.net/JoeBlackzqq/article/details/98885880  ## 9. CSS 模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染。  ### 如何防止 CSS 阻塞渲染  通过**媒体类型**和**媒体查询**，设置 `link` 标签的 `media` 属性值，根据特定场景（设备类型、显示、打印、屏幕方向变化、屏幕分辨率等）按需渲染 CSS 资源。  ```html \x3c!-- 屏幕分辨率为 800px 时，渲染 style.css --\x3e <link href="style.css" rel="stylesheet" media="(min-width: 800px)">  \x3c!-- 打印网页或者在打印预览模式下打开时，渲染 print.css  --\x3e <link rel="stylesheet" type="text/css" href="print.css" media="print"/>  \x3c!-- 手持设备（小屏幕、有限带宽）设备时，渲染 handheld.css  --\x3e <link rel="stylesheet" type="text/css" href="handheld.css" media="handheld"/> ``` **注意：**无论哪一种情况，浏览器仍会下载全部 CSS 资源，只不过将不阻塞渲染资源的优先级降低罢了。    ## 10. 熟练使用 CSS 实现常见动画，如渐变、移动、旋转、缩放等等。   ## 11. CSS 浏览器兼容性写法，了解不同 API 在不同浏览器下的兼容性情况。  ## 12. 三栏布局有几种实现方式，并说出它们的优缺点。  *三栏布局是指左栏和右栏固定宽度，中间的宽度自适应。三栏布局也被称为圣杯布局或者双飞翼布局。*  ### 1. 浮动布局   ```html <style type="text/css">     .left, .center, .right {         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         float: left;         background: red;     }     .right {         float: right;         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="right"></div>     <div class="center"></div> </body> ```  ### 2. 绝对定位布局   ```html <style type="text/css">     .left, .center, .right {         position: absolute;         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         left: 0;         background: red;     }     .right {         right: 0;         background: blue;     }     .center {         left: 300px;         right: 300px;         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```  ### 3. flex 布局   ```html <style type="text/css">     body {         display: flex;     }     .left, .center, .right {         height: 200px;     }     .left, .right {         width: 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         flex: 1;         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```   ### 4. bable-cell 表格布局   ```html <style type="text/css">     body {         display: table;         width: 100%;         height: 200px;     }     .left, .center, .right {         display: table-cell;     }     .left, .right {         width: 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```   ### 5. grid 网格布局   ```html <style type="text/css">     body {         display: grid;         width: 100%;         grid-template-rows: 200px;         grid-template-columns: 300px auto 300px;     }     .left {         background: red;     }     .right {         background: blue;     }     .center {         background: pink;     }   </style> <body>     <div class="left"></div>     <div class="center"></div>     <div class="right"></div> </body> ```  ### 总结：  ```html 1. 浮动布局：兼容性比较好，但是浮动元素脱离了文档流，会造成父容器高度塌陷，需要清除浮动。 2. 绝对定位布局：绝对定位布局快捷，但是有效性比较差，元素脱离了文档流，高度未知的时候会有问题。 3. flex 布局：移动端常用的布局方案，解决了上述两种布局的不足。 4. table-cell 表格布局：兼容性好，但是有时候单元格高度超出的时候，其他单元格的高度也会被撑高；无法设置边距；对SEO不好。 5. grid 网格布局：比较新的二维布局方式，兼容性没那么好。 ```  ## 13. 掌握一套完整的响应式布局方案。   '},{title:"Vue",path:"/posts/Chapter6/vue.html",strippedContent:" ## 1. 熟练使用 Vue 的 API、生命周期、钩子函数。  ## 2. MVVM 框架设计理念。  ## 3. Vue双向绑定实现原理、Diff 算法的内部实现。  ## 4. Vue 的事件机制。  ## 5. 从 template 转换成真实DOM的实现机制。"},{title:"数据流管理",path:"/posts/Chapter6/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86.html",strippedContent:" 1. 掌握 React 和 Vue 传统的跨组件通信方案，对比采用数据流管理框架的异同。  2. 熟练使用 Redux 管理数据流，并理解其实现原理，中间件实现原理。  3. 熟练使用 Mobx 管理数据流，并理解其实现原理，相比 Redux 有什么优势。   4. 熟练使用 Vuex 管理数据流，并理解其实现原理。  5. 以上数据流方案的异同和优缺点，不情况下的技术选型。 "},{title:"网络协议",path:"/posts/Chapter3/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html",strippedContent:" ## 1. 理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用。  ## 2. 三次握手和四次挥手详细原理，为什么要使用这种机制。  ## 3. 有哪些协议是可靠，TCP 有哪些手段保证可靠交付。  ## 4. DNS 的作用、DNS 解析的详细过程，DNS优化原理。  ## 5. CDN 的作用和原理。  ## 6. HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么？  ## 7. HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题。  ## 8. HTTP1.1、HTTP2.0 带来的改变。  ## 9. HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求。  ## 10. 理解 WebSocket 协议的底层原理、与 HTTP 的区别。"},{title:"手写",path:"/posts/Chapter2/%E6%89%8B%E5%86%99.html",strippedContent:' 1. 手写图片瀑布流效果。**[#](#1)**  2. 使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等）。**[#](#1)**  3. 使用纯 CSS 实现曲线运动（贝塞尔曲线）**[#](#3)**  4. 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点。**[#](#4)**  <h2 id="1">1. 手写图片瀑布流效果。</h2>  <h2 id="2">2. 使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等）。</h2>  <h2 id="3">3. 使用纯 CSS 实现曲线运动（贝塞尔曲线）</h2>  <h2 id="4">4. 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点。</h2>'},{title:"设计模式",path:"/posts/Chapter3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",strippedContent:" ## 1. 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等。  ## 2. 发布订阅模式和观察者模式的异同以及实际应用。  ## 3. 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用。"},{title:"实用库",path:"/posts/Chapter6/%E5%AE%9E%E7%94%A8%E5%BA%93.html",strippedContent:" 1. 至少掌握一种 UI 组件框架，如 antd design，理解其设计理念、底层实现。  2. 掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表。  3. 掌握一种 GIS 开发框架，如百度地图 API。  4. 掌握一种可视化开发框架，如 Three.js、D3。  5. 工具函数库，如lodash、underscore、moment 等，理解使用的工具类或工具函数的具体实现原理。"},{title:"编码能力",path:"/posts/Chapter4/%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B.html",strippedContent:" ## 1. 多种方式实现数组去重、扁平化、对比优缺点。  ## 2. 多种方式实现深拷贝、对比优缺点。  ## 3. 手写函数柯里化工具函数、并理解其应用场景和优势。  ## 4. 手写防抖和节流工具函数、并理解其内部原理和应用场景。  ## 5. 实现一个 sleep 函数。  "},{title:"开发和测试",path:"/posts/Chapter6/%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95.html",strippedContent:" # 开发和调试  1. 熟练使用各浏览器提供的调试工具。  2. 熟练使用一种代理工具实现请求代理、抓包，如 charls。  3. 可以使用 Android、IOS 模拟器进行调试，并掌握一种真机调试方案。  4. 了解 Vue、React 等框架调试工具的使用。 "},{title:"数据结构",path:"/posts/Chapter4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",strippedContent:" ## 1. 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点。  ## 2. 理解数组、字符串的存储原理，并熟练应用他们解决问题。  ## 3. 理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题。  ## 4. 了解图、堆的基本结构和使用场景。"},{title:"持续集成",path:"/posts/Chapter7/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90.html",strippedContent:" 1. 理解 CI/CD 技术的意义，至少熟练掌握一种 CI/CD 工具的使用，如 Jenkins。  2. 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）。 "},{title:"浏览器原理",path:"/posts/Chapter5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86.html",strippedContent:" ## 1. 各浏览器使用的 JavaScript 引擎以及它们的异同点、如何在代码中进行区分。  ## 2. 请求数据到请求结束与服务器进行了几次交互。  ## 3. 可详细描述浏览器从输入 URL 到页面展现的详细过程。  ## 4. 浏览器解析HTML代码的原理，以及构建 DOM 树的流程。  ## 5. 浏览器如何解析 CSS 规则，并将其应用到 DOM 树上。  ## 6. 浏览器如何将解析好的带有样式的DOM树进行绘制。  ## 7. 浏览器的运行机制，如何配置资源异步同步加载。  ## 8. 浏览器回流与重绘的底层原理，引发原因，如何有效避免。  ## 9. 浏览器的垃圾回收机制，如何避免内存泄漏。  ## 10. 浏览器采用的缓存方案，如何选择和控制合适的缓存方案。"},{title:"Nginx",path:"/posts/Chapter7/nginx.html",strippedContent:" ## 1. 正向代理与反向代理的特点和实例。  ## 2. 可手动搭建一个简单的 nginx 服务器。  ## 3. 熟练应用常用的 nginx 内置变量，掌握常用的匹配规则写法。  ## 4. 可以用 nginx 实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理。"},{title:"TypeScript",path:"/posts/Chapter6/TypeScript.html",strippedContent:" ## 1. 理解泛型、接口等面向对象的相关概念，TypeScript 对面向对象理念的实现。  ## 2. 理解使用 TypeScript 的好处，掌握 TypeScript 基础语法。  ## 3. TypeScript 的规则检测原理。  ## 4. 可以在 React、Vue 等框架中使用 TypeScript 进行开发。"},{title:"版本控制",path:"/posts/Chapter7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.html",strippedContent:" 1. 理解Git的核心原理、工作流程、和 SVN 的区别。  2. 熟练使用常规的 Git 命令、git rebase、git stash 等进阶命令。  3. 可以快速解决线上分支回滚、线上分支错误合并等复杂问题。"},{title:"HTML",path:"/posts/Chapter2/html.html",strippedContent:" ## 1. 从规范的角度理解 HTML，从分类和语义的角度使用标签。  ## 2. 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式。  ## 3. 元信息类标签（head、title、meta）的使用目的和配置方法。  ## 4. HTML5 离线缓存原理。  ## 5. 可以使用 Canvas API、SVG 等绘制高性能的动画。"},{title:"开发提速",path:"/posts/Chapter7/%E5%BC%80%E5%8F%91%E6%8F%90%E9%80%9F.html",strippedContent:" 1. 熟练掌握一种接口管理、接口 mock 工具的使用，如 yapi。  2. 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题。  3. 理解 TDD 与 BDD 模式，至少会使用一种前端单元测试框架。"},{title:"编译原理",path:"/posts/Chapter3/",strippedContent:" ## 1. 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序？ ## 2. 正则表达式的匹配原理和性能优化。 ## 3. 如何将JavaScript代码解析成抽象语法树(AST)。 ## 4. base64 的编码原理。 ## 1. 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序？ ## 5. 几种进制的相互转换计算方法，在JavaScript 中如何表示和转换。"},{title:"项目构建",path:"/posts/Chapter7/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA.html",strippedContent:" 1. 理解 npm、yarn 依赖包管理的原理，两者的区别。  2. 可以使用 npm 运行自定义脚本。  3. 理解 Babel、ESLint、webpack 等工具在项目中承担的作用。  4. ESLint 规则检测原理，常用的 ESLint 配置。  5. Babel 的核心原理，可以自己编写一个 Babel 插件。  6. 可以配置一种前端代码兼容方案，如 Polyfill。  7. Webpack 的编译原理、构建流程、热更新原理，chunk、bundle 和 module 的区别和应用。  8. 可熟练配置已有的 loaders 和 plugins 解决问题，可以自己编写 loaders 和 plugins。  "},{title:"Node",path:"/posts/Chapter5/node.html",strippedContent:" ## 1. 理解 Node 在应用程序中的作用，可以使用 Node 搭建前端运行环境、使用 Node 操作文件、操作数据库等等。  ## 2. 掌握一种 Node 开发框架，如 Express，Express 和 Koa 的区别。  ## 3. 熟练使用 Node 提供的 API 如 Path、Http、Child Process 等并理解其实现原理。  ## 4. Node 的底层运行原理、和浏览器的异同。  ## 5. Node 事件驱动、非阻塞机制的实现原理。  "},{title:"浏览器API",path:"/posts/Chapter5/%E6%B5%8F%E8%A7%88%E5%99%A8API.html",strippedContent:" ## 1. 浏览器提供的符合W3C标准的 DOM 操作API、浏览器差异、兼容性。  ## 2. 浏览器提供的浏览器对象模型（BOM）提供的所有全局API、浏览器差异、兼容性。  ## 3. 大量 DOM 操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)。  ## 4. 浏览器海量数据存储、操作性能优化。  ## 5. DOM 事件流的具体实现机制、不同浏览器的差异、事件代理。  ## 6. 前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、fetch、可以熟练使用第三方库。  ## 7. 浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型。  ## 8. 浏览器提供的几种存储机制、优缺点、开发中正确的选择。  ## 9. 浏览器跨标签通信。"},{title:"算法",path:"/posts/Chapter4/%E7%AE%97%E6%B3%95.html",strippedContent:" ## 1. 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗。  ## 2. 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度。  ## 3. 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用。  ## 4. 可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题。  ## 5. 前端处理海量数据的算法方案。 "},{title:"多端开发",path:"/posts/Chapter6/%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html",strippedContent:" ## 1. 单页面应用（SPA）的原理和优缺点，掌握一种快速开发 SPA 的方案。  ## 2. 理解 viewport、em、rem 的原理和用法，px、ppi、dpi、dp 的区别和实际应用。  ## 3. 移动端页面适配解决方案、不同机型适配方案。  ## 4. 掌握一种 JavaScript 移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配。  ## 5. 掌握一种 JavaScript PC 客户端开发技术，如 Electron，可搭建 Electron 开发环境，熟练进行开发，可理解 Electron 的运作原理。  ## 6. 掌握一种小程序开发框架或原生小程序开发。  ## 7. 理解多端框架的内部实现原理，至少了解一个多端框架的使用。 "},{title:"React",path:"/posts/Chapter6/react.html",strippedContent:" ## 1. React 和 Vue 选型以及两者优缺点、核心架构的区别。  ## 2. React中 setState 的执行机制，如何有效的管理状态。  ## 3. React 的事件底层实现机制。  ## 4. React 的虚拟 DOM 和 Diff 算法的内部实现。  ## 5. React的 Fiber 工作原理，解决了什么问题。  ## 6. React Router 和 Vue Router 的底层实现原理、动态加载实现原理。  ## 7. 可熟练应用 React API、生命周期等，可应用 HOC、render props、Hooks 等高阶用法解决问题。  ## 8. 基于 React 的特性和原理，可以手动实现一个简单的 React。"},{title:"Angular",path:"/posts/Chapter6/angular.html",strippedContent:" "},{title:"执行机制",path:"/posts/Chapter1/%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html",strippedContent:' ## 1. 为何 try 里面放 return，finally 还会执行，理解其内部机制。  如果存在 `finally` 代码块，`try` 中的 `return` 语句不会立马返回给调用者， 而是记录下返回值等待 `finally` 代码块执行完毕之后再返回。  **注意的几点：**  - 不管 `try` 里有没有返回值，`finally` 都会执行。  - 不管有没有异常，`finally` 都会被执行。  - `finally` 里边的返回值会覆盖 `try` 中返回的值。    ## 2. JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制。  ## 3. 宏任务和微任务分别有哪些?  **宏任务：**事件队列中每一个事件、`setImmediate（node环境）`、 `MessageChannel`、 `setTimeout`、`setInterval`。 **微任务：**`Promise.then()` 、`MutationObserver`、`process.nextTick（node环境）`。  ## 4. 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法。  ## 5. 使用`Promise`实现串行。 不对  **Promise 串行的实现原理：** 让每个串行中的任务都返回一个 `Promise`，最后统一由 `Promise` 进行 `then` 链式调用达到串行的目的。  ```js function task(fn) {     return new Promise((resolve, reject) => {         fn()         resolve();     }) } function first() {     console.log(1); } function second() {     console.log(2); } function third() {     console.log(3); }  let promise = new Promise((resolve, reject) => {     resolve("promise"); }) promise.then(task(first))     .then(task(second))     .then(task(third))     .then((res) => {         console.log(res);     }) // 1 // 2 // 3 // promise ```     ## 6. Node 与浏览器 EventLoop 的差异。  ### 事件循环   ```html 事件循环是计算机系统的一种运行机制，JavaScript 采用事件循环机制来处理异步任务的执行。 ```  [HTML规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop) 中指出：一个事件循环有一个或者多个**任务队列（Task Queue）**，一个任务队列有一组**任务（异步任务）**。  任务可以分成两种，一种是**同步任务**，另一种是**异步任务**。  **同步任务**是指在主线程上排队执行的任务，同步任务形成 `执行栈`。  **异步任务**不进入主线程排队，而是进入 `Task Queue` 排队的任务，只有 `Task Queue` 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。  ```html 执行栈中的同步任务执行完毕后，才会将 Task Queue 中的异步任务加入到主线程执行。 ```  异步任务分为：**宏任务（macrotask）**和**微任务（microtask）**。  - **宏任务（macrotask）：**     包含执行整体的 JavaScript 代码、事件回调、XHR 回调、定时器（setTimeout/setInterval/setImmediate）、IO操作以及UI渲染。  - **微任务（microtask）：**     更新应用程序状态的任务，包括 `promise` 回调、`MutationObserver`、`process.nextTick` 以及 `Object.observe`。  <img alt="event-loop" src="https://i.loli.net/2019/09/27/wNb9KecBHvyGtWL.png" width="80%">  ### Node.js 中的事件循环  当 `node.js` 运行时，会初始化一个 `EventLoop`，处理那些通过**异步api调用**、**定时器**或者调用 `process.nextTick()` 提供的 `script`或者输入到 `REPL` 中的 `script`。  下图展示了事件循环的操作顺序以及概要。  <img alt="node事件循环" src="https://i.loli.net/2019/09/27/jZNezAMIwUkbxWR.png" width="90%">  ### 浏览器中的事件循环  - 执行一个**宏任务（macrotask）**。  - 执行过程中如果遇到**微任务（microtask）**，就将它添加到微任务的任务队列中。  - **宏任务（macrotask）**执行完毕后，立即执行当前**微任务（microtask）**队列中的所有微任务（先进先出）。  - 当前**宏任务（macrotask）**执行完毕，开始检查渲染，然后 `GUI` 线程接管渲染。    <img alt="浏览器事件循环" src="https://i.loli.net/2019/09/27/vskWbIJrhP5CKX9.png" width="50%">  ### 差异： **Node.js 中**，微任务 `microtask` 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 `microtask` 队列的任务。  <img alt="node事件循环" src="https://i.loli.net/2019/09/27/THPNqOjWvIAXsBG.png" width="70%">  **浏览器环境下**，微任务 `microtask` 任务队列是每个宏任务 `macrotask` 执行完之后执行。  <img alt="浏览器事件循环" src="https://i.loli.net/2019/09/27/7rbNAxsjhLf3uZM.png" width="70%">  ## 7. 如何在保证页面运行流畅的情况下处理海量数据。  '},{title:"作用域和闭包",path:"/posts/Chapter1/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html",strippedContent:' ## 1. 理解词法作用域和动态作用域。  ### 什么是词法作用域？  **词法作用域：** 是定义在词法阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和函数作用域写在哪里来决定的。  因此当词法分析器处理代码时会保持作用域不变。词法作用域即**静态作用域**。  **动态作用域：** 需要明确的是，JavaScript 并不具有动态作用域，它只有词法作用域，简单明了。  **`this` 的执行机制表现的像动态作用域，因为 `this` 的绑定是在代码执行时确定的。**  所谓 **`动态作用域`** 是指作用域在代码执行之前都不确定，也就是说拥有动态作用域的编程语言，函数的作用域是在函数调用的时候才决定的。  为什么说 JavaScript 没有动态作用域？ ```js var num = 1; function foo() {     console.log(num); } function bar() {     var num = 2;     foo(); } bar(); // 输出结果是？ ```  假设 JavaScript 采用动态作用域，让我们分析下执行过程：  执行 `foo()`时 ，依然是从 `foo` 函数内部查找是否有局部变量 `num`。如果没有，就会顺着调用栈在调用 `foo` 函数的位置，也就是 `bar` 函数内部查找 `num` 变量，结果会打印 `2`。  而上段代码的输出结果是 `1`，在执行 `foo()` 时，先从 `foo` 函数内部查找是否有局部变量 `num`，如果没有，就根据书写的位置，查找上一层层的代码，找到了 `var num = 1`，所以结果会打印 1。所以 JavaScript 采用的是静态作用域，作用域在书写代码时就已经决定了**与调用位置没有关系。**  总结： ``` html JavaScript 只有词法作用域，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 ```  **思考：** ```js var scope = "global scope"; function checkscope() {     var scope = "local scope";     function f() {         return scope;     }     return f(); } checkscope(); ``` ```js var scope = "global scope"; function checkscope() {     var scope = "local scope";     function f() {         return scope;     }     return f; } checkscope()(); ```  ## 2. 理解 JavaScript 的作用域和作用域链。   **作用域：** JavaScript 中的作用域就是词法作用域(事实上大部分语言都是基于词法作用域的)。  `词法作用域`是一套关于引擎如何寻找变量以及会在何处找到变量的规则。  `词法作用域`最重要的特征是**它的定义过程发生在代码的书写阶段**(假设你没有使用 `eval()` 或 `with`)。   **作用域链：** 当在查找变量时，首先会在当前作用域中进行查找，如果没有找到，就会向上级进行查找，直到全局作用域。这个过程形成的关系链就是作用域。  如下代码：  ```js function foo(a) {     var b = a * 2;     function bar(c) {         console.log(a, b, c);     }     bar(b * 3); } foo(1); ```   在上段代码中，引擎执行 `console.log()` 声明，并查找 `a`、`b` 和 `c` 三个变量的引用。它首先从最内部的作用域，也就是 `bar()` 函数的作用域开始查找，引擎首先这里找到了`c`，而无法在这里找到 `a`，因此会去上一级到所嵌套的 `foo()` 的作用域中继续查找，在`foo()` 中查找到了`b`，而扔没有找到 `a`的引用， 因此引擎会继续去上一级（这级是全局作用域）继续查找，最后在找到了 `a`。最后经过一些列的向上查找，得到最后的输出结果 `1, 2, 6`。  **注意：** 词法作用域查找只会查找**一级标识符**，如果代码中引用了 `foo.bar.baz`，词法作用域查找只会试图查找 `foo` 标识符，找到这个变量后，对象属性访问规则会分别接管对 `bar` 和 `baz` 属性的访问。  ![屏幕快照 2019-09-23 下午4.25.28.png](https://i.loli.net/2019/09/23/BTSID9FgkGLid45.png)   **思考如下代码：** ```js var a = 10; var foo = {     a: 11,     bar: {         baz: function() {             console.log(a);         }     } } foo.bar.baz(); ```  ## 3. 理解 JavaScript 的执行上下文。  #### 什么是执行上下文？ 当函数执行时，会创建一个称为执行上下文的变量对象`可理解为作用域`。一个执行上下文定义了一个函数执行时的环境。  `执行上下文`也分为两种类型：  - **全局执行上下文：**代码首次执行时候的默认环境，在代码的整个执行过程中，只用一个全局执行上下文。  - **函数执行上下文：**每当执行流程进入到一个函数体内部的时候，就会创建一个函数执行上下文，`可以有任意数量的函数执行上下文`。  **执行上下文主要有两个阶段：** `创建阶段`和`执行阶段`。  **创建阶段：** - 首先，为每个函数或变量创建与外部环境的连接，这这个连接形成`作用域链`。`作用链`告诉执行上下文它应该包含什么，以及它应该在哪里查找解析函数的引用和变量的值。  - 扫描`作用链`后，将创建一个环境存储器，其中`全局上下文`、`变量`、`函数及函数参数`的创建和引用在内存中完成。  - 最后，在第一步中创建的每个执行上下文中确定 `this` 关键字的值。   **每个执行上下文包含了三个重要属性：`变量对象（VO）`、`作用域链`、`this`。**   创建阶段伪代码： ```js createContext = { // 创建阶段   \'outerEnvironmentConnection\': { // 创建外部连接         // 形成作用域链    },        \'variableObjectMapping\': {         // 变量、函数和函数参数的创建和引用在内存中完成。    },    \'valueOfThis\': {},  // 确定 this 的值 } ```  **执行阶段：**  `执行阶段`是代码在创建阶段形成的执行上下文中的运行的阶段，并且逐行分配变量值。  当执行开始时，JavaScript 引擎在其创建阶段形成的`AO对象`中查找执行函数的引用。如果在当前对象中没有找到，它将沿着作用域继续向上查找，直到它到达全局环境。  如果在全局环境中找不到函数引用，则将返回错误。  如果找到了引用并且函数正确执行，那么这个特定函数的执行上下文将从栈中弹出，接着 JavaScript 引擎将移动到下一个函数，它们的函数执行上下文将被加入到栈中并执行，以此类推。  下面结合代码来理解`两种执行上下文`的`两个阶段`：  ```js let name = "webinfoq"; var title = "execution context"; const message = "hello world";  function func1(num) {   var author = "deepak";   let value = 3;   let func2 = function multiply() {     return num * value;   }   const fixed = "Divine";   function addFive() {     return num + 5;   } } func1(10); ``` 因此`全局执行上下文`的`创建阶段`将如下所示： ```js globalExecutionContext = {  // 全局执行上下文     outerEnvironmentConnection: null,  // 全局上下文外部环境为 null     variableObjectMapping: {          name: uninitialized,  // 在创建阶段，let 声明的变量是未初始化状态         title: undefined,     // 在创建阶段，var 声明的变量表示为未定义         date: uninitialized,  // 在创建阶段，const 声明的变量是未初始化状态         func1: `<func1 reference>`,  // func1 地址引用     },     this: window // Global Object   } ``` 在`执行阶段`完成对变量的赋值等操作：  ```js globalExectutionContext = {  // 全局执行上下文     outerEnvironmentConnection: null, // 全部上下文外部环境为 null     variableObjectMapping: {         name: "webinfoq",         title: "execution context",         message: "hello world",         func1: pointer to function func1, // 指向 func1 的指针     },     this: window //Global Object } ```  当执行到 `func1` 时，将形成新的`函数执行上下文`，`创建阶段`如下所示： ```js func1ExecutionContext = {  // func1 函数执行上下文     outerEnvironmentConnection: Global,  // 外部环境为全局环境     variableObjectMapping: {        arguments: {             0: 10,             length: 1         },         num: 10,         author: undefined,  // var 声明的         value: uninitialized,  // let 声明的         func2: uninitialized,  // let 声明的         fixed: uninitialized,  // const 声明         addFive: `<addFive reference>`  // addFive 地址引用     },     this: Global Object or undefined   } ``` `执行阶段`如下所示： ```js func1ExecutionContext = {     outerEnvironmentConnection: Global,       variableObjectMapping: {        arguments: {  // 先处理 arguments 参数             0: 10,             length: 1         },         num: 10,         author: "deepak",  //变量赋值         val: 3,         func2: pointer to function func2()          fixed: "Divine"         addFive: pointer to function addFive()     },     this: Global Object or undefined } ``` **最后：**  Javascript 引擎创建执行上下文，调用栈。当有函数执行时，引擎就会创建一个新的函数执行上下文。最后所用函数执行完成后，将更新全局环境，然后全局代码完成，程序结束。   ## 4. 理解 JavaScript 执行上下文栈，可以应用堆栈信息快速定位问题。  通过阅读上一小节我们得知，每当有函数执行时，就会创建一个全新的`执行上下文`，那么怎么管理这些执行上下文呢？  JavaScript 引擎创建了**执行上下文栈** `Execution Context Stack` 来管理执行上下文。  可以把执行栈认为成一个储存函数调用的栈结构，遵循先进后出的原则。  下图为`执行上下文`入栈出栈示意图：  ![入栈出栈示意图](https://i.loli.net/2019/09/23/twsk5g6oaOBFEVq.gif)   **JavaScript 引擎是单线程执行，所有代码都是排队执行：**  - 一开始执行的是全局代码，首先创建`全局执行上下文`，然后将该执行上下文压入执行栈中。  - 当执行一个函数，就会创建该`函数执行上下文`，然后将其压入执行栈的顶部。  - 函数执行完成后，执行上下文从底部退出，等待垃圾回收。  **调用栈的应用：** ```js 你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。 另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具， 其中包含 JavaScript 调试器。 就本例来说，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger 语句。 运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。 因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 ```  ## 5. this 的原理以及几种不同使用场景的取值。  **this** 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于`函数调用时`的各种条件。  **this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**  当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。`this` 就是记录的其中一个属性，会在函数执行的过程中用到。  理解`调用栈`和`调用位置`： ```js function baz() {     // 当前调用栈是: baz     console.log( "baz" );     bar(); // <-- bar 的调用位置  } function bar() {     // 当前调用栈是 baz -> bar     console.log( "bar" );     foo(); // <-- foo 的调用位置，当前调用位置在 baz 中 } function foo() {     // 当前调用栈是 baz -> bar -> foo      // 因此，当前调用位置在 bar 中     console.log( "foo" ); } baz(); // <-- baz 的调用位置，当前调用位置是全局作用域   ``` **this 绑定遵循以下四种规则：** `默认绑定`、`隐式绑定`、`显示绑定`、`new 绑定`。  #### 1. 默认绑定：独立函数调用，`this` 指向全局对象。调用时前边没有或省略 `.` 操作符号。 ```js function foo() {      console.log(this.a); } var a = 2; // window.a = 2; foo(); // window.foo(); ``` **注意：** ```js 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined. ``` #### 2. 隐式绑定：调用位置是否有上下文对象，也就是说，函数被作为某个对象的方法被调用时，`this` 指向那个对象。  ```js function foo() {      console.log(this.a); } var obj2 = {      a: 42,     foo: foo  }; var obj1 = {      a: 2,     obj2: obj2  }; obj1.obj2.foo(); // 42 ``` 上段代码中，词法作用域只会查找最顶层的 `obj1`，按着对象属性访问规则，会在自身上查找属性 `obj2`，所以 `this` 指向 `obj2`，\b所以 `this.a` 等于 `bj2.a`。  **对象属性引用链中只有最顶层或者说最后一层会影响调用位置。**   **注意：** ```js 会出现隐式丢失的情况： this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定， 从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。 ```  #### 3. 显示绑定：使用 `call`、`apply` 或者 `bind` 绑定到指定的对象。**this指向传入的第一个参数。**  ```js function foo() {      console.log(this.a); } var obj = {      a:2 }; var bar = function() {      foo.call(obj); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的 bar 不可能再修改它的 this  bar.call( window ); // 2 ``` **注意：** ```js 把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则。 ```   #### 4. `new` 绑定：`this` 指向创建的空对象 `{}`。  使用 `new` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：  1. 创建(或者说构造)一个全新的对象。  2. 这个新对象会被执行`[[proto]]`连接。  3. 这个新对象会绑定到函数调用的 `this`。  4. 如果函数没有返回其他对象，那么 `new` 表达式中的函数调用会自动返回这个新对象。  ##### 总结：关于 `this` 绑定的场景，遵循以下 `4` 条规则：  1. 由 `new` 调用? 绑定到新创建的对象。  2. 由`call`或者 `apply` 或者 `bind` 调用? 绑定到**指定的对象**。  3. 由上下文对象调用? 绑定到那个上下文对象。  4. 在严格模式下绑定到 `undefined`，否则绑定到**全局对象**。  ##### 拓展： ``` 绑定优先级：new 绑定 > 硬绑定 > 隐式绑定 > 默认绑定 ``` *本节参考：你不知道的 JavaScript（上卷）*    ## 6. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用。  ##### 闭包的概念：闭包是可以记住并有权访问所在函数作用域的`函数`，即使这个`函数`是在当前函数作用域之外执行。  ```js function add() {     var a = 1;     return function closure(b) {          return a + b;      } } const closure = add(); console.log(closure(1)); // 2 ```  这段代码中，调用 `add()` 时会生成一个函数执行上下文，并推入到`执行上下文栈中`。 `add` 函数执行完毕后，它的执行上下文会从执行栈中推出，同时局部变量 `a` 会被清理才对，但我们在执行 `console.log(closure(1));`时却输出了结果 `2`。  我们发现，调用`add()`时，会返回一个函数 `ƒ closure(b) { return a + b; }`，说明局部变量 `a` 存储于 `closure` 函数作用域中，因此我们能得到结果 `2`。  返回的这个函数 `ƒ closure(b) { return a + b; }` 就是我们将要介绍的 **`闭包`**。  ### 闭包的实现原理  ##### 闭包是如何实现对外部作用域的变量存储的？  **我们需要先搞清楚：**它是拷贝了变量 `a` 的值到其作用域中，还是 `a` 压根没有被销毁，而是给了闭包 `closure` 访问的权限。  ```js function add() {     var a = 1;     ++a;     return function closure(b) {         return a + b;     } } const closure = add(); console.log(closure(1)); ```  首先，我们在这段代码 `++a` 处打上断点，看下实际执行情况。  ![屏幕快照 2019-09-24 下午2.57.06.png](https://i.loli.net/2019/09/24/Raiyz5VeuqWP6jD.png)![屏幕快照 2019-09-24 下午2.53.13.png](https://i.loli.net/2019/09/24/p4urbaPhGJA1fxi.png)  我们发现调用栈为 `add`，在执行到断点处时，\b作用域对象 `Scope` 中存储了当前局部变量 `a` 的值为 `2`，这是我们预期的结果。  接着我们在代码 `return a + b;` 处打上断点，实际情况如下图所示：  ![屏幕快照 2019-09-24 下午3.06.28.png](https://i.loli.net/2019/09/24/itPuok97KMTNBfD.png)![屏幕快照 2019-09-24 下午2.49.18.png](https://i.loli.net/2019/09/24/SYpT7jrPiD8oBEV.png)  从 `Debug` 的结果来看，当执行到断点 `return a + b;` 处时，调用栈 `add` 被推出，当前调用栈变成了 `closure`，作用域对象 `Scope` 中局部变量 `a` 被销毁，只保存了当前调用栈 `closure` 中的变量 `b`。  而运行到此时，多出了一个 `Closure` 对象，它持有所在作用域 `add` 中的局部变量 `a` 属性，它的值为 `2`。  **这里我们应该能得知：**它是拷贝了变量 `a` 的值到其作用域中进而给了闭包 `closure` 访问的权限。   **总结：**  JavaScript 在执行时，如果遇到上述含有 `闭包` 的代码，它会在内存开辟出一块空间，这个内存空间称为 `Closure` 对象，**它用来存储所在函数作用域中的变量，因此其所在作用域的变量即使被销毁，在外部也能访问到存储下来的变量。**  ***闭包查找变量是沿着作用域链向上查找的，本文并没有介绍的作用域链相关的知识，因为个人感觉闭包能缓存变量的原理并不是因为作用域链，作用域链只能说明闭包访问的范围。***  ### 闭包的应用场景 - **jQuery** 源码的实现（ jQuery 就是一个大的闭包 ）。 - 函数节流。 - **Ajax** 的回调函数。 - 处理循环中的异步操作。  ## 7. 理解堆栈溢出和内存泄漏的原理，如何防止？  ## 8. 如何处理循环的异步操作？  在实际项目中，我们可能会遇到，在循环中发起接口调用的请求，就像这样： ```js  const parmas = ["todos/1", "todos/2", "todos/3"]; const urls = \'https://jsonplaceholder.typicode.com\'; for(var i = 0; i < parmas.length; i++) {     fetch(urls + ${parmas[i]}).then(function(res) {         console.log(res)     }) } ```  #### async await #####1. 串行执行： ```js const urls = [   \'https://jsonplaceholder.typicode.com/todos/1\',   \'https://jsonplaceholder.typicode.com/todos/2\',   \'https://jsonplaceholder.typicode.com/todos/3\' ];  async function getTodos() {   for(var i = 0; i < urls.length; i++) {       const todo = await fetch(urls[i]);       console.log(todo);   } } getTodos()  ``` ##### 2. 并行执行： ```js // 第一种 async function getData() {   const promises = urls.map(url => fetch(url))   for (const promise of promises) {     const data = await promise     console.log(data);   } } getData()  // 第二种 async function getData() {     const promises = urls.map(async (url, index) => {         const data = await fetch(url);         console.log(data);     })     await Promise.all(promises); } getData(); ```   ## 9. 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理。  ```js  ```'},{title:"语法和API",path:"/posts/Chapter1/%E8%AF%AD%E6%B3%95%E5%92%8CAPI.html",strippedContent:' ## 1. 理解 `ECMAScript` 和 `JavaScript` 的关系。  ECMAScript 和 JavaScript 的关系是：前者是后者的规格，后者是前者的一种实现，在日常场合，这两个词是可以互换的。  ```js ECMAScript 是国际标准化组织 ECMA 为 JavaScript 制定的一种标准，之所以不叫 JavaScript： 一是因为商标问题，JavaScript 本身也已经被 Netscape 公司注册为商标，只有 Netscape 公司可以合法地使用 JavaScript 这个名字。 二是想体现这门语言的制定者是 ECMA，这样有利于保证这门语言的开放性和中立性。 ```  ## 2. 熟练运用 `es5`、`es6` 提供的语法规范。 这个只能在实践中多积累啦。 [babel 官网 Learn ES2015](https://babeljs.io/docs/en/learn) 提供了全面的语法介绍和使用。  ## 3. 熟练掌握 `JavaScript` 提供的全局对象（例如 `Date`、`Math`）、全局函数（例如 `decodeURI`、`isNaN`）、全局属性（例如`Infinity`、`undefined`）。  ## 4. 熟练应用 `map`、`reduce`、`filter` 等高阶函数解决问题。  列举一些 `map`、`reduce`、`filter` 高频使用场景。  ### [map 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map) `map()` 方法返回一个新数组，其结果是该数组每个成员调用提供的函数后返回的新数组。 ```js var arr = [1, 2, 3, 4]; var newArr = arr.map(x => x * 2); console.log(newArr); // [2, 4, 6, 8] ```  ### map 方法使用场景：  ##### 1. 将字符串成员转换为数组项  ```js var str = "yuanyuan"; var arr = Array.prototype.call(str, x => x + ""); console.log(arr); //["y", "u", "a", "n", "y", "u", "a", "n"] ``` ##### 2. 在 React 中用来渲染列表数据 ```js const names = ["jser", "phper", "javaer", "pythener"]; const NamesList = () => (<ul>{names.map(name => <li key={name}> {name} </li>)}</ul>); const rootElement = document.getElementById("root"); ReactDOM.render(<NamesList />, rootElement); ```  ##### 3. 格式化数组对象 ```js const myUsers = [     { name: \'jser\', age: 18 },     { name: \'phper\', age: 19 },     { name: \'javaer\', age: 20 } ] const mapFormat = myUsers.map((item) => {     const result = [];     result[item.name] = item.age;     result.sex = "男";     return result; }) console.log(mapFormat); // [{ jser: 18, sex: "男" },{ phper: 19, sex: "男" },{ javaer: 20, sex: "男" }] ``` ### [reduce 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)  `reduce()` 方法对数组每个元素执行一个 `reduce` 函数，将其结果汇总为单个返回值。  ```js const array = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) => accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array.reduce(reducer));  // 10 ```  ### reduce 方法使用场景：  ##### 1. 对数组进行求和 ```js 参见上段代码 ``` ##### 2. 将二维数组转换为一维数组 ```js let array = [[1, 2], [3, 4], [5, 6]]; const reducer = (acc, cur) => acc.concat(cur); let result = array.reduce(reducer, [])   // 将 [] 作为回到函数第一个参数 console.log(result); //[1, 2, 3, 4, 5, 6] ```  ##### 3. 计算数组每个元素出现的次数 ```js let names = [\'jser\', \'jser\', \'javaer\', \'javaer\', \'phper\', \'pythener\'] let obj = {}; names.reduce((acc, cur) => {     acc[cur]? acc[cur]++ : acc[cur] = 1;     return acc; }, obj)   // 将 obj 作为回到函数第一个参数 obj  //解析： //第一次遍历：acc = {} cur = "jser" //第二次遍历：acc = {jser: 1} cur = "jser" //第三次遍历：acc = {jser: 2} cur = "javaer" //第四次遍历：acc = {jser: 2, javaer: 1} cur = "javaer" //第五次遍历：acc = {jser: 2, javaer: 2} cur = "phper" //第六次遍历：acc = {jser: 2, javaer: 2, phper: 1} cur = "pythener" //第七次退出：acc = {jser: 2, javaer: 2, phper: 1, pythen: 1}   console.log(obj) // {jser: 2, javaer: 2, phper: 1, pythen: 1}   ```  ### [filter 方法介绍：](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)  `filter()` 方法创建一个新数组，其成员是通过提供函数测试的所有元素。 ```js const words = [\'spray\', \'limit\', \'elite\', \'exuberant\', \'destruction\', \'present\']; const result = words.filter(word => word.length > 6);  // 元素的长度大于6的通过测试 console.log(result); ["exuberant", "destruction", "present"] ``` ### filter 方法使用场景  ##### 1. 数组去重 ```js function unique(arr) {   return arr.filter((item, index, arr) => arr.indexOf(item) === index); } let arr = [1, 1, false, false, undefined, undefined, null, null]; unique(arr); // [1, false, undefined, null] ```   ## 5. `setInterval`需要注意的点，使用 `setTimeout` 实现 `setInterval`。  **setInterval 需要注意的点：**  - `setInterval` 第一个参数可以是一个函数签名也可以是一个被引号包裹的函数调用。     ```js     setInterval(engine, 1000);      //or     setInterval("engine()", 1000);     ```  - 第一个参数不能传递带参数的函数。     ```js      setInterval(function(args), 300)  // 报错     ```      - `setInterval` 如果不使用 `clearInterval` 停止，将会一直运行，即使第二次使用传入了不同的函数处理程序。  - `setInterval` 只能在方法外使用。   **使用 setTimerout 实现 setInterval：**  ```js // 递归调用 _setInterval(); function _setInterval() {     console.log(1);     let timer = setTimeout(() => {         _setInterval();         clearInterval(timer);     }, 1000) } ```  ## 6. JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题。  ### 修饰符 修饰符写在结尾的 `/` 之后，影响整个正则表达式的匹配行为。  - **`i` 不区分大小写（ignore）：**      在匹配时忽略英文字母的大小写。  - **`g` 全局匹配（global）：**      正则表达式默认只会返回第一个匹配结果，使用标志符 `g` 则可以返回所有匹配。  - **`m` 多行匹配（multiline）：**      将开始和结束字符（ `^` 和 `$` ）视为在多行上工作。      即分别匹配每一行（由 `\\n` 或 `\\r` 分割）的开始和结束，而不只是只匹配整个输入字符串的最开始和最末尾处。  ### 字符集 用于匹配字符集中的任意一个字符。  - `[xyz]`：匹配所包含的`x`、`y`、`z` 任意一个字符。  - `[^xyz]`：补集，匹配除 `x`、`y`、`z` 以外的字符。  - `[a-z]`：匹配从 `a` 到 `z` 的任意字符。  - `[^a-n]`：补集，匹配除`a` 到 `n` 的其他字符。  - `[A-Z]`：匹配从 `A` 到 `Z` 的任意字符。  - `[0-9]`：匹配从 `0` 到 `9` 的任意数字。  ```js 匹配所有的字母和数字可以写成：/[a-zA-Z0-9]/ 或者 /[a-z0-9]/i ```  ### 量词 使用量词达到重复匹配的目的。  - **`{n}`**：匹配 `n` 次。  - **`{n,m}`**：匹配 `n-m` 次。  - **`{n,}`**：匹配 `>=n` 次。  - **`?`**：匹配 `0 || 1` 次。  - **`*`**：匹配 `>=0` 次，等价于 `{0,}`。  - **`+`**：匹配 `>=1` 次，等价于 `{1,}`。   ### 元字符 元字符就是描述字符的字符，它用于对字符表达式的内容、转换及各种操作信息进行描述。  - **`\\d`**：匹配任意数字，等价于 `[0-9]`。  - **`\\D`**：匹配任意非数字字符，`\\d` 的补集。  - **`\\w`**：匹配任意基本拉丁字母表中的字母和数字，以及下划线，等价于 `[A-Za-z0-9_]`。  - **`\\W`**：匹配任意非基本拉丁字母表中的字母和数字，以及下划线，`\\w` 的补集。  - **`\\s`**：匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。  - **`\\S`**：匹配一个非空白符，`\\s` 的补集。  - **`\\b`**：匹配一个零宽单词边界，如一个字母与一个空格之间。     ```js     例如 /\\bno/ 匹配 "at noon" 中的 "no"。     /ly\\b/ 匹配 "possibly yesterday." 中的 "ly"。     ```  - **`\\B`**：匹配一个零宽非单词边界，如两个字母之间或两个空格之间。     ```js     例如，/\\Bon/ 匹配 "at noon" 中的 "on"。     /ye\\B/ 匹配 "possibly yesterday." 中的 "ye"。     ```  - **`\\t`**：匹配一个水平制表符（tab)。  - **`\\n`**：匹配一个换行符（newline)。  - **`\\r`**：匹配一个回车符（carriage return)。  ### 特殊字符 它们不会按照字面意思进行匹配，而有特殊的意义，比如前文讲过用于量词的 `?`、`*`、`+`。  其他常见的特殊字符有：  - **`\\`**：转义字符。可以将普通字符转成特殊字符。也可以将特殊字符转成字面意思。     ```js     比如 \\+ 匹配 +。     ```  - **`.`**：匹配任意单个字符，但是换行符除外（`\\n`, `\\r`, `\\u2028`或 `\\u2029`）。     ```js     在字符集中 [.]，无特殊含义，即表示 \'.\' 的字面意思。     ```  - **`|`**：替换字符，匹配 `|` 前或后的表达式。     ```js     比如需要同时匹配 "bear" 和 "pear"，可以使用 /(b|p)ear/ 或者 /bear|pear/。     但是不能用 /b|pear/，该表达式只能匹配 "b" 和 "pear"。     ```  - **`^`**：匹配输入的开始。     ```js     比如，/^A/ 不匹配 "an Apple" 中的 "A"，但匹配 "An apple" 中的 "A"。     ```  - **`$`**：匹配输入的结尾。     ```js     比如，/t$/ 不匹配 "eater" 中的 "t"，但匹配 "eat" 中的 "t"。     ^ 和 $ 在表单验证时常需要使用，因为需要验证从开始到结尾的一个完整输入，而不是匹配输入中的某一段。     ```   ### 分组 - **`(xyz)`**：捕获分组，匹配并捕获匹配项。     ```     例如，/(foo)/ 匹配且捕获 "foo bar." 中的 "foo"。     被匹配的子字符串可以在结果数组的元素 [1], …, [n] 中找到，     或在被定义的 RegExp 对象的属性 $1, …, $9中找到。     ``` - **`(?:xyz)`**：非捕获分组，匹配但不会捕获匹配项，匹配项不能再次被访问到。  - **`\\n`**：n 是一个正整数，表示反向引用，指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。 \t```js \t例如，/apple(,)\\sorange\\1/ 匹配 "apple, orange, cherry, peach." 中的 "apple,orange,"。     ```  ### 断言  - **`x(?=y)`**：仅匹配被 `y` 跟随的 `x`。 \t```js     例如， /bruce(?=wayne)/，如果 "bruce" 后面跟着 wayne，则匹配之。     /bruce(?=wayne|banner)/，如果 "bruce" 后面跟着 "wayne" 或者 banner，则匹配之。     但是，"wayne" 和 "banner" 都不会在匹配结果中出现。     ``` \t - **`x(?!y)`**：仅匹配不被 `y` 跟随的 `x`。 \t```js     /\\d+(?!.)/ 只会匹配不被 "." 跟随的数字。      ```  **`/\\d+(?!\\.)/.exec(\'3.141\')` 匹配 "141"，而不是 "3.141"。**   ### 应用 #### 1. 匹配手机号码  目前国内的手机号码是 `1(3/4/5/7/8)` 开头的 `11` 位数字，因此手机号码的正则可以分解为以下几部分：  - 以 `1` 开头：`/^1/`。  - 第 `2` 位为 `3、4、5、7、8` 中的一个：`/[34578]/` 或 `/(3|4|5|7|8)/`。  - 剩余 `3-11` 位均为数字，并以数字结尾：`/\\d{9}$/`。  - 组合起来即为 `/^1[34578]\\d{9}$/` 或 `/^1(3|4|5|7|8)\\d{9}$/`，因为使用捕获括号存在性能损失，所以推荐使用第一种写法。  #### 2. 匹配电子邮件  标准的电子邮件组成为 `<yourname>@<domain>.<extension><optional-extension>`，每部分的格式标准为（进行了相应的简化，主要为展示如何书写正则）：  - `yourname`：任意英文字母`（a-z/A-Z）`、数字`（0-9）`、下划线`（_）`、英文句点`（.）`、连字符`（-）`，长度大于 `0`。   -`domain`：任意英文字母`（a-z/A-Z）`、数字`（0-9）`、连字符`（-）`，长度大于 `0`。  - `extension`：任意英文字母`（a-z/A-Z）`，长度 `2-8`。  - `optional-extension`：`"."` 开头，后面跟任意英文字母`（a-z/A-Z）`，长度 `2-8` 可选。  每部分的正则表达式为：  - **yourname**：`/[a-z\\d._-]+/`；  - **domain**：`/[a-z\\d-]+/`；  - **extension**： `/[a-z]{2,8}/`；  - **optional-extension**：`/(.[a-z]{2,8})?/`。  组合起来形成最后的正则表达式：`/^([a-z\\d._-]+)@([a-z\\d-]+)\\.([a-z]{2,8})(\\.[a-z]{2,8})?$/`；为了增加可读性可以将每部分用 `"()"` 包起来，并不要忘记起始和结束符 `^$`。  *本节参考[还不会正则表达式？看这篇！](https://mp.weixin.qq.com/s/f6ii_hKgY0gLdhMFda6S6Q)*  ## 7. JavaScript 异常处理的方式，统一的异常处理方案。  异常处理的方式：使用 `try...catch` 捕获异常并抛出、在一些不合理的情况下主动抛出异常 `throw...`。 '},{title:"变量和类型",path:"/posts/Chapter1/",strippedContent:' ## 1. JavaScript 规定了几种语言类型？  JavaScript 规定了两种数据类型： - **原始类型：** `string`、`number`、`boolean` 、`null`、`undefined`、`symbol`  - **引用类型：** `Object`、`Function`、`Array`   ## 2. JavaScript 对象的底层数据结构是什么？  ## 3. Symbol 类型在实际开发中的应用？  ## 4. JavaScript 变量类型在内存中的具体存储形式？  - **基本类型：** 保存在`栈`内存中，通过按值访问，值都有固定的大小。  - **引用类型：** 保存在`堆`内存中，通过按引用访问（不允许直接访问堆内存），值大小不固定。  ```js let a: string = "123"; // 栈内存 let b: number = 123; // 栈内存 let c: null = null; // 栈内存 let d: object = { x: 10 }; // 变量d存在于栈中，{ x: 10 }作为对象存在于堆中 let e = [1, 2, 3]; // 变量e存在于栈中，[1, 2, 3]作为对象存在于堆中 ``` 如图所示：  ![屏幕快照 2019-09-20 下午3.26.23.png](https://i.loli.net/2019/09/20/Cu3irzOYkqGFfsD.png)  拓展：  - **原始类型**的比较是值的比较，只有它们的值相等时才相等。  - **引用类型**的比较是按引用的比较，当且仅当它们引用同一个基本对象时，它们才相等。  ## 5. 基本类型对应的内置对象，以及他们之间的装箱拆箱操作？  ## 6. 理解值类型和引用类型？  ## 7. null 和 undefined 的区别？ **null** 表示`"空对象"`，即此处应该有值： ```js  - 在 if 语句中，会转换为 false. - 转换为数字时，表示为 0。 - 作为函数的参数，表示该函数的参数不是对象。 - 作为对象原型链的终点 Object.getPrototypeOf(Object.prototype); ``` **undefined** 表示  `"缺少值"`，就是此处应该有一个值，但是还没有定义： ```js - 在 if 语句中，会转换为 false. - 转换为数字时，表示为 NaN. - 变量被声明了，但没有被赋值，就等于 undefined. - 调用函数时，没有提供对应的实参，该参数显示为 undefined. - 对象没有赋值的属性，该属性的值为 undefined. - 函数没有返回值时，默认返回 undefined. ``` 拓展： ```html typeof null 为 "object" 的解释： 不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型。 null 的二进制表示都是 0，自然前三位都是 0，所以执行 typeof null 时，会返回 ”object”。 ```  ## 8. 至少说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型？  ### typeof `typeof`是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。 ```js typeof \'\';             // string 有效 typeof 1;              // number 有效 typeof Symbol();       // symbol 有效 typeof true;           // boolean 有效 typeof undefined;      // undefined 有效 typeof null;           // object 无效 typeof [] ;            // object 无效 typeof new Function(); // function 有效 typeof new Date();     // object 无效 typeof new RegExp();   // object 无效 ``` **缺点：**  ```js typeof 对于引用类型中的数组、日期、正则等类型的处理，只返回了处于其原型链最顶端的 Object 类型； 对应 null 返回的是 "object"，而 null 有自己的数据类型 Null。 ``` ### instanceof `instanceof` 是用来判断 `a` 是否为 `B` 的实例，表达式为：`a instanceof B`，如果 `a` 是 `B` 的实例，则返回 `true`，否则返回 `false`。 **在这里需要特别注意的是：`instanceof` 检测的是原型对象。** ```js // 伪代码实现 instanceof (a,B) = {     var L = a.__proto__;     var R = B.prototype;     if(L === R) {         // A的内部属性 __proto__ 指向 B 的原型对象         return true;     }     return false; } ``` 从上述过程可以看出，当 `a` 的 `__proto__` 指向 `B` 的原型对象时，就认为 `a` 就是 `B` 的实例，我们再来看几个例子： ```js [] instanceof Array; // true {} instanceof Object;// true new Date() instanceof Date;// true   function Person(){}; new Person() instanceof Person;   [] instanceof Object; // true new Date() instanceof Object;// true new Person instanceof Object;// true ``` 我们发现，虽然 `instanceof` 能够判断出 `[]` 是 `Array` 的实例，但它认为 `[]` 也是 `Object` 的实例，为什么呢？  我们来分析一下 `[]`、`Array`、`Object` 三者之间的关系：  从 `instanceof` 能够判断出 `[].__proto__`  指向 `Array.prototype`，而 `Array.prototype.__proto__` 又指向了 `Object.prototype`，最终 `Object.prototype.__proto__`指向了 `null`，标志着原型链的结束。  因此，`[]`、`Array`、`Object` 就在内部形成了一条原型链：  ![849589-20160112232510850-2003340583.png](https://i.loli.net/2019/09/21/fevn2goItbBzqKc.png)  从原型链可以看出，`[]` 的 `__proto__`  直接指向 `Array.prototype`，间接指向 `Object.prototype`，所以按照 `instanceof` 的判断规则，`[]` 就是 `Object` 的实例。依次类推，类似的 `new Date()`、`new Person()` 也会形成一条对应的原型链 。  **缺点：**  ```js instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 ```  **拓展：**  `instanceof` 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。  ```js var iframe = document.createElement(\'iframe\'); document.body.appendChild(iframe); xArray = window.frames[0].Array; var arr = new xArray(1,2,3); // [1,2,3] arr instanceof Array; // false ``` ### Array.isArray()  针对数组的这个问题，ES5 提供了 `Array.isArray()` 方法。该方法用以确认某个对象本身是否为 `Array` 类型，而不区分该对象在哪个环境中创建。 ```js if (Array.isArray(value)){    //对数组执行某些操作 } ``` `Array.isArray()` 本质上检测的是对象的 `[[Class]]` 值，`[[Class]]` 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 `[object Xxx]` ，`Xxx` 就是对应的具体类型。对于数组而言，`[[Class]]` 的值就是 [object Array] 。  ### toStrig()  `toString()` 是 `Object` 的原型方法，调用该方法，默认返回当前对象的 `[[Class]]`。这是一个内部属性，其格式为 `[object Xxx]`，其中 `Xxx` 就是对象的类型。  对于 `Object` 对象，直接调用 `toString()` 就能返回 `[object Object]`。而对于其他对象，则需要通过 `call / apply` 来调用才能返回正确的类型信息。  ```js Object.prototype.toString.call(\'\') ;   // [object String] Object.prototype.toString.call(1) ;    // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object Window] window 是全局对象  ```  ### constructor  当一个函数 `F` 被定义时，JS 引擎会为 `F` 添加 `prototype` 原型对象，然后再在 `prototype`上添加一个 `constructor` 属性，并让其指向 `F` 的引用。  如下所示：  ![849589-20170508125250566-1896556617.png](https://i.loli.net/2019/09/21/iFpwzxHVIlKDRJL.png)  当执行 `var f = new F()` 时，`F` 被当成了构造函数，`f` 是 `F` 的实例对象，此时 `F` 原型上的 `constructor` 传递到了 `f` 上，因此 `f.constructor == F`。  ![849589-20170508125714941-1649387639.png](https://i.loli.net/2019/09/21/veHsCKjrDYIFUAW.png)  可以看出，`F` 利用原型对象上的 `constructor` 引用了自身，当 `F` 作为构造函数来创建对象时，原型上的 `constructor `就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 `F` 就是新对象的类型。**这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。**  同样，`JavaScript` 中的内置对象在内部构建时也是这样做的：  ![849589-20170508131800457-2091987664.png](https://i.loli.net/2019/09/21/uHZb16KyLsComNq.png)  **细节问题：**  **`null` 和 `undefined` 是无效的对象，因此是不会有 `constructor` 存在的，这两种类型的数据需要通过其他方式来判断。**  函数的 `constructor` 是不稳定的，这个主要体现在自定义对象上，当开发者重写 `prototype` 后，原有的 `constructor` 引用会丢失，`constructor` 会默认为 `Object`。  ![849589-20170508132757347-1999338357.png](https://i.loli.net/2019/09/21/9hrsbizMQag3kpI.png)   因为 `prototype` 被重新赋值的是一个 `{}`， `{}` 是 `new Object()` 的字面量，因此 `new Object()` 会将 `Object` 原型上的 `constructor` 传递给 `{}`，也就是 `Object` 本身。  因此，为了规范开发，在重写对象原型时一般都需要重新给 `constructor` 赋值，以保证对象实例的类型不被篡改。  **总结：** - `typeof` 检测引用类型和 `null` 时，除了函数都会显示 `"object"`。 - 检测函数使用推荐使用 `typeof`。 - **instanceof：** 检测对象是否是某个构造函数的实例。 - **Array.isArray()：** 判断是否为 `Array` 数据类型时使用。 - **constructor：** 可以使用 `constructor` 属性验证实例的原始类型（与操作符 `instanceof` 非常类似）。 - **toString()：** 万能。  ```js 检测对象的属性是否存在使用 in 运算符或者使用 Object.hasOwnProperty() ```  *本节参考：[一像素-判断数据类型的四种方法](https://www.cnblogs.com/onepixel/p/5126046.html)*  ## 9. 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用？  ### 自动转换为`boolean`类型的的情况：  |数据类型|转换之后的值| |---|---| |数字 0|false| |NaN|  false |空字符 ”|false |null |\tfalse |undefined|\tfalse |非 0 数字|\ttrue |非空字符串\t|true |非 null 对象类型\t|true  ## 10. 出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript 处理大数字的方法、避免精度丢失的方法？ '},{title:"原型和原型链",path:"/posts/Chapter1/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.html",strippedContent:' ## 1. 理解原型设计模式以及 JavaScript 中的原型规则。  我们创建的每个函数都有一个 `protoype` 属性，这个 `prototype` 属性是一个指针，指向**原型对象**。  **这个对象的用途**：包含由特定类型的所有实例共享的属性和方法（通俗的说就是，所有特定类型的实例都可以共享这个对象上的属性和方法）。  ### 原型对象的两种赋值方法：  ##### 1. 给原型对象添加属性或方法： ```js function Person() {} // Person 原型对象上默认只有一个 constructor 属性 // 这个 constructor 指向 Person Person.prototype.name = "jser"; Person.prototype.age = 16; Person.prototype.sayName = function() {     return this.name; }  let per1 = new Person(); let per2 = new Person(); per1.sayName === per2.sayName; // true per1.age === per2.age;  // true ``` 正如上边所说，实例 `per1` 和 `per2` 共享 `Person` 原型对象的属性和方法。  ##### 2. 重写原型对象： ```js function Person() {} Person.prototype = {     name: "jser",     age: 16,     sayName() {         return this.name;     } } let per1 = new Person(); let per2 = new Person(); per1.sayName === per2.sayName; // true per1.age === per2.age;  // true ``` 这种方式会重写原型对象，重写后的原型对象默认的 `constructor` 属性不再指向 `Person` 此时它指向 `Object`。（下文会有讲到）  我们可以手动将它指向 `Person`： ```js Person.prototype = {     constructor: Person,     ... } ```  ### 原型对象内存分析：  ![屏幕快照 2019-09-25 下午4.25.37.png](https://i.loli.net/2019/09/25/kC9hIFf1PJosjHX.png)  默认情况下，原型对象 `Person.prototype` 会包含一个 `constructor` 属性，这个属性上也有一个 `prototype` 属性，这个属性是一个指针，指向**原型对象**。  ```js 创建的实例也有 constructor 属性，可以使用 实例.constructor.prototype 去修改或扩展原型对象。 ``` ```js Person.prototype.constructor === Person // true Person.prototype.constructor.prototype === Person.prototype // true ```  当调用构造函数创建一个新实例后，该实例内部会包含一个内部属性 `__proto__`，它指向构造函数的原型对象。  ```js person1.__proto__ === Person.prototype // true ```  这个`连接`只存在于**实例**与构造函数的**原型对象**之间，而不是存在于实例与构造函数之间，**也就是说这个内部属性和构造函数没有直接的关系。**  ### 原型对象的值不能被实例重写： ```js function Person() {} Person.prototype = {     constructor: Person,     name: "jser",     age: 16,     sayName() {         return this.name;     } } let per1 = new Person(); let per2 = new Person(); per1.name = "zxl"; // 重写 name console.log(per1.name);  // zxl person实例 在自身查到到了 name  console.log(per2.name);  // jser 在原型对象上查找到的 name ``` 可以看到原型对象中的 `name` 没有被改变，`person2.name` 在原型对象上查找的值仍为 `"jser"`。  **原型模式查找属性原则：**  - 在**原型模式**中，当通过实例读取属性值时，首先会在实例自身上查找，如果实例上没有，则就会去原型对象上搜索；  - 如果在**自身**上找到，就使用这个值，不会再继续去原型对象上查找。  ![屏幕快照 2019-09-25 下午5.13.55.png](https://i.loli.net/2019/09/25/QdMBUg5YSR6ce3p.png)  ### 原型模式的动态性：  上文说到不能通过实例对象来重写原型对象上的属性，如果想要重写原型对象上的属性，只能通过原型对象自身去修改。 ```js ... Person.prototype.age = 22; ``` **原型模型原则：由于在原型中查找值的过程是一次搜索，因此在对原型对象做的任何修改都会立即从实例上反映出来，即使是先创建实例后修改原型也如此。** ```js // 先创建实例 后修改原型对象 let per2 = new Person(); Person.prototype.age = 22; console.log(per2.age); // 变成改写后的 22  // 后创建实例 先修改原型对象 Person.prototype.age = 22; let per2 = new Person(); console.log(per2.age); // 变成改写后的 22 ``` **如果先创建了实例，之后用字面量赋值的方式来重写原型对象，这就会切断现有原型对象与之前存在的任何实例之间的联系。** ```js function Person() {} let per1 = new Person(); Person.prototype = {     name: "jser",     age: 16,     sayHi() {         console.log("Hi");     } } per1.sayHi(); ``` 这段代码会报 `Uncaught TypeError: per1.sayHi is not a function`，说明实例 `per1` 没有搜索不到 `sayHi` 这个方法，因为在创建 `per1` 实例之前，`per1.__proto__` 指向的原型对象只有一个默认属性 `constructor`。 ```js { constructor: ƒ } ``` 重写的 `Person.prototype` 被分配在了新的内存空间中：  ![屏幕快照 2019-09-25 下午5.58.18.png](https://i.loli.net/2019/09/25/3nq4eFlfZCEhuNy.png)  ### 原型对象的缺点： **原型对象**的好处是原型中的所有属性和方法可以被很多实例共享。  缺点是当原型中包含引用类型的值的属性时，一个实例对象对这个引用类型的属性做了修改，在其他实例对象中也可以体现出来。  ```js function Person() {} Person.prototype = {     constructor: Person,     name: "jser",     age: 16,     friends: ["javaer", "phper"] } let per1 = new Person(); per1.friends.push("pythener"); let per2 = new Person(); console.log(per2.friends) ``` 原型对象中引用类型属性 `friends` 被修改成了 ` ["javaer", "phper", "pythener"]`，因此实例对象 `per2` 搜索到的结果也被 `per1` 修改了。  ### 从原型对象中体现的一些原型模式的规则可以总结如下：  - 构造函数有一个 `prototype` 指针指向原型对象，构造函数的实例共享原型对象上的属性和方法。  - 实例与原型对象之间有一个 `__proto__` 连接。  - 原型对象上有一个 `constructor` 属性默认指向构造函数，`constructor` 属性上有一个 `prototype` 指针指向原型对象。  - 原型对象上的值不能被实例重写。  - 在原型模式中，通过实例子搜索属性时，实例上的属性会屏蔽原型对象上的同名属性。  - 原型模式中查找值的过程是一次搜索，因此在对原型对象做的任何修改都会立即从实例上反映出来，即使是先创建实例后修改原型也如此。 - 如果先创建了实例，之后用字面量赋值的方式来重写原型对象，这就会切断现有原型对象与之前存在的任何实例之间的联系。  - 原型可以被继承，如通过 `Object.create(prototype, optionalDescriptorObjects)` 来实现原型继承。  ## 2. instanceof 的底层实现原理，手动实现一个 instanceof。  **instanceof**是用来判断 `a` 是否为 `B` 的实例，表达式为：a `instanceof` B，如果 `a` 是 `B` 的实例，则返回 `true`，否则返回 `false`。   **在这里需要特别注意的是：`instanceof` 检测的是原型对象。** ```js // 底层实现原理： instanceof (a,B) = {     var L = a.__proto__;     var R = B.prototype;     if(L === R) {         // A的内部属性 __proto__ 指向 B 的原型对象         return true;     }     return false; } ``` 代码的基本实现： ```js function _instanceof(instance, F) {     if(!F) `Right-hand side of \'instanceof\' is not an object`;     const L = instance.__proto__;     const R = F.prototype;     if(!L) throw `Unexpected identifier`;     if(instance.__proto__ === F.prototype) {         return true;     }     return false; } ```  ## 3. 实现继承的几种方式以及他们的优缺点。  继承的继承方式：`原型链继承`、 `构造继承（call/apply）`、`组合继承`、`寄生组合继承` `ES6继承`。  ### 原型链继承  ##### 首先回顾下构造函数、原型、和实例之间的关系： 每一个构造函数都有一个原型对象 `F.prototype`，原型对象都包含一个指向构造构造的指针 `constructor`，而实例都包含一个指向原型对象的内部指针 `__proto__`。 ```js function F() {} var f = new F() F.prototype.constructor === F; f.__proto__ === F.prototype;  ``` **原型链继承的思想：**将父类的实例作为子类的原型对象。 ```js function Tiger(leg) {     this.leg = leg; } Tiger.prototype.getLeg = function() {     return this.leg; }  function Cat(eat) {     this.eat =  eat; }  // 将 Tiger 的实例对象 Tiger {leg: "四条腿"} 作为 Cat 的原型对象 // 这是一个重写 Cat 原型对象的过程 Cat.prototype = new Tiger("四条腿");    Cat.prototype.getEat = function() {     return this.eat; }  let cat = new Cat("鱼"); console.log(cat.getLeg()); // 四条腿 console.log(cat.getEat()); // 鱼 ``` **原型链继承实际上是重写子类原型对象的过程，子类原型对象的 `constructor` 属性会被默认指向父类。** ```js Cat.prototype.constructor === Tiger; // true ```  **原型链继承的缺点：** 当父类的原型对象修改后，子类也会访问到修改后的结果，父类一变其他都跟着变了。  *遵循了原型模式的动态性（请看第 1 小节）*  ### 构造继承（call/apply）  **构造继承的思想：** 利用 `call` 或 `apply` 将父类的 `this` 硬绑定到子类上。  ```js function Tiger (leg) {     this.leg = leg;     this.getLeg = function () {         return this.leg;     } }; //对原型对象进行的扩展的方法就无法被继承了 Tiger.prototype.getEat = function () {         console.log("吃肉"); };  function Cat(eat) {     // 使用 call 将 this 硬绑定到 Cat 类上     // 创建 Cat 类实例后，实例调用方法时，this 指向 Cat     // console.log(this); Cat      Tiger.call(this, \'四条腿\');　　     this.eat = eat; };  let cat = new Cat("鱼"); console.log(cat.leg);　　　　  // 四条腿 （继承自 Tiger 类） console.log(cat.getEat());　　// 报错 调用不到 Tiger 类原型对象上面的方法　　 ```  **构造继承的缺点：**  - 只能继承父类的实例属性或方法，不能继承父类原型上的属性或方法，无法实现函数复用。  - 每个子类都有父类实例函数的副本，性能会有耗损。  ### 组合继承  **组合继承的思想：**是将`原型链继承`和`构造继承`组合起来使用，是常用的一种继承方式。 ```js function Tiger(leg) {     this.leg = leg; } Tiger.prototype.getLeg = function() {     return this.leg; }  function Cat(eat) {     // 构造继承 使用 call 调用父类 将 this 硬绑定到子类上     // 继承父类的实例属性或方法     Tiger.call(this, "四条腿"); // 第二次调用父类     this.eat =  eat; }  // 使用原型链继承 将 Tiger 的实例对象 Tiger {leg: "四条腿"} 作为 Cat 的原型对象 // 继承父类的原型属性或原型方法 Cat.prototype = new Tiger("四条腿");   // 第一次调用父类  Cat.prototype.getEat = function() {     return this.eat; }  let cat = new Cat("鱼"); // 触发第二次调用 console.log(cat.leg);  // 四条腿 （继承自父的实例属性 ） console.log(cat.getLeg()); // 四条腿 （继承自父类的原型方法） console.log(cat.getEat()); // 鱼 ``` 第一次调用 `Tiger` 构造函数时，`Cat.prototype` 会得到属性 `leg`，它是父类的实例属性，只不过现在位于子类的原型对象中。 当 使用 `new` 调用 `Cat` 构造函数时，又会调用一次 `Tiger` 构造函数，这一次会在 `new` 创建的新对象上创建实例属性 `leg`， 于是这个属性就屏蔽了原型对象上的同名属性。  **组合继承的缺点：** 调用了两次父类，第二次调用父类时，会在新对象上创建实例属性，这会屏蔽存在子类原型对象上的同名属性。  ### 寄生式继承  **寄生继承的思想：**创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。  ```js function cloneObj(parent) {     let clone = object(parent);     clone.getLeg = function() {        return this.leg;     }     return clone; }  // 寄生 function object(obj) {     function F() {};     F.prototype = obj;     return new F(); }  let tiger = {     eat: "肉",     leg: "四条" } let cat = cloneObj(tiger); cat.getLeg();  // 四条 ```  **寄生继承的缺点：**使用寄生式继承为对象添加方法，会由于不能做到方法的复用而降低效率，这一点和构造函数模式类似。   ### 寄生组合继承 **寄生组合继承思想：**是在组合继承的基础上，使用`寄生`方式对组合继承进行的一次优化。 ```js function Tiger(name) {     this.name = name; } Tiger.prototype.leg = "四条腿";  Tiger.prototype.getEat = function() {     return this.eat; } function Cat(eat) {     // 构造继承 使用 call 调用父类 将 this 硬绑定到子类上     // 继承父类的实例属性或方法     Tiger.call(this, "老虎");      this.eat = eat; } // 寄生 !function() {     let F = function() {};         // 创建一个空对象作为寄生     F.prototype = Tiger.prototype; // 将父类的原型对象寄生到空对象的原型对象上     new F().constructor  = Cat;    // 构造指针手动指向子类     Cat.prototype = new F();       // 将空对象的实例作为子类的原型对象 （子类只继承了父类的原型上的方法和属性） }();  let cat = new Cat("鱼"); console.log(cat.eat); // 鱼 // （子类实例自身的属性） console.log(cat.leg); // 四条腿 （继承了父类原型上的属性） console.log(cat.getEat()); ``` **寄生组合继承是实现基于类型的继承的最有效的方式，但是实现起来相对复杂，代码量会很大。**  ### ES6 继承（这里在本节作为了解） ES6 中提供了 `class` 构造函数的写法，对于继承 `class` 可以使用 `extends` 关键字。 ```js class Tiger {     constructor(leg){         this.leg = leg;     }     getLeg() {         console.log(this.leg);     } } class Cat extends Tiger {       constructor(leg, eat) {         super(leg);  //相当于构造继承中的 Tiger.call(this, leg);         this.eat = eat;     }     //子类独有的方法     getEat() {         return this.eat;     } }      const cat = new Cat("四条腿", "鱼");     cat.getLeg();     cat.getEat();     console.log(cat instanceof Cat);    //true     console.log(cat instanceof Tiger);  //true ``` **拓展：**  ```js ES6 提供了 Object.create() 方法也可以实现继承。 语法：Object.create(proto[, propertiesObject]) ```   ## 4. 至少说出一种开源项目(如Node)中应用原型继承的案例。  ## 5. 描述 new 一个对象的详细过程，手动实现一个 new 操作符。  **使用 `new`操作符来调用函数时，会自动执行下面的操作：**  1.创建一个新的空对象；  2.这个对象会被执行 `[[prototpye]]` 连接；  3.这个新对象会绑定到函数调用的 `this`；  4.如果函数没用返回其他对象，那么 `new` 调用的函数会自动返回这个新对象。  **手动实现：** ```js // new 操作符的模拟实现 function _new() {     let o = {}; // 创建一个空对象     let C = arguments[0];  // 获得构造函数     o.constructor = C;     // 将空对象的 constructor 默认指向构造函数     o.__proto___ = C.prototype;  // 进行 [[prototype]] 连接     let res = C.apply(o, arguments);  // 进行 this 绑定 并获得构造函数返回值     // 返回处理     return typeof res === "object" ? res : o; } // 测试 function Person() {     this.name = "jser" } var p = _new(Person); p.name; // ”jser“ p.constructor  // Person ```  ## 6. 理解 es6 中 class 构造以及继承的底层实现原理。 '}]}}]);